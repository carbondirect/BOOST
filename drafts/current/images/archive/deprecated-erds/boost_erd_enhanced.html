<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BOOST ERD - Enhanced D3.js with Schema Integration</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.9);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }
        
        .header h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-weight: 600;
            font-size: 2.5em;
        }
        
        .header p {
            color: #7f8c8d;
            font-size: 16px;
            margin: 0;
        }
        
        .legend {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 12px;
            margin-bottom: 30px;
            padding: 25px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            border-radius: 8px;
            background: rgba(248, 249, 250, 0.8);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }
        
        .legend-item:hover {
            background: rgba(248, 249, 250, 1);
            border-color: rgba(0,0,0,0.1);
            transform: translateY(-1px);
        }
        
        .legend-color {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 1.5px solid;
            flex-shrink: 0;
        }
        
        .controls {
            text-align: center;
            margin-bottom: 25px;
        }
        
        .controls button {
            margin: 0 8px;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: rgba(52, 152, 219, 0.9);
            color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            font-family: inherit;
        }
        
        .controls button:hover {
            background: rgba(41, 128, 185, 1);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }
        
        .controls button.active {
            background: rgba(44, 62, 80, 0.9);
            box-shadow: 0 4px 12px rgba(44, 62, 80, 0.3);
        }
        
        .svg-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            overflow: hidden;
            position: relative;
        }
        
        .entity {
            cursor: pointer;
            transition: all 0.25s ease;
            filter: drop-shadow(0 2px 8px rgba(0,0,0,0.08));
        }
        
        .entity:hover {
            filter: drop-shadow(0 4px 16px rgba(0,0,0,0.15));
            transform: scale(1.02);
        }
        
        .entity-header {
            font-weight: 600;
            font-size: 14px;
            letter-spacing: -0.02em;
        }
        
        .entity-field {
            font-size: 11px;
            fill: #34495e;
            font-weight: 400;
        }
        
        .entity-pk {
            font-weight: 600;
            fill: #e74c3c;
        }
        
        .entity-fk {
            font-weight: 600;
            fill: #3498db;
        }
        
        .entity-required {
            font-weight: 500;
            fill: #2c3e50;
        }
        
        .relationship {
            stroke: #95a5a6;
            stroke-width: 1.5;
            fill: none;
            transition: all 0.2s ease;
        }
        
        .relationship:hover {
            stroke: #34495e;
            stroke-width: 2.5;
        }
        
        .relationship.highlighted {
            stroke: #e74c3c;
            stroke-width: 2.5;
        }
        
        .relationship-label {
            font-size: 10px;
            fill: #7f8c8d;
            text-anchor: middle;
            pointer-events: none;
            font-weight: 500;
        }
        
        /* Crow's foot notation styles */
        .crow-foot-one {
            stroke: #95a5a6;
            stroke-width: 1.5;
            fill: none;
        }
        
        .crow-foot-many {
            stroke: #95a5a6;
            stroke-width: 1.5;
            fill: none;
        }
        
        .tooltip {
            position: absolute;
            padding: 16px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.25s ease;
            z-index: 1000;
            max-width: 320px;
            font-weight: 400;
            line-height: 1.4;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
        }
        
        .tooltip strong {
            font-weight: 600;
            color: #3498db;
        }
        
        .zoom-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .zoom-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            color: #34495e;
            cursor: pointer;
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
        }
        
        .zoom-btn:hover {
            background: white;
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>BOOST Biomass Chain of Custody ERD</h1>
            <p>Interactive D3.js Visualization with Schema Integration & Crow's Foot Notation</p>
        </div>
        
        <div class="legend" id="legend"></div>
        
        <div class="controls">
            <button onclick="showAll()" class="active">Show All</button>
            <button onclick="filterByArea('Core Traceability')">Core Traceability</button>
            <button onclick="filterByArea('Organizational Foundation')">Organizations</button>
            <button onclick="filterByArea('Transaction Management')">Transactions</button>
            <button onclick="resetLayout()">Reset Layout</button>
            <button onclick="exportSVG()">Export SVG</button>
        </div>
        
        <div class="svg-container">
            <div class="zoom-controls">
                <button class="zoom-btn" onclick="zoomIn()">+</button>
                <button class="zoom-btn" onclick="zoomOut()">−</button>
                <button class="zoom-btn" onclick="resetZoom()">⌂</button>
            </div>
            <svg id="erd-svg" width="1600" height="1200"></svg>
        </div>
        
        <div class="tooltip" id="tooltip"></div>
    </div>

    <script>
        // Enhanced configuration with better aesthetics
        const config = {
            width: 1600,
            height: 1200,
            entityWidth: 220,
            entityFieldHeight: 18,
            entityPadding: 12,
            headerHeight: 36,
            colors: {
                'Core Traceability': { 
                    fill: 'rgba(232, 245, 232, 0.9)', 
                    stroke: '#2e7d32', 
                    header: '#2e7d32',
                    text: '#1b5e20' 
                },
                'Organizational Foundation': { 
                    fill: 'rgba(227, 242, 253, 0.9)', 
                    stroke: '#1976d2', 
                    header: '#1976d2',
                    text: '#0d47a1' 
                },
                'Material & Supply Chain': { 
                    fill: 'rgba(239, 235, 233, 0.9)', 
                    stroke: '#8d6e63', 
                    header: '#8d6e63',
                    text: '#5d4037' 
                },
                'Transaction Management': { 
                    fill: 'rgba(255, 243, 224, 0.9)', 
                    stroke: '#ff8f00', 
                    header: '#ff8f00',
                    text: '#e65100' 
                },
                'Sustainability & Claims': { 
                    fill: 'rgba(255, 253, 231, 0.9)', 
                    stroke: '#fbc02d', 
                    header: '#fbc02d',
                    text: '#f57f17' 
                },
                'Geographic & Location': { 
                    fill: 'rgba(243, 229, 245, 0.9)', 
                    stroke: '#7b1fa2', 
                    header: '#7b1fa2',
                    text: '#4a148c' 
                },
                'Reporting & Compliance': { 
                    fill: 'rgba(255, 235, 238, 0.9)', 
                    stroke: '#d32f2f', 
                    header: '#d32f2f',
                    text: '#b71c1c' 
                },
                'Analytics & Data Management': { 
                    fill: 'rgba(250, 250, 250, 0.9)', 
                    stroke: '#616161', 
                    header: '#616161',
                    text: '#424242' 
                },
                'Personnel Management': { 
                    fill: 'rgba(255, 248, 225, 0.9)', 
                    stroke: '#795548', 
                    header: '#795548',
                    text: '#5d4037' 
                }
            }
        };

        // Schema-driven entity definitions
        const schemaEntities = [
            {
                id: 'TraceableUnit',
                name: 'TraceableUnit',
                area: 'Core Traceability',
                description: 'Central entity for biomass tracking with moisture content integration',
                schema: {
                    properties: {
                        'traceableUnitId': { type: 'string', isPK: true, required: true, description: 'Unique ID for each TRU' },
                        'unitType': { type: 'enum', required: true, description: 'individual_log, pile, volume_aggregation, processed_batch' },
                        'totalVolumeM3': { type: 'number', required: true, description: 'Total volume in cubic meters' },
                        'currentMoistureContent': { type: 'number', description: 'Current moisture content percentage' },
                        'currentGeographicDataId': { type: 'string', isFK: true, description: 'Foreign key to current location' },
                        'harvestGeographicDataId': { type: 'string', isFK: true, description: 'Foreign key to harvest location' },
                        'operatorId': { type: 'string', isFK: true, description: 'Foreign key to operator' },
                        'materialTypeId': { type: 'string', isFK: true, required: true, description: 'Foreign key to Material entity' }
                    }
                },
                x: 700, y: 300
            },
            {
                id: 'MaterialProcessing',
                name: 'MaterialProcessing',
                area: 'Core Traceability',
                description: 'Processing operations that transform TRUs',
                schema: {
                    properties: {
                        'processingId': { type: 'string', isPK: true, required: true, description: 'Processing operation ID' },
                        'inputTraceableUnitId': { type: 'string', isFK: true, required: true, description: 'Input TRU being processed' },
                        'outputTraceableUnitId': { type: 'string', isFK: true, description: 'Output TRU created' },
                        'processType': { type: 'enum', required: true, description: 'felling, delimbing, crosscutting, chipping' },
                        'operatorId': { type: 'string', isFK: true, description: 'Operator performing processing' },
                        'inputVolume': { type: 'number', description: 'Input volume before processing' },
                        'outputVolume': { type: 'number', description: 'Output volume after processing' }
                    }
                },
                x: 400, y: 500
            },
            {
                id: 'Organization',
                name: 'Organization',
                area: 'Organizational Foundation',
                description: 'Business entities in the supply chain',
                schema: {
                    properties: {
                        'organizationId': { type: 'string', isPK: true, required: true, description: 'Unique organization identifier' },
                        'organizationName': { type: 'string', required: true, description: 'Legal name of organization' },
                        'organizationType': { type: 'enum', required: true, description: 'harvester, processor, certifier, transporter' },
                        'primaryGeographicDataId': { type: 'string', isFK: true, description: 'Primary operational location' },
                        'contactEmail': { type: 'string', description: 'Primary contact email' },
                        'certifications': { type: 'array', description: 'List of certification IDs' }
                    }
                },
                x: 100, y: 200
            },
            {
                id: 'Transaction',
                name: 'Transaction',
                area: 'Transaction Management',
                description: 'Business transactions between organizations',
                schema: {
                    properties: {
                        'transactionId': { type: 'string', isPK: true, required: true, description: 'Transaction identifier' },
                        'supplyingOrganizationId': { type: 'string', isFK: true, required: true, description: 'Seller organization' },
                        'customerOrganizationId': { type: 'string', isFK: true, required: true, description: 'Buyer organization' },
                        'contractValue': { type: 'number', description: 'Total transaction value' },
                        'transactionStatus': { type: 'enum', description: 'pending, confirmed, delivered, completed' }
                    }
                },
                x: 1200, y: 300
            },
            {
                id: 'GeographicData',
                name: 'GeographicData',
                area: 'Geographic & Location',
                description: 'Spatial data and location information using GeoJSON',
                schema: {
                    properties: {
                        'geographicDataId': { type: 'string', isPK: true, required: true, description: 'Geographic identifier' },
                        'geoJsonData': { type: 'json', required: true, description: 'Valid GeoJSON object' },
                        'dataType': { type: 'enum', description: 'harvest_site, processing_location, administrative_boundary' },
                        'description': { type: 'string', description: 'Human-readable area description' }
                    }
                },
                x: 700, y: 100
            },
            {
                id: 'Operator',
                name: 'Operator',
                area: 'Personnel Management',
                description: 'Personnel performing operations with certifications',
                schema: {
                    properties: {
                        'operatorId': { type: 'string', isPK: true, required: true, description: 'Operator identifier' },
                        'organizationId': { type: 'string', isFK: true, required: true, description: 'Employing organization' },
                        'operatorName': { type: 'string', required: true, description: 'Full name of operator' },
                        'operatorType': { type: 'enum', required: true, description: 'harvester_operator, mill_operator, transport_driver' },
                        'certifications': { type: 'array', description: 'Required certifications held' },
                        'equipmentAuthorizations': { type: 'array', description: 'Equipment authorized to use' }
                    }
                },
                x: 400, y: 700
            }
        ];

        // Enhanced relationships with crow's foot notation
        const relationships = [
            { from: 'TraceableUnit', to: 'MaterialProcessing', label: 'undergoes', fromCard: 'one', toCard: 'many', type: 'identifying' },
            { from: 'MaterialProcessing', to: 'TraceableUnit', label: 'creates', fromCard: 'one', toCard: 'one', type: 'non-identifying' },
            { from: 'Organization', to: 'TraceableUnit', label: 'manages', fromCard: 'one', toCard: 'many', type: 'non-identifying' },
            { from: 'Organization', to: 'Transaction', label: 'creates', fromCard: 'one', toCard: 'many', type: 'identifying' },
            { from: 'Organization', to: 'Operator', label: 'employs', fromCard: 'one', toCard: 'many', type: 'identifying' },
            { from: 'GeographicData', to: 'TraceableUnit', label: 'locates', fromCard: 'one', toCard: 'many', type: 'non-identifying' },
            { from: 'Operator', to: 'MaterialProcessing', label: 'performs', fromCard: 'one', toCard: 'many', type: 'non-identifying' }
        ];

        // Initialize D3 visualization
        const svg = d3.select('#erd-svg');
        const tooltip = d3.select('#tooltip');
        
        // Add zoom and pan
        const g = svg.append('g');
        const zoom = d3.zoom()
            .scaleExtent([0.1, 3])
            .on('zoom', (event) => {
                g.attr('transform', event.transform);
            });
        svg.call(zoom);

        let currentFilter = null;

        function createLegend() {
            const legend = d3.select('#legend');
            const areas = [...new Set(schemaEntities.map(e => e.area))];
            
            areas.forEach(area => {
                const entityCount = schemaEntities.filter(e => e.area === area).length;
                const item = legend.append('div')
                    .attr('class', 'legend-item')
                    .style('cursor', 'pointer')
                    .on('click', () => filterByArea(area));
                
                item.append('div')
                    .attr('class', 'legend-color')
                    .style('background-color', config.colors[area].fill)
                    .style('border-color', config.colors[area].stroke);
                
                const textDiv = item.append('div');
                textDiv.append('div')
                    .style('font-weight', '600')
                    .style('color', config.colors[area].text)
                    .text(area);
                textDiv.append('div')
                    .style('font-size', '11px')
                    .style('color', '#7f8c8d')
                    .text(`${entityCount} ${entityCount === 1 ? 'entity' : 'entities'}`);
            });
        }

        function drawEntity(entity) {
            const color = config.colors[entity.area];
            const fields = Object.entries(entity.schema.properties);
            const displayFields = fields.slice(0, 8); // Limit to 8 fields for better display
            const entityHeight = config.headerHeight + (displayFields.length * config.entityFieldHeight) + (config.entityPadding * 2);
            
            const g = svg.select('g').append('g')
                .attr('class', 'entity')
                .attr('data-area', entity.area)
                .attr('data-id', entity.id);

            // Main entity rectangle with subtle shadow
            const mainRect = g.append('rect')
                .attr('x', entity.x)
                .attr('y', entity.y)
                .attr('width', config.entityWidth)
                .attr('height', entityHeight)
                .attr('fill', color.fill)
                .attr('stroke', color.stroke)
                .attr('stroke-width', 1.5)
                .attr('rx', 8);

            // Header rectangle with stronger color
            g.append('rect')
                .attr('x', entity.x)
                .attr('y', entity.y)
                .attr('width', config.entityWidth)
                .attr('height', config.headerHeight)
                .attr('fill', color.header)
                .attr('rx', 8);
                
            // Fix header bottom corners
            g.append('rect')
                .attr('x', entity.x)
                .attr('y', entity.y + config.headerHeight - 8)
                .attr('width', config.entityWidth)
                .attr('height', 8)
                .attr('fill', color.header);

            // Entity name in header
            g.append('text')
                .attr('class', 'entity-header')
                .attr('x', entity.x + config.entityWidth / 2)
                .attr('y', entity.y + config.headerHeight / 2 + 5)
                .attr('text-anchor', 'middle')
                .attr('fill', 'white')
                .text(entity.name);

            // Separator line
            g.append('line')
                .attr('x1', entity.x)
                .attr('y1', entity.y + config.headerHeight)
                .attr('x2', entity.x + config.entityWidth)
                .attr('y2', entity.y + config.headerHeight)
                .attr('stroke', color.stroke)
                .attr('stroke-width', 1);

            // Fields with improved styling
            displayFields.forEach(([fieldName, fieldInfo], i) => {
                const fieldY = entity.y + config.headerHeight + config.entityPadding + (i * config.entityFieldHeight);
                let fieldClass = 'entity-field';
                let prefix = '';
                
                if (fieldInfo.isPK) {
                    fieldClass = 'entity-pk';
                    prefix = 'PK ';
                } else if (fieldInfo.isFK) {
                    fieldClass = 'entity-fk';
                    prefix = 'FK ';
                } else if (fieldInfo.required) {
                    fieldClass = 'entity-required';
                }
                
                const displayType = fieldInfo.type === 'enum' ? 'enum' : fieldInfo.type;
                
                g.append('text')
                    .attr('class', fieldClass)
                    .attr('x', entity.x + 12)
                    .attr('y', fieldY)
                    .text(`${prefix}${fieldName}: ${displayType}`);
            });

            // Show "..." if there are more fields
            if (fields.length > 8) {
                const moreY = entity.y + config.headerHeight + config.entityPadding + (8 * config.entityFieldHeight);
                g.append('text')
                    .attr('class', 'entity-field')
                    .attr('x', entity.x + 12)
                    .attr('y', moreY)
                    .style('font-style', 'italic')
                    .style('fill', '#95a5a6')
                    .text(`... and ${fields.length - 8} more fields`);
            }

            // Enhanced hover effects
            g.on('mouseover', function(event) {
                const fieldsText = Object.entries(entity.schema.properties)
                    .slice(0, 5)
                    .map(([name, info]) => `• ${name} (${info.type})${info.required ? ' *' : ''}`)
                    .join('<br/>');
                
                tooltip.style('opacity', 1)
                    .html(`<strong>${entity.name}</strong><br/>${entity.description}<br/><br/><em>Key Fields:</em><br/>${fieldsText}<br/><br/><small>Area: ${entity.area}</small>`)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
            })
            .on('mouseout', function() {
                tooltip.style('opacity', 0);
            })
            .on('click', function() {
                highlightRelationships(entity.id);
            });

            return { entity, height: entityHeight };
        }

        function drawCrowsFootRelationships() {
            relationships.forEach(rel => {
                const fromEntity = schemaEntities.find(e => e.id === rel.from);
                const toEntity = schemaEntities.find(e => e.id === rel.to);
                
                if (fromEntity && toEntity) {
                    drawCrowsFootRelationship(fromEntity, toEntity, rel);
                }
            });
        }

        function drawCrowsFootRelationship(fromEntity, toEntity, relationship) {
            const g = svg.select('g').append('g')
                .attr('class', 'relationship-group')
                .attr('data-from', relationship.from)
                .attr('data-to', relationship.to);

            // Calculate connection points with smart routing
            const fromX = fromEntity.x + config.entityWidth / 2;
            const fromY = fromEntity.y + 150; // Approximate entity bottom
            const toX = toEntity.x + config.entityWidth / 2;
            const toY = toEntity.y + 20; // Approximate entity top

            // Create path with rounded corners to avoid entities
            const midY = fromY + (toY - fromY) / 2;
            const pathData = `M ${fromX} ${fromY} L ${fromX} ${midY} L ${toX} ${midY} L ${toX} ${toY}`;

            // Main relationship line
            const line = g.append('path')
                .attr('class', 'relationship')
                .attr('d', pathData)
                .attr('stroke', relationship.type === 'identifying' ? '#34495e' : '#95a5a6')
                .attr('stroke-width', relationship.type === 'identifying' ? 2 : 1.5)
                .attr('stroke-dasharray', relationship.type === 'identifying' ? 'none' : '5,5');

            // Draw crow's foot notation at the "to" end
            if (relationship.toCard === 'many') {
                drawCrowsFoot(g, toX, toY, true);
            } else {
                drawSingleLine(g, toX, toY, true);
            }

            // Draw single line or circle at the "from" end
            if (relationship.fromCard === 'one') {
                drawSingleLine(g, fromX, fromY, false);
            }

            // Relationship label
            g.append('text')
                .attr('class', 'relationship-label')
                .attr('x', fromX + (toX - fromX) / 2)
                .attr('y', midY - 5)
                .text(relationship.label);
        }

        function drawCrowsFoot(g, x, y, isTo) {
            const direction = isTo ? -1 : 1;
            const footY = y + (direction * 12);
            
            // Three lines forming crow's foot
            g.append('line')
                .attr('class', 'crow-foot-many')
                .attr('x1', x)
                .attr('y1', y)
                .attr('x2', x - 8)
                .attr('y2', footY);
            
            g.append('line')
                .attr('class', 'crow-foot-many')
                .attr('x1', x)
                .attr('y1', y)
                .attr('x2', x)
                .attr('y2', footY);
            
            g.append('line')
                .attr('class', 'crow-foot-many')
                .attr('x1', x)
                .attr('y1', y)
                .attr('x2', x + 8)
                .attr('y2', footY);
        }

        function drawSingleLine(g, x, y, isTo) {
            const direction = isTo ? -1 : 1;
            const lineY = y + (direction * 8);
            
            g.append('line')
                .attr('class', 'crow-foot-one')
                .attr('x1', x - 6)
                .attr('y1', lineY)
                .attr('x2', x + 6)
                .attr('y2', lineY);
        }

        // Control functions
        function showAll() {
            currentFilter = null;
            svg.selectAll('.entity').style('opacity', 1);
            svg.selectAll('.relationship-group').style('opacity', 1);
            updateActiveButton(event.target);
        }

        function filterByArea(area) {
            currentFilter = area;
            svg.selectAll('.entity').style('opacity', function() {
                return d3.select(this).attr('data-area') === area ? 1 : 0.2;
            });
            svg.selectAll('.relationship-group').style('opacity', 0.3);
            updateActiveButton(event.target);
        }

        function highlightRelationships(entityId) {
            svg.selectAll('.relationship-group').style('opacity', function() {
                const from = d3.select(this).attr('data-from');
                const to = d3.select(this).attr('data-to');
                return (from === entityId || to === entityId) ? 1 : 0.2;
            });
            
            svg.selectAll('.entity').style('opacity', function() {
                const id = d3.select(this).attr('data-id');
                const isConnected = relationships.some(rel => 
                    (rel.from === entityId && rel.to === id) || 
                    (rel.to === entityId && rel.from === id)
                );
                return (id === entityId || isConnected) ? 1 : 0.3;
            });
        }

        function resetLayout() {
            showAll();
            resetZoom();
        }

        function updateActiveButton(button) {
            d3.selectAll('.controls button').classed('active', false);
            d3.select(button).classed('active', true);
        }

        // Zoom controls
        function zoomIn() {
            svg.transition().call(zoom.scaleBy, 1.5);
        }

        function zoomOut() {
            svg.transition().call(zoom.scaleBy, 1 / 1.5);
        }

        function resetZoom() {
            svg.transition().call(zoom.transform, d3.zoomIdentity);
        }

        function exportSVG() {
            const svgElement = document.getElementById('erd-svg');
            const serializer = new XMLSerializer();
            const svgString = serializer.serializeToString(svgElement);
            const blob = new Blob([svgString], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'boost-erd-enhanced.svg';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Initialize the visualization
        function init() {
            createLegend();
            schemaEntities.forEach(entity => drawEntity(entity));
            drawCrowsFootRelationships();
        }

        // Start the visualization
        init();
    </script>
</body>
</html>