<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BOOST ERD - No Overlap Solution</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=SF+Pro+Display:wght@300;400;500;600&family=SF+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
            margin: 0;
            padding: 24px;
            background: #fafbfc;
            color: #24292f;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .container {
            max-width: 2000px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 24px;
            background: white;
            padding: 24px;
            border-radius: 12px;
            border: 1px solid #d1d9e0;
            box-shadow: 0 1px 3px rgba(16, 24, 40, 0.04);
        }
        
        .header h1 {
            color: #101828;
            margin: 0 0 8px 0;
            font-weight: 600;
            font-size: 28px;
            letter-spacing: -0.02em;
        }
        
        .header p {
            color: #667085;
            font-size: 15px;
            margin: 0;
            font-weight: 400;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
        }
        
        .btn {
            padding: 8px 16px;
            border: 1px solid #d1d9e0;
            border-radius: 6px;
            background: white;
            color: #374151;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            font-family: inherit;
            transition: all 0.15s ease;
        }
        
        .btn:hover {
            background: #f9fafb;
            border-color: #9ca3af;
        }
        
        .btn.active {
            background: #1f2937;
            color: white;
            border-color: #1f2937;
        }
        
        .svg-container {
            background: white;
            border-radius: 12px;
            border: 1px solid #d1d9e0;
            box-shadow: 0 1px 3px rgba(16, 24, 40, 0.04);
            overflow: hidden;
            position: relative;
        }
        
        .entity {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .entity:hover {
            filter: drop-shadow(0 4px 12px rgba(0,0,0,0.1));
        }
        
        .entity-header {
            font-family: 'SF Pro Display', system-ui, sans-serif;
            font-weight: 600;
            font-size: 13px;
            letter-spacing: -0.01em;
        }
        
        .entity-field {
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 11px;
            fill: #374151;
            font-weight: 400;
        }
        
        .entity-pk {
            font-family: 'SF Mono', monospace;
            font-weight: 500;
            font-size: 11px;
            fill: #dc2626;
        }
        
        .entity-fk {
            font-family: 'SF Mono', monospace;
            font-weight: 500;
            font-size: 11px;
            fill: #2563eb;
        }
        
        .entity-required {
            font-family: 'SF Mono', monospace;
            font-weight: 500;
            font-size: 11px;
            fill: #1f2937;
        }
        
        .relationship {
            fill: none;
            transition: all 0.15s ease;
        }
        
        .relationship-identifying {
            stroke: #374151;
            stroke-width: 1;
        }
        
        .relationship-non-identifying {
            stroke: #9ca3af;
            stroke-width: 1;
            stroke-dasharray: 3,2;
        }
        
        .relationship:hover {
            stroke: #1f2937 !important;
            stroke-width: 2 !important;
        }
        
        .relationship-label {
            font-size: 10px;
            fill: #6b7280;
            text-anchor: middle;
            pointer-events: none;
            font-weight: 500;
            background: white;
            padding: 2px;
        }
        
        .crowsfoot-line {
            stroke: #374151;
            stroke-width: 1;
            fill: none;
        }
        
        .tooltip {
            position: absolute;
            padding: 12px;
            background: rgba(17, 24, 39, 0.95);
            color: white;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 1000;
            max-width: 300px;
            font-weight: 400;
            line-height: 1.4;
            backdrop-filter: blur(8px);
        }
        
        .tooltip code {
            background: rgba(255,255,255,0.1);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'SF Mono', monospace;
        }

        .simulation-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .sim-btn {
            width: 100px;
            padding: 6px 12px;
            border: 1px solid #d1d9e0;
            border-radius: 6px;
            background: white;
            color: #374151;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            font-family: inherit;
        }

        .sim-btn:hover {
            background: #f9fafb;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>BOOST ERD</h1>
            <p>Force-directed layout with intelligent relationship routing</p>
        </div>
        
        <div class="controls">
            <button class="btn active" onclick="showAll()">All Entities</button>
            <button class="btn" onclick="filterByArea('Core Traceability')">Core Traceability</button>
            <button class="btn" onclick="filterByArea('Organizational')">Organizations</button>
            <button class="btn" onclick="filterByArea('Transaction')">Transactions</button>
            <button class="btn" onclick="resetLayout()">Reset Layout</button>
            <button class="btn" onclick="exportDiagram()">Export SVG</button>
        </div>
        
        <div class="svg-container">
            <div class="simulation-controls">
                <button class="sim-btn" onclick="restartSimulation()">Restart Layout</button>
                <button class="sim-btn" onclick="stopSimulation()">Stop Physics</button>
            </div>
            <svg id="erd-svg" width="2000" height="1400"></svg>
        </div>
        
        <div class="tooltip" id="tooltip"></div>
    </div>

    <script>
        // Configuration
        const config = {
            width: 2000,
            height: 1400,
            entityWidth: 240,
            entityFieldHeight: 16,
            entityPadding: 8,
            headerHeight: 28,
            colors: {
                'Core Traceability': { 
                    fill: 'rgba(220, 252, 231, 0.25)', 
                    stroke: '#10b981', 
                    header: '#059669'
                },
                'Organizational': { 
                    fill: 'rgba(219, 234, 254, 0.25)', 
                    stroke: '#3b82f6', 
                    header: '#2563eb'
                },
                'Transaction': { 
                    fill: 'rgba(254, 243, 199, 0.25)', 
                    stroke: '#f59e0b', 
                    header: '#d97706'
                },
                'Material': { 
                    fill: 'rgba(231, 229, 228, 0.25)', 
                    stroke: '#78716c', 
                    header: '#57534e'
                },
                'Geographic': { 
                    fill: 'rgba(243, 232, 255, 0.25)', 
                    stroke: '#a855f7', 
                    header: '#9333ea'
                },
                'Personnel': { 
                    fill: 'rgba(254, 242, 242, 0.25)', 
                    stroke: '#ef4444', 
                    header: '#dc2626'
                }
            }
        };

        // Entities with calculated dimensions
        const entities = [
            {
                id: 'TraceableUnit',
                name: 'TraceableUnit',
                area: 'Core Traceability',
                description: 'Central entity for biomass tracking with Kaulen framework integration',
                fields: [
                    { name: 'traceableUnitId', type: 'string', isPK: true, required: true },
                    { name: 'unitType', type: 'enum', required: true },
                    { name: 'uniqueIdentifier', type: 'string', required: true },
                    { name: 'totalVolumeM3', type: 'number', required: true },
                    { name: 'currentMoistureContent', type: 'number' },
                    { name: 'currentGeographicDataId', type: 'string', isFK: true },
                    { name: 'operatorId', type: 'string', isFK: true },
                    { name: 'materialTypeId', type: 'string', isFK: true, required: true }
                ]
            },
            {
                id: 'MaterialProcessing',
                name: 'MaterialProcessing', 
                area: 'Core Traceability',
                description: 'Processing operations that transform TRUs',
                fields: [
                    { name: 'processingId', type: 'string', isPK: true, required: true },
                    { name: 'inputTraceableUnitId', type: 'string', isFK: true, required: true },
                    { name: 'outputTraceableUnitId', type: 'string', isFK: true },
                    { name: 'processType', type: 'enum', required: true },
                    { name: 'operatorId', type: 'string', isFK: true },
                    { name: 'inputVolume', type: 'number' },
                    { name: 'outputVolume', type: 'number' }
                ]
            },
            {
                id: 'ProcessingHistory',
                name: 'ProcessingHistory',
                area: 'Core Traceability', 
                description: 'Complete timeline of processing events',
                fields: [
                    { name: 'processingHistoryId', type: 'string', isPK: true, required: true },
                    { name: 'traceableUnitId', type: 'string', isFK: true, required: true },
                    { name: 'materialProcessingId', type: 'string', isFK: true },
                    { name: 'processSequenceNumber', type: 'integer' },
                    { name: 'inputMoistureContent', type: 'number' },
                    { name: 'outputMoistureContent', type: 'number' }
                ]
            },
            {
                id: 'Organization',
                name: 'Organization',
                area: 'Organizational',
                description: 'Business entities in the BOOST supply chain',
                fields: [
                    { name: 'organizationId', type: 'string', isPK: true, required: true },
                    { name: 'organizationName', type: 'string', required: true },
                    { name: 'organizationType', type: 'enum', required: true },
                    { name: 'primaryGeographicDataId', type: 'string', isFK: true },
                    { name: 'contactEmail', type: 'string' }
                ]
            },
            {
                id: 'Transaction',
                name: 'Transaction',
                area: 'Transaction',
                description: 'Business transactions between organizations',
                fields: [
                    { name: 'transactionId', type: 'string', isPK: true, required: true },
                    { name: 'supplyingOrganizationId', type: 'string', isFK: true, required: true },
                    { name: 'customerOrganizationId', type: 'string', isFK: true, required: true },
                    { name: 'contractValue', type: 'number' },
                    { name: 'transactionStatus', type: 'enum' },
                    { name: 'transactionDate', type: 'date', required: true }
                ]
            },
            {
                id: 'GeographicData',
                name: 'GeographicData',
                area: 'Geographic',
                description: 'Spatial data and location information',
                fields: [
                    { name: 'geographicDataId', type: 'string', isPK: true, required: true },
                    { name: 'geoJsonData', type: 'json', required: true },
                    { name: 'dataType', type: 'enum' },
                    { name: 'description', type: 'string' }
                ]
            },
            {
                id: 'Material',
                name: 'Material',
                area: 'Material',
                description: 'Material types and specifications',
                fields: [
                    { name: 'materialTypeId', type: 'string', isPK: true, required: true },
                    { name: 'materialName', type: 'string', required: true },
                    { name: 'materialCategory', type: 'enum' },
                    { name: 'applicablePlantParts', type: 'string[]' }
                ]
            },
            {
                id: 'Operator',
                name: 'Operator',
                area: 'Personnel',
                description: 'Personnel performing operations',
                fields: [
                    { name: 'operatorId', type: 'string', isPK: true, required: true },
                    { name: 'organizationId', type: 'string', isFK: true, required: true },
                    { name: 'operatorName', type: 'string', required: true },
                    { name: 'operatorType', type: 'enum', required: true },
                    { name: 'certifications', type: 'string[]' }
                ]
            }
        ];

        // Calculate entity dimensions
        entities.forEach(entity => {
            const visibleFields = Math.min(entity.fields.length, 6);
            entity.height = config.headerHeight + (visibleFields * config.entityFieldHeight) + (config.entityPadding * 2) + 4;
            entity.width = config.entityWidth;
        });

        // Relationships
        const relationships = [
            { from: 'TraceableUnit', to: 'MaterialProcessing', label: 'input_to', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'MaterialProcessing', to: 'TraceableUnit', label: 'creates', type: 'identifying', fromCard: 'one', toCard: 'one' },
            { from: 'TraceableUnit', to: 'ProcessingHistory', label: 'has_history', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'MaterialProcessing', to: 'ProcessingHistory', label: 'documented_by', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'Organization', to: 'TraceableUnit', label: 'manages', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'Organization', to: 'Transaction', label: 'supplies', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'Organization', to: 'Operator', label: 'employs', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'Operator', to: 'MaterialProcessing', label: 'performs', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'GeographicData', to: 'TraceableUnit', label: 'locates', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'Material', to: 'TraceableUnit', label: 'defines_type', type: 'non-identifying', fromCard: 'one', toCard: 'many' }
        ];

        // D3 Setup
        const svg = d3.select('#erd-svg');
        const tooltip = d3.select('#tooltip');
        
        let simulation;
        let entityElements;
        let relationshipElements;

        // Force simulation for entity positioning
        function createForceSimulation() {
            simulation = d3.forceSimulation(entities)
                .force('link', d3.forceLink(relationships)
                    .id(d => d.id)
                    .distance(300)
                    .strength(0.3)
                )
                .force('charge', d3.forceManyBody()
                    .strength(-8000)
                    .distanceMax(500)
                )
                .force('center', d3.forceCenter(config.width / 2, config.height / 2))
                .force('collision', d3.forceCollide()
                    .radius(d => Math.max(d.width, d.height) / 2 + 50)
                    .strength(0.8)
                )
                .force('x', d3.forceX()
                    .x(d => {
                        // Bias entities toward their functional area positions
                        const areaPositions = {
                            'Core Traceability': config.width * 0.5,
                            'Organizational': config.width * 0.2,
                            'Transaction': config.width * 0.8,
                            'Geographic': config.width * 0.5,
                            'Material': config.width * 0.7,
                            'Personnel': config.width * 0.3
                        };
                        return areaPositions[d.area] || config.width / 2;
                    })
                    .strength(0.1)
                )
                .force('y', d3.forceY()
                    .y(d => {
                        const areaPositions = {
                            'Core Traceability': config.height * 0.5,
                            'Organizational': config.height * 0.4,
                            'Transaction': config.height * 0.4,
                            'Geographic': config.height * 0.2,
                            'Material': config.height * 0.2,
                            'Personnel': config.height * 0.7
                        };
                        return areaPositions[d.area] || config.height / 2;
                    })
                    .strength(0.1)
                );
        }

        // A* pathfinding for relationship routing
        function findPath(start, end, obstacles) {
            const grid = createGrid(obstacles);
            const path = aStar(grid, start, end);
            return path;
        }

        function createGrid(obstacles) {
            const cellSize = 20;
            const cols = Math.ceil(config.width / cellSize);
            const rows = Math.ceil(config.height / cellSize);
            const grid = [];

            for (let y = 0; y < rows; y++) {
                grid[y] = [];
                for (let x = 0; x < cols; x++) {
                    const worldX = x * cellSize;
                    const worldY = y * cellSize;
                    let blocked = false;

                    // Check if this cell intersects with any entity
                    for (let obstacle of obstacles) {
                        if (worldX < obstacle.x + obstacle.width + 20 &&
                            worldX + cellSize > obstacle.x - 20 &&
                            worldY < obstacle.y + obstacle.height + 20 &&
                            worldY + cellSize > obstacle.y - 20) {
                            blocked = true;
                            break;
                        }
                    }

                    grid[y][x] = {
                        x, y, worldX, worldY, blocked,
                        g: 0, h: 0, f: 0, parent: null
                    };
                }
            }
            return grid;
        }

        function aStar(grid, start, end) {
            const cellSize = 20;
            const startNode = grid[Math.floor(start.y / cellSize)][Math.floor(start.x / cellSize)];
            const endNode = grid[Math.floor(end.y / cellSize)][Math.floor(end.x / cellSize)];
            
            const openSet = [startNode];
            const closedSet = [];

            while (openSet.length > 0) {
                let current = openSet[0];
                for (let i = 1; i < openSet.length; i++) {
                    if (openSet[i].f < current.f) {
                        current = openSet[i];
                    }
                }

                openSet.splice(openSet.indexOf(current), 1);
                closedSet.push(current);

                if (current === endNode) {
                    const path = [];
                    let curr = current;
                    while (curr) {
                        path.unshift({ x: curr.worldX, y: curr.worldY });
                        curr = curr.parent;
                    }
                    return path;
                }

                const neighbors = getNeighbors(grid, current);
                for (let neighbor of neighbors) {
                    if (closedSet.includes(neighbor) || neighbor.blocked) continue;

                    const tentativeG = current.g + 1;
                    if (!openSet.includes(neighbor)) {
                        openSet.push(neighbor);
                    } else if (tentativeG >= neighbor.g) {
                        continue;
                    }

                    neighbor.parent = current;
                    neighbor.g = tentativeG;
                    neighbor.h = Math.abs(neighbor.x - endNode.x) + Math.abs(neighbor.y - endNode.y);
                    neighbor.f = neighbor.g + neighbor.h;
                }
            }
            
            // If no path found, return direct line
            return [start, end];
        }

        function getNeighbors(grid, node) {
            const neighbors = [];
            const { x, y } = node;
            const rows = grid.length;
            const cols = grid[0].length;

            if (x > 0) neighbors.push(grid[y][x - 1]);
            if (x < cols - 1) neighbors.push(grid[y][x + 1]);
            if (y > 0) neighbors.push(grid[y - 1][x]);
            if (y < rows - 1) neighbors.push(grid[y + 1][x]);

            return neighbors;
        }

        // Draw entity
        function drawEntity(entity) {
            const color = config.colors[entity.area] || { fill: '#f3f4f6', stroke: '#9ca3af', header: '#6b7280' };
            const visibleFields = entity.fields.slice(0, 6);
            
            const g = svg.append('g')
                .attr('class', 'entity')
                .attr('data-area', entity.area)
                .attr('data-id', entity.id);

            // Entity background
            const rect = g.append('rect')
                .attr('width', entity.width)
                .attr('height', entity.height)
                .attr('fill', color.fill)
                .attr('stroke', color.stroke)
                .attr('stroke-width', 1)
                .attr('rx', 6);

            // Header
            g.append('rect')
                .attr('width', entity.width)
                .attr('height', config.headerHeight)
                .attr('fill', color.header)
                .attr('rx', 6);
                
            g.append('rect')
                .attr('y', config.headerHeight - 6)
                .attr('width', entity.width)
                .attr('height', 6)
                .attr('fill', color.header);

            // Entity name
            g.append('text')
                .attr('class', 'entity-header')
                .attr('x', entity.width / 2)
                .attr('y', config.headerHeight / 2 + 4)
                .attr('text-anchor', 'middle')
                .attr('fill', 'white')
                .text(entity.name);

            // Fields
            visibleFields.forEach((field, i) => {
                const fieldY = config.headerHeight + config.entityPadding + (i * config.entityFieldHeight) + 12;
                let fieldClass = 'entity-field';
                
                if (field.isPK) fieldClass = 'entity-pk';
                else if (field.isFK) fieldClass = 'entity-fk';
                else if (field.required) fieldClass = 'entity-required';
                
                const prefix = field.isPK ? 'PK ' : field.isFK ? 'FK ' : field.required ? 'â€¢ ' : '  ';
                
                g.append('text')
                    .attr('class', fieldClass)
                    .attr('x', 8)
                    .attr('y', fieldY)
                    .text(`${prefix}${field.name}: ${field.type}`);
            });

            // More fields indicator
            if (entity.fields.length > 6) {
                g.append('text')
                    .attr('class', 'entity-field')
                    .attr('x', 8)
                    .attr('y', config.headerHeight + config.entityPadding + (6 * config.entityFieldHeight) + 12)
                    .style('fill', '#9ca3af')
                    .style('font-style', 'italic')
                    .text(`... ${entity.fields.length - 6} more`);
            }

            // Events
            g.on('mouseover', function(event) {
                const fieldsList = entity.fields.slice(0, 4)
                    .map(f => `<code>${f.name}</code>: ${f.type}${f.required ? ' *' : ''}`)
                    .join('<br/>');
                
                tooltip.style('opacity', 1)
                    .html(`<strong>${entity.name}</strong><br/>${entity.description}<br/><br/>${fieldsList}`)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
            })
            .on('mouseout', () => tooltip.style('opacity', 0))
            .on('click', () => highlightRelationships(entity.id));

            return g;
        }

        // Draw relationships with smart routing
        function drawRelationships() {
            svg.selectAll('.relationship-group').remove();
            
            relationships.forEach(rel => {
                const fromEntity = entities.find(e => e.id === rel.from);
                const toEntity = entities.find(e => e.id === rel.to);
                
                if (fromEntity && toEntity) {
                    drawSmartRelationship(fromEntity, toEntity, rel);
                }
            });
        }

        function drawSmartRelationship(fromEntity, toEntity, rel) {
            // Find optimal connection points
            const fromCenter = { x: fromEntity.x + fromEntity.width / 2, y: fromEntity.y + fromEntity.height / 2 };
            const toCenter = { x: toEntity.x + toEntity.width / 2, y: toEntity.y + toEntity.height / 2 };
            
            // Calculate connection points on entity edges
            const fromPoint = getConnectionPoint(fromEntity, toCenter);
            const toPoint = getConnectionPoint(toEntity, fromCenter);
            
            // Create obstacles (other entities)
            const obstacles = entities.filter(e => e.id !== fromEntity.id && e.id !== toEntity.id);
            
            // Find path
            const path = findPath(fromPoint, toPoint, obstacles);
            
            // Draw relationship
            const g = svg.append('g')
                .attr('class', 'relationship-group')
                .attr('data-from', rel.from)
                .attr('data-to', rel.to);

            // Create path string
            let pathString = `M ${path[0].x} ${path[0].y}`;
            for (let i = 1; i < path.length; i++) {
                pathString += ` L ${path[i].x} ${path[i].y}`;
            }

            // Draw main line
            g.append('path')
                .attr('class', `relationship relationship-${rel.type}`)
                .attr('d', pathString);

            // Draw crow's foot notation
            const endPoint = path[path.length - 1];
            const prevPoint = path[path.length - 2] || path[0];
            const angle = Math.atan2(endPoint.y - prevPoint.y, endPoint.x - prevPoint.x);
            
            if (rel.toCard === 'many') {
                drawCrowsFoot(g, endPoint.x, endPoint.y, angle);
            } else {
                drawSingleMark(g, endPoint.x, endPoint.y, angle);
            }
            
            drawSingleMark(g, path[0].x, path[0].y, angle + Math.PI);

            // Label at path midpoint
            const midIndex = Math.floor(path.length / 2);
            const midPoint = path[midIndex];
            
            g.append('rect')
                .attr('x', midPoint.x - 20)
                .attr('y', midPoint.y - 8)
                .attr('width', 40)
                .attr('height', 16)
                .attr('fill', 'white')
                .attr('stroke', '#e5e7eb')
                .attr('rx', 3);
                
            g.append('text')
                .attr('class', 'relationship-label')
                .attr('x', midPoint.x)
                .attr('y', midPoint.y + 4)
                .text(rel.label);
        }

        function getConnectionPoint(entity, targetPoint) {
            const centerX = entity.x + entity.width / 2;
            const centerY = entity.y + entity.height / 2;
            
            const dx = targetPoint.x - centerX;
            const dy = targetPoint.y - centerY;
            
            // Calculate which edge to connect to
            const slope = dy / dx;
            const entitySlope = entity.height / entity.width;
            
            if (Math.abs(slope) < entitySlope) {
                // Connect to left or right edge
                if (dx > 0) {
                    return { x: entity.x + entity.width, y: centerY };
                } else {
                    return { x: entity.x, y: centerY };
                }
            } else {
                // Connect to top or bottom edge
                if (dy > 0) {
                    return { x: centerX, y: entity.y + entity.height };
                } else {
                    return { x: centerX, y: entity.y };
                }
            }
        }

        function drawCrowsFoot(g, x, y, angle) {
            const size = 8;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            
            // Three lines forming crow's foot
            const offsets = [-size, 0, size];
            offsets.forEach(offset => {
                const perpCos = Math.cos(angle + Math.PI / 2);
                const perpSin = Math.sin(angle + Math.PI / 2);
                
                g.append('line')
                    .attr('class', 'crowsfoot-line')
                    .attr('x1', x)
                    .attr('y1', y)
                    .attr('x2', x - cos * 12 + perpCos * offset)
                    .attr('y2', y - sin * 12 + perpSin * offset);
            });
        }

        function drawSingleMark(g, x, y, angle) {
            const perpCos = Math.cos(angle + Math.PI / 2);
            const perpSin = Math.sin(angle + Math.PI / 2);
            
            g.append('line')
                .attr('class', 'crowsfoot-line')
                .attr('x1', x + perpCos * 4)
                .attr('y1', y + perpSin * 4)
                .attr('x2', x - perpCos * 4)
                .attr('y2', y - perpSin * 4);
        }

        // Simulation tick handler
        function ticked() {
            // Update entity positions
            entityElements
                .attr('transform', d => `translate(${d.x - d.width/2},${d.y - d.height/2})`);
            
            // Update relationships
            drawRelationships();
        }

        // Control functions
        function showAll() {
            svg.selectAll('.entity').style('opacity', 1);
            svg.selectAll('.relationship-group').style('opacity', 0.7);
            updateActiveButton(0);
        }

        function filterByArea(area) {
            svg.selectAll('.entity').style('opacity', function() {
                return d3.select(this).attr('data-area') === area ? 1 : 0.2;
            });
            svg.selectAll('.relationship-group').style('opacity', 0.3);
        }

        function highlightRelationships(entityId) {
            svg.selectAll('.relationship-group').style('opacity', function() {
                const from = d3.select(this).attr('data-from');
                const to = d3.select(this).attr('data-to');
                return (from === entityId || to === entityId) ? 1 : 0.2;
            });
            
            svg.selectAll('.entity').style('opacity', function() {
                const id = d3.select(this).attr('data-id');
                const isConnected = relationships.some(rel => 
                    (rel.from === entityId && rel.to === id) || 
                    (rel.to === entityId && rel.from === id)
                );
                return (id === entityId || isConnected) ? 1 : 0.3;
            });
        }

        function resetLayout() {
            if (simulation) {
                simulation.alpha(1).restart();
            }
        }

        function restartSimulation() {
            if (simulation) {
                simulation.alpha(1).restart();
            }
        }

        function stopSimulation() {
            if (simulation) {
                simulation.stop();
            }
        }

        function updateActiveButton(index) {
            d3.selectAll('.btn').classed('active', false);
            d3.selectAll('.btn').nodes()[index].classList.add('active');
        }

        function exportDiagram() {
            const svgElement = document.getElementById('erd-svg');
            const serializer = new XMLSerializer();
            const svgString = serializer.serializeToString(svgElement);
            
            const blob = new Blob([svgString], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'boost-erd-no-overlap.svg';
            a.click();
            
            URL.revokeObjectURL(url);
        }

        // Initialize
        function initializeVisualization() {
            // Create force simulation
            createForceSimulation();
            
            // Draw entities
            entityElements = svg.selectAll('.entity')
                .data(entities)
                .enter()
                .append('g')
                .attr('class', 'entity')
                .each(function(d) {
                    d3.select(this).call(sel => drawEntity(d));
                })
                .call(d3.drag()
                    .on('start', function(event, d) {
                        if (!event.active) simulation.alphaTarget(0.3).restart();
                        d.fx = d.x;
                        d.fy = d.y;
                    })
                    .on('drag', function(event, d) {
                        d.fx = event.x;
                        d.fy = event.y;
                    })
                    .on('end', function(event, d) {
                        if (!event.active) simulation.alphaTarget(0);
                        d.fx = null;
                        d.fy = null;
                    })
                );

            // Set up simulation tick handler
            simulation.on('tick', ticked);
            
            // Initial relationship drawing
            setTimeout(() => {
                drawRelationships();
            }, 100);
        }

        // Start
        initializeVisualization();
    </script>
</body>
</html>