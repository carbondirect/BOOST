<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BOOST ERD - Comprehensive Data Model v2.0</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=SF+Pro+Display:wght@300;400;500;600&family=SF+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
            margin: 0;
            padding: 24px;
            background: #fafbfc;
            color: #24292f;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .container {
            max-width: 2800px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 24px;
            background: white;
            padding: 24px;
            border-radius: 12px;
            border: 1px solid #d1d9e0;
            box-shadow: 0 1px 3px rgba(16, 24, 40, 0.04);
        }
        
        .header h1 {
            color: #101828;
            margin: 0 0 8px 0;
            font-weight: 600;
            font-size: 32px;
            letter-spacing: -0.02em;
        }
        
        .header p {
            color: #667085;
            font-size: 16px;
            margin: 0;
            font-weight: 400;
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 32px;
            margin-top: 16px;
            font-size: 14px;
            color: #6b7280;
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .stat-number {
            font-size: 24px;
            font-weight: 600;
            color: #1f2937;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 8px 16px;
            border: 1px solid #d1d9e0;
            border-radius: 6px;
            background: white;
            color: #374151;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            font-family: inherit;
            transition: all 0.15s ease;
        }
        
        .btn:hover {
            background: #f9fafb;
            border-color: #9ca3af;
        }
        
        .btn.active {
            background: #1f2937;
            color: white;
            border-color: #1f2937;
        }
        
        .svg-container {
            background: white;
            border-radius: 12px;
            border: 1px solid #d1d9e0;
            box-shadow: 0 1px 3px rgba(16, 24, 40, 0.04);
            overflow: hidden;
            position: relative;
            cursor: grab;
        }
        
        .svg-container.panning {
            cursor: grabbing;
        }
        
        .entity {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .entity:hover {
            filter: drop-shadow(0 4px 12px rgba(0,0,0,0.1));
        }
        
        .entity-header {
            font-family: 'SF Pro Display', system-ui, sans-serif;
            font-weight: 600;
            font-size: 12px;
            letter-spacing: -0.01em;
        }
        
        .entity-field {
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 10px;
            fill: #374151;
            font-weight: 400;
        }
        
        .entity-pk {
            font-family: 'SF Mono', monospace;
            font-weight: 500;
            font-size: 10px;
            fill: #dc2626;
        }
        
        .entity-fk {
            font-family: 'SF Mono', monospace;
            font-weight: 500;
            font-size: 10px;
            fill: #2563eb;
        }
        
        .entity-required {
            font-family: 'SF Mono', monospace;
            font-weight: 500;
            font-size: 10px;
            fill: #1f2937;
        }
        
        .relationship {
            fill: none;
            transition: all 0.25s ease;
        }
        
        .relationship-identifying {
            stroke: #374151;
            stroke-width: 1.5;
        }
        
        .relationship-non-identifying {
            stroke: #9ca3af;
            stroke-width: 1.2;
            stroke-dasharray: 5,3;
        }
        
        .relationship:hover {
            stroke: #1f2937 !important;
            stroke-width: 2.5 !important;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }
        
        .relationship-label {
            font-size: 9px;
            fill: #6b7280;
            text-anchor: middle;
            pointer-events: none;
            font-weight: 500;
        }
        
        .label-background {
            fill: rgba(255, 255, 255, 0.9);
            stroke: #e5e7eb;
            stroke-width: 0.5;
            rx: 3;
        }
        
        .crowsfoot-line {
            stroke: #374151;
            stroke-width: 1.2;
            fill: none;
        }
        
        .tooltip {
            position: absolute;
            padding: 12px;
            background: rgba(17, 24, 39, 0.95);
            color: white;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 1000;
            max-width: 350px;
            font-weight: 400;
            line-height: 1.4;
            backdrop-filter: blur(8px);
        }
        
        .tooltip code {
            background: rgba(255,255,255,0.1);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'SF Mono', monospace;
        }

        .zoom-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .area-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-width: 200px;
        }

        .control-btn {
            padding: 6px 12px;
            border: 1px solid #d1d9e0;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.95);
            color: #374151;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            font-family: inherit;
            transition: all 0.15s ease;
            backdrop-filter: blur(4px);
            text-align: left;
        }

        .control-btn:hover {
            background: white;
            border-color: #9ca3af;
            transform: translateY(-1px);
        }

        .control-btn.active {
            background: #1f2937;
            color: white;
            border-color: #1f2937;
        }

        .zoom-indicator {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            color: #6b7280;
            backdrop-filter: blur(4px);
        }

        .help-text {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            font-size: 10px;
            color: #6b7280;
            backdrop-filter: blur(4px);
            max-width: 200px;
            text-align: center;
        }

        .legend {
            position: absolute;
            bottom: 80px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 12px;
            font-size: 10px;
            color: #6b7280;
            backdrop-filter: blur(4px);
            max-width: 200px;
        }

        .legend h4 {
            margin: 0 0 8px 0;
            font-size: 11px;
            font-weight: 600;
            color: #374151;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>BOOST Data Standard v2.0</h1>
            <p>Comprehensive biomass chain of custody data model with Kaulen framework integration</p>
            <div class="stats">
                <div class="stat">
                    <div class="stat-number">20</div>
                    <div>Entities</div>
                </div>
                <div class="stat">
                    <div class="stat-number">7</div>
                    <div>Thematic Areas</div>
                </div>
                <div class="stat">
                    <div class="stat-number">31</div>
                    <div>Relationships</div>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <button class="btn active" onclick="showAll()">All Entities</button>
            <button class="btn" onclick="filterByArea('core_traceability')">üü¢ Core Traceability</button>
            <button class="btn" onclick="filterByArea('commercial_transactions')">üü† Commercial</button>
            <button class="btn" onclick="filterByArea('organizational')">üîµ Organizational</button>
            <button class="btn" onclick="filterByArea('certification_claims')">üü£ Certification</button>
            <button class="btn" onclick="filterByArea('material_specification')">üü§ Materials</button>
            <button class="btn" onclick="filterByArea('geographic_spatial')">üü™ Geographic</button>
            <button class="btn" onclick="filterByArea('measurement_quality')">üî¥ Measurement</button>
            <button class="btn" onclick="fitToScreen()">Fit to Screen</button>
            <button class="btn" onclick="exportDiagram()">Export SVG</button>
        </div>
        
        <div class="svg-container" id="svg-container">
            <div class="zoom-controls">
                <button class="control-btn" onclick="zoomIn()" title="Zoom In">üîç+</button>
                <button class="control-btn" onclick="zoomOut()" title="Zoom Out">üîç‚àí</button>
                <button class="control-btn" onclick="resetZoom()" title="Reset Zoom">‚åÇ</button>
            </div>
            
            <div class="area-controls">
                <button class="control-btn" onclick="setCurveType('curveBasis')" title="Smooth curves">Smooth</button>
                <button class="control-btn" onclick="setCurveType('curveCardinal')" title="Cardinal curves">Cardinal</button>
                <button class="control-btn" onclick="setCurveType('curveBundle')" title="Bundle curves">Bundle</button>
            </div>
            
            <div class="zoom-indicator" id="zoom-indicator">100%</div>
            
            <div class="help-text">
                Mouse wheel: zoom<br/>
                Click & drag: pan<br/>
                Click entity: highlight<br/>
                Hover: details
            </div>

            <div class="legend">
                <h4>Field Types</h4>
                <div class="legend-item">
                    <span style="color: #dc2626; font-weight: 600;">PK</span>
                    <span>Primary Key</span>
                </div>
                <div class="legend-item">
                    <span style="color: #2563eb; font-weight: 600;">FK</span>
                    <span>Foreign Key</span>
                </div>
                <div class="legend-item">
                    <span style="color: #1f2937;">‚óè</span>
                    <span>Required Field</span>
                </div>
                <div class="legend-item">
                    <span style="color: #9ca3af;">‚óã</span>
                    <span>Optional Field</span>
                </div>
            </div>
            
            <svg id="erd-svg" width="2800" height="1800"></svg>
        </div>
        
        <div class="tooltip" id="tooltip"></div>
    </div>

    <script>
        // Load entity definitions
        let entityDefinitions = null;
        
        // Configuration
        const config = {
            width: 2800,
            height: 1800,
            entityWidth: 200,
            entityFieldHeight: 14,
            entityPadding: 6,
            headerHeight: 24,
            curveType: 'curveBasis',
            colors: {
                'core_traceability': { 
                    fill: 'rgba(220, 252, 231, 0.25)', 
                    stroke: '#10b981', 
                    header: '#059669'
                },
                'commercial_transactions': { 
                    fill: 'rgba(254, 243, 199, 0.25)', 
                    stroke: '#f59e0b', 
                    header: '#d97706'
                },
                'organizational': { 
                    fill: 'rgba(219, 234, 254, 0.25)', 
                    stroke: '#3b82f6', 
                    header: '#2563eb'
                },
                'certification_claims': { 
                    fill: 'rgba(243, 232, 255, 0.25)', 
                    stroke: '#a855f7', 
                    header: '#7c3aed'
                },
                'material_specification': { 
                    fill: 'rgba(231, 229, 228, 0.25)', 
                    stroke: '#78716c', 
                    header: '#57534e'
                },
                'geographic_spatial': { 
                    fill: 'rgba(243, 232, 255, 0.25)', 
                    stroke: '#a855f7', 
                    header: '#9333ea'
                },
                'measurement_quality': { 
                    fill: 'rgba(254, 242, 242, 0.25)', 
                    stroke: '#ef4444', 
                    header: '#dc2626'
                }
            }
        };

        // Load entity definitions from JSON
        async function loadEntityDefinitions() {
            try {
                const response = await fetch('boost_erd_entities_complete.json');
                entityDefinitions = await response.json();
                initializeVisualization();
            } catch (error) {
                console.error('Could not load entity definitions:', error);
                // Fallback to embedded definitions
                initializeVisualization();
            }
        }

        // Strategic positioning for 20 entities across 7 thematic areas
        const entityPositions = {
            // Core Traceability - Central cluster (5 entities)
            'TraceableUnit': { x: 1400, y: 900 },
            'MaterialProcessing': { x: 1100, y: 1200 },
            'ProcessingHistory': { x: 1700, y: 1200 },
            'TrackingPoint': { x: 1400, y: 600 },
            'LocationHistory': { x: 1100, y: 600 },

            // Commercial Transactions - Right side (3 entities)
            'Transaction': { x: 2200, y: 900 },
            'TransactionBatch': { x: 2200, y: 1200 },
            'DataReconciliation': { x: 2500, y: 1050 },

            // Organizational - Left side (2 entities)
            'Organization': { x: 300, y: 900 },
            'Operator': { x: 600, y: 900 },

            // Certification & Claims - Upper right (4 entities)
            'Claim': { x: 2200, y: 300 },
            'Certificate': { x: 2500, y: 300 },
            'CertificationBody': { x: 2200, y: 600 },
            'CertificationScheme': { x: 2500, y: 600 },

            // Material Specification - Upper center (4 entities)
            'Material': { x: 1400, y: 300 },
            'SpeciesComponent': { x: 1700, y: 300 },
            'ProductGroup': { x: 1100, y: 300 },
            'MoistureContent': { x: 1700, y: 600 },

            // Geographic & Spatial - Center left (1 entity)
            'GeographicData': { x: 900, y: 900 },

            // Measurement & Quality - Lower left (2 entities)
            'MeasurementRecord': { x: 300, y: 1200 },
            'BiometricIdentifier': { x: 600, y: 1200 }
        };

        // Comprehensive entity definitions (fallback if JSON fails)
        const entities = [
            {
                id: 'TraceableUnit',
                name: 'TraceableUnit', 
                area: 'core_traceability',
                description: 'Central entity for biomass tracking with Kaulen framework integration and moisture content tracking',
                fields: [
                    { name: 'traceableUnitId', type: 'string', isPK: true, required: true },
                    { name: 'unitType', type: 'enum', required: true },
                    { name: 'uniqueIdentifier', type: 'string', required: true },
                    { name: 'totalVolumeM3', type: 'number', required: true },
                    { name: 'currentMoistureContent', type: 'number' },
                    { name: 'assortmentType', type: 'enum' },
                    { name: 'qualityGrade', type: 'enum' },
                    { name: 'currentStatus', type: 'enum' },
                    { name: 'isMultiSpecies', type: 'boolean' },
                    { name: 'createdTimestamp', type: 'datetime', required: true },
                    { name: 'currentGeographicDataId', type: 'string', isFK: true },
                    { name: 'harvestGeographicDataId', type: 'string', isFK: true },
                    { name: 'operatorId', type: 'string', isFK: true },
                    { name: 'materialTypeId', type: 'string', isFK: true, required: true },
                    { name: 'parentTraceableUnitId', type: 'string', isFK: true }
                ]
            },
            {
                id: 'MaterialProcessing',
                name: 'MaterialProcessing',
                area: 'core_traceability', 
                description: 'Processing operations that transform TRUs with plant part tracking',
                fields: [
                    { name: 'processingId', type: 'string', isPK: true, required: true },
                    { name: 'inputTraceableUnitId', type: 'string', isFK: true, required: true },
                    { name: 'outputTraceableUnitId', type: 'string', isFK: true },
                    { name: 'processType', type: 'enum', required: true },
                    { name: 'processTimestamp', type: 'datetime', required: true },
                    { name: 'operatorId', type: 'string', isFK: true },
                    { name: 'equipmentUsed', type: 'string' },
                    { name: 'inputVolume', type: 'number' },
                    { name: 'outputVolume', type: 'number' },
                    { name: 'inputMoistureContent', type: 'number' },
                    { name: 'outputMoistureContent', type: 'number' },
                    { name: 'processingEfficiency', type: 'number' }
                ]
            },
            {
                id: 'ProcessingHistory', 
                name: 'ProcessingHistory',
                area: 'core_traceability',
                description: 'Complete timeline of processing events with moisture tracking',
                fields: [
                    { name: 'processingHistoryId', type: 'string', isPK: true, required: true },
                    { name: 'traceableUnitId', type: 'string', isFK: true, required: true },
                    { name: 'materialProcessingId', type: 'string', isFK: true },
                    { name: 'processSequenceNumber', type: 'integer' },
                    { name: 'processDate', type: 'datetime', required: true },
                    { name: 'inputMoistureContent', type: 'number' },
                    { name: 'outputMoistureContent', type: 'number' },
                    { name: 'qualityChanges', type: 'string' },
                    { name: 'mediaBreakOccurred', type: 'boolean' }
                ]
            },
            {
                id: 'TrackingPoint',
                name: 'TrackingPoint', 
                area: 'core_traceability',
                description: 'Physical locations where TRUs are tracked during movement',
                fields: [
                    { name: 'trackingPointId', type: 'string', isPK: true, required: true },
                    { name: 'pointType', type: 'enum', required: true },
                    { name: 'geographicDataId', type: 'string', isFK: true, required: true },
                    { name: 'operatorId', type: 'string', isFK: true },
                    { name: 'equipmentUsed', type: 'string' },
                    { name: 'establishedTimestamp', type: 'datetime', required: true },
                    { name: 'capacity', type: 'number' },
                    { name: 'isActive', type: 'boolean', required: true }
                ]
            },
            {
                id: 'LocationHistory',
                name: 'LocationHistory',
                area: 'core_traceability', 
                description: 'Historical movement records of traceable units',
                fields: [
                    { name: 'locationHistoryId', type: 'string', isPK: true, required: true },
                    { name: 'traceableUnitId', type: 'string', isFK: true, required: true },
                    { name: 'trackingPointId', type: 'string', isFK: true },
                    { name: 'arrivalTimestamp', type: 'datetime', required: true },
                    { name: 'departureTimestamp', type: 'datetime' },
                    { name: 'transportMethod', type: 'enum' },
                    { name: 'durationHours', type: 'number' }
                ]
            },
            {
                id: 'Transaction',
                name: 'Transaction',
                area: 'commercial_transactions',
                description: 'Business transactions between organizations', 
                fields: [
                    { name: 'transactionId', type: 'string', isPK: true, required: true },
                    { name: 'supplyingOrganizationId', type: 'string', isFK: true, required: true },
                    { name: 'customerOrganizationId', type: 'string', isFK: true, required: true },
                    { name: 'transactionDate', type: 'date', required: true },
                    { name: 'contractValue', type: 'number' },
                    { name: 'transactionStatus', type: 'enum' },
                    { name: 'paymentTerms', type: 'string' },
                    { name: 'deliveryTerms', type: 'string' }
                ]
            },
            {
                id: 'TransactionBatch',
                name: 'TransactionBatch', 
                area: 'commercial_transactions',
                description: 'Batch-level commercial transactions with full traceability',
                fields: [
                    { name: 'transactionBatchId', type: 'string', isPK: true, required: true },
                    { name: 'transactionId', type: 'string', isFK: true, required: true },
                    { name: 'quantity', type: 'number', required: true },
                    { name: 'quantityUnit', type: 'enum' },
                    { name: 'qualityGrade', type: 'enum' },
                    { name: 'batchStatus', type: 'enum' },
                    { name: 'reconciliationStatus', type: 'enum' },
                    { name: 'deliveryGeographicDataId', type: 'string', isFK: true },
                    { name: 'mediaBreakDetected', type: 'boolean' },
                    { name: 'averageMoistureContent', type: 'number' }
                ]
            },
            {
                id: 'DataReconciliation',
                name: 'DataReconciliation',
                area: 'commercial_transactions',
                description: 'Reconciliation records for transaction discrepancies',
                fields: [
                    { name: 'dataReconciliationId', type: 'string', isPK: true, required: true },
                    { name: 'transactionBatchId', type: 'string', isFK: true, required: true },
                    { name: 'discrepancyType', type: 'enum' },
                    { name: 'detectedTimestamp', type: 'datetime', required: true },
                    { name: 'resolvedTimestamp', type: 'datetime' },
                    { name: 'resolution', type: 'string' },
                    { name: 'responsible_party', type: 'string' },
                    { name: 'corrective_action', type: 'string' }
                ]
            },
            {
                id: 'Organization',
                name: 'Organization',
                area: 'organizational',
                description: 'Business entities in the BOOST supply chain',
                fields: [
                    { name: 'organizationId', type: 'string', isPK: true, required: true },
                    { name: 'organizationName', type: 'string', required: true },
                    { name: 'organizationType', type: 'enum', required: true },
                    { name: 'primaryGeographicDataId', type: 'string', isFK: true },
                    { name: 'contactEmail', type: 'string' },
                    { name: 'contactPhone', type: 'string' },
                    { name: 'registrationNumber', type: 'string' },
                    { name: 'isActive', type: 'boolean', required: true }
                ]
            },
            {
                id: 'Operator',
                name: 'Operator', 
                area: 'organizational',
                description: 'Personnel performing operations with enhanced certification tracking',
                fields: [
                    { name: 'operatorId', type: 'string', isPK: true, required: true },
                    { name: 'organizationId', type: 'string', isFK: true, required: true },
                    { name: 'operatorName', type: 'string', required: true },
                    { name: 'operatorType', type: 'enum', required: true },
                    { name: 'certifications', type: 'string[]' },
                    { name: 'equipmentAuthorizations', type: 'string[]' },
                    { name: 'licenseNumber', type: 'string' },
                    { name: 'licenseExpiry', type: 'date' },
                    { name: 'isActive', type: 'boolean', required: true }
                ]
            },
            {
                id: 'Claim',
                name: 'Claim',
                area: 'certification_claims',
                description: 'Sustainability and certification claims with validation',
                fields: [
                    { name: 'claimId', type: 'string', isPK: true, required: true },
                    { name: 'traceableUnitId', type: 'string', isFK: true, required: true },
                    { name: 'claimType', type: 'enum', required: true },
                    { name: 'statement', type: 'string', required: true },
                    { name: 'validated', type: 'boolean', required: true },
                    { name: 'claimPercentage', type: 'number' },
                    { name: 'claimScope', type: 'enum' },
                    { name: 'certificationSchemeId', type: 'string', isFK: true },
                    { name: 'validatedBy', type: 'string', isFK: true },
                    { name: 'validationDate', type: 'date' }
                ]
            },
            {
                id: 'Certificate', 
                name: 'Certificate',
                area: 'certification_claims',
                description: 'Digital certificates for sustainability schemes',
                fields: [
                    { name: 'certificateId', type: 'string', isPK: true, required: true },
                    { name: 'certificateNumber', type: 'string', required: true },
                    { name: 'organizationId', type: 'string', isFK: true, required: true },
                    { name: 'certificationSchemeId', type: 'string', isFK: true, required: true },
                    { name: 'certificationBodyId', type: 'string', isFK: true },
                    { name: 'issueDate', type: 'date', required: true },
                    { name: 'expiryDate', type: 'date', required: true },
                    { name: 'certificateScope', type: 'string' },
                    { name: 'status', type: 'enum' }
                ]
            },
            {
                id: 'CertificationBody',
                name: 'CertificationBody',
                area: 'certification_claims', 
                description: 'Accredited bodies that issue certificates',
                fields: [
                    { name: 'certificationBodyId', type: 'string', isPK: true, required: true },
                    { name: 'bodyName', type: 'string', required: true },
                    { name: 'accreditationNumber', type: 'string' },
                    { name: 'contactDetails', type: 'string' },
                    { name: 'authorizedSchemes', type: 'string[]' },
                    { name: 'isActive', type: 'boolean', required: true }
                ]
            },
            {
                id: 'CertificationScheme',
                name: 'CertificationScheme',
                area: 'certification_claims',
                description: 'Sustainability certification schemes (FSC, PEFC, SBP, etc.)',
                fields: [
                    { name: 'certificationSchemeId', type: 'string', isPK: true, required: true },
                    { name: 'schemeName', type: 'string', required: true },
                    { name: 'schemeVersion', type: 'string' },
                    { name: 'schemeDescription', type: 'string' },
                    { name: 'applicableRegions', type: 'string[]' },
                    { name: 'schemeOwner', type: 'string' },
                    { name: 'isActive', type: 'boolean', required: true }
                ]
            },
            {
                id: 'Material',
                name: 'Material', 
                area: 'material_specification',
                description: 'Material types and specifications with plant part definitions',
                fields: [
                    { name: 'materialTypeId', type: 'string', isPK: true, required: true },
                    { name: 'materialName', type: 'string', required: true },
                    { name: 'materialCategory', type: 'enum' },
                    { name: 'applicablePlantParts', type: 'string[]' },
                    { name: 'typicalMoisture', type: 'number' },
                    { name: 'densityKgM3', type: 'number' },
                    { name: 'energyContentMJKg', type: 'number' }
                ]
            },
            {
                id: 'SpeciesComponent',
                name: 'SpeciesComponent',
                area: 'material_specification', 
                description: 'Species composition within materials',
                fields: [
                    { name: 'speciesComponentId', type: 'string', isPK: true, required: true },
                    { name: 'traceableUnitId', type: 'string', isFK: true, required: true },
                    { name: 'speciesName', type: 'string', required: true },
                    { name: 'scientificName', type: 'string' },
                    { name: 'percentage', type: 'number', required: true },
                    { name: 'volumeM3', type: 'number' },
                    { name: 'plantParts', type: 'string[]' }
                ]
            },
            {
                id: 'ProductGroup',
                name: 'ProductGroup',
                area: 'material_specification',
                description: 'Commercial product classifications and groupings', 
                fields: [
                    { name: 'productGroupId', type: 'string', isPK: true, required: true },
                    { name: 'productGroupName', type: 'string', required: true },
                    { name: 'productCategory', type: 'enum' },
                    { name: 'classification', type: 'string' },
                    { name: 'description', type: 'string', required: true },
                    { name: 'regulatoryClassification', type: 'string' },
                    { name: 'typicalUses', type: 'string[]' },
                    { name: 'qualityStandards', type: 'string[]' }
                ]
            },
            {
                id: 'MoistureContent', 
                name: 'MoistureContent',
                area: 'material_specification',
                description: 'Detailed moisture content measurements and tracking',
                fields: [
                    { name: 'moistureContentId', type: 'string', isPK: true, required: true },
                    { name: 'traceableUnitId', type: 'string', isFK: true, required: true },
                    { name: 'moisturePercentage', type: 'number', required: true },
                    { name: 'measurementMethod', type: 'enum' },
                    { name: 'measurementTimestamp', type: 'datetime', required: true },
                    { name: 'operatorId', type: 'string', isFK: true },
                    { name: 'temperature', type: 'number' },
                    { name: 'humidity', type: 'number' }
                ]
            },
            {
                id: 'GeographicData',
                name: 'GeographicData',
                area: 'geographic_spatial',
                description: 'Spatial data and location information using GeoJSON',
                fields: [
                    { name: 'geographicDataId', type: 'string', isPK: true, required: true },
                    { name: 'geoJsonData', type: 'json', required: true },
                    { name: 'dataType', type: 'enum' },
                    { name: 'description', type: 'string' },
                    { name: 'country', type: 'string' },
                    { name: 'region', type: 'string' },
                    { name: 'accuracy', type: 'number' },
                    { name: 'elevationM', type: 'number' }
                ]
            },
            {
                id: 'MeasurementRecord', 
                name: 'MeasurementRecord',
                area: 'measurement_quality',
                description: 'Quality measurements and dimensional data',
                fields: [
                    { name: 'measurementRecordId', type: 'string', isPK: true, required: true },
                    { name: 'traceableUnitId', type: 'string', isFK: true, required: true },
                    { name: 'measurementType', type: 'enum' },
                    { name: 'value', type: 'number', required: true },
                    { name: 'unit', type: 'string', required: true },
                    { name: 'measurementTimestamp', type: 'datetime', required: true },
                    { name: 'operatorId', type: 'string', isFK: true },
                    { name: 'instrumentUsed', type: 'string' },
                    { name: 'accuracy', type: 'number' }
                ]
            },
            {
                id: 'BiometricIdentifier',
                name: 'BiometricIdentifier', 
                area: 'measurement_quality',
                description: 'Biometric identifiers for media-interruption-free tracking',
                fields: [
                    { name: 'biometricIdentifierId', type: 'string', isPK: true, required: true },
                    { name: 'traceableUnitId', type: 'string', isFK: true, required: true },
                    { name: 'identifierType', type: 'enum' },
                    { name: 'identifierData', type: 'string', required: true },
                    { name: 'confidenceScore', type: 'number' },
                    { name: 'captureTimestamp', type: 'datetime', required: true },
                    { name: 'operatorId', type: 'string', isFK: true },
                    { name: 'equipment', type: 'string' }
                ]
            }
        ].map(entity => ({
            ...entity,
            x: entityPositions[entity.id]?.x || 1000,
            y: entityPositions[entity.id]?.y || 900
        }));

        // Comprehensive relationships for 20-entity system
        const relationships = [
            // Core Traceability Hub
            { from: 'TraceableUnit', to: 'MaterialProcessing', label: 'input_to', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'MaterialProcessing', to: 'TraceableUnit', label: 'creates', type: 'identifying', fromCard: 'one', toCard: 'one' },
            { from: 'TraceableUnit', to: 'ProcessingHistory', label: 'has_history', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'MaterialProcessing', to: 'ProcessingHistory', label: 'documented_by', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'TraceableUnit', to: 'LocationHistory', label: 'has_location_history', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'TrackingPoint', to: 'LocationHistory', label: 'records_at', type: 'identifying', fromCard: 'one', toCard: 'many' },

            // Commercial Transactions
            { from: 'Transaction', to: 'TransactionBatch', label: 'contains', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'TransactionBatch', to: 'DataReconciliation', label: 'requires_reconciliation', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'TransactionBatch', to: 'TraceableUnit', label: 'includes', type: 'non-identifying', fromCard: 'many', toCard: 'many' },

            // Organizational
            { from: 'Organization', to: 'Transaction', label: 'supplies', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'Organization', to: 'Operator', label: 'employs', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'Organization', to: 'Certificate', label: 'holds', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'Operator', to: 'MaterialProcessing', label: 'performs', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'Operator', to: 'TrackingPoint', label: 'operates', type: 'non-identifying', fromCard: 'one', toCard: 'many' },

            // Certification & Claims
            { from: 'TraceableUnit', to: 'Claim', label: 'supports', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'CertificationScheme', to: 'Claim', label: 'validates', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'CertificationScheme', to: 'Certificate', label: 'issues', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'CertificationBody', to: 'Certificate', label: 'certifies', type: 'identifying', fromCard: 'one', toCard: 'many' },

            // Material Specification
            { from: 'Material', to: 'TraceableUnit', label: 'defines_type', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'TraceableUnit', to: 'SpeciesComponent', label: 'composed_of', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'ProductGroup', to: 'Material', label: 'categorizes', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'TraceableUnit', to: 'MoistureContent', label: 'has_moisture_data', type: 'identifying', fromCard: 'one', toCard: 'many' },

            // Geographic
            { from: 'GeographicData', to: 'TraceableUnit', label: 'locates', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'GeographicData', to: 'Organization', label: 'locates', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'GeographicData', to: 'TrackingPoint', label: 'locates', type: 'identifying', fromCard: 'one', toCard: 'one' },

            // Measurement & Quality
            { from: 'TraceableUnit', to: 'MeasurementRecord', label: 'measured_by', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'TraceableUnit', to: 'BiometricIdentifier', label: 'identified_by', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'Operator', to: 'MeasurementRecord', label: 'performs', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'Operator', to: 'MoistureContent', label: 'measures', type: 'non-identifying', fromCard: 'one', toCard: 'many' },

            // Self-referential
            { from: 'TraceableUnit', to: 'TraceableUnit', label: 'parent_of', type: 'non-identifying', fromCard: 'one', toCard: 'many' }
        ];

        // D3 Setup with zoom and pan
        const svg = d3.select('#erd-svg');
        const tooltip = d3.select('#tooltip');
        const container = d3.select('#svg-container');
        
        // Create main group for zoom/pan transforms
        const g = svg.append('g').attr('class', 'main-group');
        
        // Zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 5])
            .on('zoom', handleZoom);
        
        // Apply zoom to SVG
        svg.call(zoom);
        
        // Track zoom level for indicator
        let currentZoom = 1;
        
        function handleZoom(event) {
            const { transform } = event;
            g.attr('transform', transform);
            currentZoom = transform.k;
            updateZoomIndicator();
            
            // Update cursor during pan
            if (event.sourceEvent && event.sourceEvent.type === 'mousemove') {
                container.classed('panning', true);
            } else {
                container.classed('panning', false);
            }
        }
        
        function updateZoomIndicator() {
            d3.select('#zoom-indicator').text(`${Math.round(currentZoom * 100)}%`);
        }

        // Zoom control functions
        function zoomIn() {
            svg.transition().duration(300).call(zoom.scaleBy, 1.5);
        }
        
        function zoomOut() {
            svg.transition().duration(300).call(zoom.scaleBy, 1 / 1.5);
        }
        
        function resetZoom() {
            svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity);
        }
        
        function fitToScreen() {
            // Calculate bounding box of all entities
            const bounds = {
                minX: Math.min(...entities.map(e => e.x)),
                maxX: Math.max(...entities.map(e => e.x + config.entityWidth)),
                minY: Math.min(...entities.map(e => e.y)),
                maxY: Math.max(...entities.map(e => e.y + 250)) // Approximate entity height
            };
            
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;
            const scale = Math.min(config.width / width, config.height / height) * 0.85;
            
            const centerX = (bounds.minX + bounds.maxX) / 2;
            const centerY = (bounds.minY + bounds.maxY) / 2;
            
            const translateX = config.width / 2 - centerX * scale;
            const translateY = config.height / 2 - centerY * scale;
            
            svg.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity.translate(translateX, translateY).scale(scale)
            );
        }

        // Connection points and curve generation
        function getConnectionPoint(entity, targetEntity) {
            const entityCenter = {
                x: entity.x + config.entityWidth / 2,
                y: entity.y + 120
            };
            
            const targetCenter = {
                x: targetEntity.x + config.entityWidth / 2,
                y: targetEntity.y + 120
            };
            
            const dx = targetCenter.x - entityCenter.x;
            const dy = targetCenter.y - entityCenter.y;
            
            const angle = Math.atan2(dy, dx);
            const entityRadius = Math.max(config.entityWidth, 240) / 2;
            
            const connectionPoint = {
                x: entityCenter.x + Math.cos(angle) * entityRadius,
                y: entityCenter.y + Math.sin(angle) * entityRadius
            };
            
            connectionPoint.x = Math.max(entity.x, Math.min(entity.x + config.entityWidth, connectionPoint.x));
            connectionPoint.y = Math.max(entity.y, Math.min(entity.y + 250, connectionPoint.y));
            
            return connectionPoint;
        }

        function generateControlPoints(fromPoint, toPoint, relationship) {
            const dx = toPoint.x - fromPoint.x;
            const dy = toPoint.y - fromPoint.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            const controlDistance = Math.min(distance * 0.4, 200);
            
            let cp1, cp2;
            
            if (Math.abs(dx) > Math.abs(dy)) {
                cp1 = {
                    x: fromPoint.x + controlDistance,
                    y: fromPoint.y
                };
                cp2 = {
                    x: toPoint.x - controlDistance,
                    y: toPoint.y
                };
            } else {
                cp1 = {
                    x: fromPoint.x,
                    y: fromPoint.y + Math.sign(dy) * controlDistance
                };
                cp2 = {
                    x: toPoint.x,
                    y: toPoint.y - Math.sign(dy) * controlDistance
                };
            }
            
            return [fromPoint, cp1, cp2, toPoint];
        }

        // Draw entity function
        function drawEntity(entity) {
            const color = config.colors[entity.area] || { fill: '#f3f4f6', stroke: '#9ca3af', header: '#6b7280' };
            const visibleFields = entity.fields.slice(0, 8); // Show more fields for comprehensive view
            const entityHeight = config.headerHeight + (visibleFields.length * config.entityFieldHeight) + (config.entityPadding * 2) + 4;
            
            const entityGroup = g.append('g')
                .attr('class', 'entity')
                .attr('data-area', entity.area)
                .attr('data-id', entity.id)
                .attr('transform', `translate(${entity.x}, ${entity.y})`);

            // Entity background
            entityGroup.append('rect')
                .attr('width', config.entityWidth)
                .attr('height', entityHeight)
                .attr('fill', color.fill)
                .attr('stroke', color.stroke)
                .attr('stroke-width', 1)
                .attr('rx', 6);

            // Header
            entityGroup.append('rect')
                .attr('width', config.entityWidth)
                .attr('height', config.headerHeight)
                .attr('fill', color.header)
                .attr('rx', 6);
                
            entityGroup.append('rect')
                .attr('y', config.headerHeight - 6)
                .attr('width', config.entityWidth)
                .attr('height', 6)
                .attr('fill', color.header);

            // Entity name
            entityGroup.append('text')
                .attr('class', 'entity-header')
                .attr('x', config.entityWidth / 2)
                .attr('y', config.headerHeight / 2 + 3)
                .attr('text-anchor', 'middle')
                .attr('fill', 'white')
                .text(entity.name);

            // Fields
            visibleFields.forEach((field, i) => {
                const fieldY = config.headerHeight + config.entityPadding + (i * config.entityFieldHeight) + 10;
                let fieldClass = 'entity-field';
                
                if (field.isPK) fieldClass = 'entity-pk';
                else if (field.isFK) fieldClass = 'entity-fk';
                else if (field.required) fieldClass = 'entity-required';
                
                const prefix = field.isPK ? 'PK ' : field.isFK ? 'FK ' : field.required ? '‚Ä¢ ' : '  ';
                
                entityGroup.append('text')
                    .attr('class', fieldClass)
                    .attr('x', 6)
                    .attr('y', fieldY)
                    .text(`${prefix}${field.name}: ${field.type}`);
            });

            // More fields indicator
            if (entity.fields.length > 8) {
                entityGroup.append('text')
                    .attr('class', 'entity-field')
                    .attr('x', 6)
                    .attr('y', config.headerHeight + config.entityPadding + (8 * config.entityFieldHeight) + 10)
                    .style('fill', '#9ca3af')
                    .style('font-style', 'italic')
                    .text(`... ${entity.fields.length - 8} more`);
            }

            // Events
            entityGroup.on('mouseover', function(event) {
                const fieldsList = entity.fields.slice(0, 6)
                    .map(f => `<code>${f.name}</code>: ${f.type}${f.required ? ' *' : ''}${f.isPK ? ' (PK)' : ''}${f.isFK ? ' (FK)' : ''}`)
                    .join('<br/>');
                
                tooltip.style('opacity', 1)
                    .html(`<strong>${entity.name}</strong><br/><em>${entity.area.replace('_', ' ')}</em><br/><br/>${entity.description}<br/><br/>${fieldsList}`)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
            })
            .on('mouseout', () => tooltip.style('opacity', 0))
            .on('click', () => highlightRelationships(entity.id));

            return entityGroup;
        }

        // Draw curved relationships
        function drawRelationships() {
            g.selectAll('.relationship-group').remove();
            
            relationships.forEach((rel, index) => {
                const fromEntity = entities.find(e => e.id === rel.from);
                const toEntity = entities.find(e => e.id === rel.to);
                
                if (fromEntity && toEntity) {
                    drawCurvedRelationship(fromEntity, toEntity, rel);
                }
            });
        }

        function drawCurvedRelationship(fromEntity, toEntity, rel) {
            const fromPoint = getConnectionPoint(fromEntity, toEntity);
            const toPoint = getConnectionPoint(toEntity, fromEntity);
            const controlPoints = generateControlPoints(fromPoint, toPoint, rel);
            
            const relationshipGroup = g.append('g')
                .attr('class', 'relationship-group')
                .attr('data-from', rel.from)
                .attr('data-to', rel.to);

            // Create curved path
            const line = d3.line()
                .x(d => d.x)
                .y(d => d.y)
                .curve(d3[config.curveType]);

            const path = relationshipGroup.append('path')
                .attr('class', `relationship relationship-${rel.type}`)
                .attr('d', line(controlPoints));

            // Crow's foot notation
            const lastPoint = controlPoints[controlPoints.length - 1];
            const secondLastPoint = controlPoints[controlPoints.length - 2];
            const endAngle = Math.atan2(lastPoint.y - secondLastPoint.y, lastPoint.x - secondLastPoint.x);
            
            if (rel.toCard === 'many') {
                drawCrowsFoot(relationshipGroup, toPoint.x, toPoint.y, endAngle);
            } else {
                drawSingleMark(relationshipGroup, toPoint.x, toPoint.y, endAngle);
            }
            
            const startAngle = Math.atan2(controlPoints[1].y - controlPoints[0].y, controlPoints[1].x - controlPoints[0].x);
            drawSingleMark(relationshipGroup, fromPoint.x, fromPoint.y, startAngle + Math.PI);

            // Label
            const pathLength = path.node().getTotalLength();
            const midPoint = path.node().getPointAtLength(pathLength / 2);
            
            const textWidth = rel.label.length * 5;
            relationshipGroup.append('rect')
                .attr('class', 'label-background')
                .attr('x', midPoint.x - textWidth/2 - 3)
                .attr('y', midPoint.y - 8)
                .attr('width', textWidth + 6)
                .attr('height', 14)
                .attr('rx', 3);
                
            relationshipGroup.append('text')
                .attr('class', 'relationship-label')
                .attr('x', midPoint.x)
                .attr('y', midPoint.y + 2)
                .text(rel.label);
        }

        function drawCrowsFoot(g, x, y, angle) {
            const size = 6;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            
            const offsets = [-size, 0, size];
            offsets.forEach(offset => {
                const perpCos = Math.cos(angle + Math.PI / 2);
                const perpSin = Math.sin(angle + Math.PI / 2);
                
                g.append('line')
                    .attr('class', 'crowsfoot-line')
                    .attr('x1', x)
                    .attr('y1', y)
                    .attr('x2', x - cos * 10 + perpCos * offset)
                    .attr('y2', y - sin * 10 + perpSin * offset);
            });
        }

        function drawSingleMark(g, x, y, angle) {
            const perpCos = Math.cos(angle + Math.PI / 2);
            const perpSin = Math.sin(angle + Math.PI / 2);
            
            g.append('line')
                .attr('class', 'crowsfoot-line')
                .attr('x1', x + perpCos * 3)
                .attr('y1', y + perpSin * 3)
                .attr('x2', x - perpCos * 3)
                .attr('y2', y - perpSin * 3);
        }

        // Control functions
        function setCurveType(curveType) {
            config.curveType = curveType;
            drawRelationships();
            
            d3.selectAll('.area-controls .control-btn').classed('active', false);
            d3.select(event.target).classed('active', true);
        }

        function showAll() {
            g.selectAll('.entity').style('opacity', 1);
            g.selectAll('.relationship-group').style('opacity', 0.8);
            updateActiveButton(0);
        }

        function filterByArea(area) {
            g.selectAll('.entity').style('opacity', function() {
                return d3.select(this).attr('data-area') === area ? 1 : 0.2;
            });
            g.selectAll('.relationship-group').style('opacity', 0.3);
        }

        function highlightRelationships(entityId) {
            g.selectAll('.relationship-group').style('opacity', function() {
                const from = d3.select(this).attr('data-from');
                const to = d3.select(this).attr('data-to');
                return (from === entityId || to === entityId) ? 1 : 0.2;
            });
            
            g.selectAll('.entity').style('opacity', function() {
                const id = d3.select(this).attr('data-id');
                const isConnected = relationships.some(rel => 
                    (rel.from === entityId && rel.to === id) || 
                    (rel.to === entityId && rel.from === id)
                );
                return (id === entityId || isConnected) ? 1 : 0.3;
            });
        }

        function updateActiveButton(index) {
            d3.selectAll('.controls .btn').classed('active', false);
            d3.selectAll('.controls .btn').nodes()[index].classList.add('active');
        }

        function exportDiagram() {
            const svgElement = document.getElementById('erd-svg');
            const serializer = new XMLSerializer();
            const svgString = serializer.serializeToString(svgElement);
            
            const blob = new Blob([svgString], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'boost-erd-comprehensive-v2.svg';
            a.click();
            
            URL.revokeObjectURL(url);
        }

        // Initialize
        function initializeVisualization() {
            entities.forEach(entity => {
                drawEntity(entity);
            });
            
            drawRelationships();
            updateZoomIndicator();
            
            // Initial fit to screen
            setTimeout(fitToScreen, 100);
        }

        // Start - try to load JSON definitions, fallback to embedded
        loadEntityDefinitions();
    </script>
</body>
</html>