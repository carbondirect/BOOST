% Python Reference Implementation Section
% Comprehensive documentation of the BOOST Python reference implementation

The BOOST standard provides a comprehensive Python reference implementation that demonstrates dynamic, schema-driven data models, validation, and supply chain tracking capabilities for biomass chain of custody operations.

\subsection{Overview}
\label{sec:python-overview}

The Python reference implementation uses a \textbf{dynamic, schema-driven architecture} that automatically adapts to changes in BOOST JSON schemas without requiring code modifications. Key features include:

\begin{itemize}
    \item \textbf{Dynamic Schema-Driven Architecture}: Automatically adapts to schema changes without code modifications
    \item \textbf{Comprehensive Validation}: Schema, business logic, and cross-entity validation with 8 categories of business rules
    \item \textbf{Dynamic Model Generation}: Pydantic models generated directly from JSON schemas at runtime
    \item \textbf{Configuration-Driven Business Rules}: Business logic validation rules defined in configuration files
    \item \textbf{Supply Chain Tracking}: Complete traceability with automatic relationship discovery
    \item \textbf{Multi-Certification Support}: FSC, SBP, PEFC, ISCC, RED II compliance validation
    \item \textbf{Mass Balance Accounting}: Volume and mass conservation validation with configurable tolerance checking
    \item \textbf{JSON-LD Export/Import}: Full semantic web compatibility with schema.org and W3C PROV ontology support
    \item \textbf{Schema Version Compatibility}: Graceful handling of schema evolution and backward compatibility
\end{itemize}

\subsection{Installation}
\label{sec:python-installation}

\subsubsection{Prerequisites}
\label{sec:python-prerequisites}

The Python reference implementation requires:

\begin{itemize}
    \item Python 3.8 or higher
    \item pip package manager
\end{itemize}

\subsubsection{Dependencies}
\label{sec:python-dependencies}

Core dependencies are defined in \code{requirements.txt}:

\begin{pythonexample}{Python Dependencies}
\pythoncode{pydantic>=2.0.0      # Data validation and settings management
jsonschema>=4.0.0    # JSON Schema validation  
requests>=2.28.0     # HTTP library for API calls
pyld>=2.0.0          # JSON-LD processor}
\end{pythonexample}

Installation:

\begin{pythonexample}{Installation Command}
\pythoncode{pip install -r requirements.txt}
\end{pythonexample}

\subsection{Architecture}
\label{sec:python-architecture}

The implementation follows a layered architecture with three main components:

\begin{enumerate}
    \item \textbf{Schema Loader}: Dynamic schema loading and model generation engine
    \item \textbf{Dynamic Validation}: Configuration-driven validation with 8 categories of business rules
    \item \textbf{BOOST Client}: High-level API interface using dynamic models
\end{enumerate}

The architecture ensures automatic adaptation to schema changes while providing comprehensive validation and traceability capabilities.

\subsection{Core Components}
\label{sec:python-core-components}

\subsubsection{SchemaLoader}
\label{sec:python-schema-loader}

The \textbf{SchemaLoader} (\code{schema\_loader.py}) is the foundation component that provides dynamic schema loading and model generation:

\textbf{Key Features:}
\begin{itemize}
    \item \textbf{Automatic Schema Discovery}: Scans directories for \code{validation\_schema.json} files
    \item \textbf{Dynamic Model Generation}: Creates Pydantic models from JSON schemas at runtime
    \item \textbf{Enum Generation}: Dynamically creates Python enums from schema definitions
    \item \textbf{Relationship Discovery}: Analyzes schemas to discover foreign key relationships automatically
    \item \textbf{Primary Key Detection}: Identifies primary key fields from schema patterns
\end{itemize}

\textbf{Usage Example:}

\begin{pythonexample}{SchemaLoader Usage}
\pythoncode{from schema_loader import SchemaLoader

# Initialize with automatic schema discovery
loader = SchemaLoader()

# Get dynamically generated Pydantic models
OrganizationModel = loader.get_model('organization')
TraceableUnitModel = loader.get_model('traceable_unit')

# Get enum values directly from current schemas
org_types = loader.get_field_enum_values('organization', 
                                    'organizationType')
print(f"Available organization types: {org_types}")

# Access relationship information discovered from schemas
relationships = loader.get_relationships('traceable_unit')
primary_key = loader.get_primary_key('organization')}
\end{pythonexample}

\subsubsection{DynamicBOOSTValidator}
\label{sec:python-validator}

The \textbf{DynamicBOOSTValidator} (\code{dynamic\_validation.py}) provides comprehensive, schema-driven validation using configuration-based business rules:

\textbf{Validation Categories:}
\begin{enumerate}
    \item \textbf{Schema Validation}: JSON Schema compliance and structural validation
    \item \textbf{Volume/Mass Conservation}: Physical conservation laws with configurable tolerance checking
    \item \textbf{Temporal Logic}: Date/time consistency rules and processing sequence validation
    \item \textbf{Geographic Logic}: Location-based constraints and transport distance validation
    \item \textbf{Species Composition}: Biological consistency and percentage validation
    \item \textbf{Certification Logic}: Chain of custody validation and certificate integrity
    \item \textbf{Regulatory Compliance}: LCFS, EU RED, and sustainability criteria validation
    \item \textbf{Economic/Quality Logic}: Market constraints and quality assurance validation
\end{enumerate}

\textbf{Usage Example:}

\begin{pythonexample}{DynamicBOOSTValidator Usage}
\pythoncode{from dynamic_validation import DynamicBOOSTValidator

validator = DynamicBOOSTValidator()

# Schema validation against current schema
is_valid, errors = validator.validate_entity("organization", org_data)

# Configuration-driven business logic validation
is_valid, errors = validator.validate_business_logic(
    "material_processing", processing_data)

# Comprehensive cross-entity validation
entities = {
    'organization': [org1, org2],
    'traceable_unit': [tru1, tru2],
    'transaction': [txn1]
}
results = validator.comprehensive_validation(entities)}
\end{pythonexample}

\subsubsection{BOOSTClient}
\label{sec:python-client}

The \textbf{BOOSTClient} (\code{boost\_client.py}) provides a high-level interface that uses the dynamic models and validation system:

\textbf{Core Functions:}
\begin{itemize}
    \item \textbf{Entity Creation}: Create entities using dynamically generated models with automatic validation
    \item \textbf{Schema Introspection}: Query available entities, enums, and constraints from current schemas
    \item \textbf{Supply Chain Analysis}: Trace relationships and analyze supply chains using dynamic models
    \item \textbf{Validation}: Comprehensive validation using all dynamic rules and business logic
    \item \textbf{JSON-LD Support}: Export/import with semantic annotations and context management
\end{itemize}

\textbf{Usage Example:}

\begin{pythonexample}{BOOSTClient Usage}
\pythoncode{from boost_client import create_client

# Initialize client with dynamic schema loading
client = create_client()

# Schema introspection
schema_info = client.get_schema_info()
print(f"Available entities: {schema_info['available_entities']}")

# Dynamic enum discovery
org_types = client.get_available_enum_values('organization', 
                        'organizationType')

# Entity creation with schema validation
org = client.create_organization(
    organization_id="ORG-FOREST-001",
    name="Pacific Forest Products",
    org_type="harvester",  # Validated against current schema
    contact_email="ops@pacificforest.com"
)

# Comprehensive validation
validation = client.validate_all()
if validation['valid']:
    print("âœ“ All entities pass validation!")}
\end{pythonexample}

\subsection{Dynamic Schema Adaptation}
\label{sec:python-schema-adaptation}

A key strength of the Python implementation is its \textbf{automatic adaptation to schema changes}. Most schema modifications require \textbf{no code changes}.

\subsubsection{Automatically Handled Changes}
\label{sec:python-auto-changes}

\textbf{Adding New Fields:}
\begin{itemize}
    \item New optional fields are immediately available
    \item Required fields trigger validation updates automatically
    \item Default values from schemas are applied automatically
\end{itemize}

\textbf{Adding New Enum Values:}
\begin{itemize}
    \item New enum values become available immediately after schema reload
    \item Validation rules update automatically
    \item No code changes required
\end{itemize}

\textbf{Adding New Entity Types:}
\begin{itemize}
    \item New schema files are discovered automatically
    \item Dynamic models are generated on first access
    \item All validation rules apply automatically
\end{itemize}

\textbf{Modifying Business Logic Rules:}
\begin{itemize}
    \item Configuration file changes are applied automatically
    \item Tolerance values and thresholds update dynamically
    \item Cross-entity validation rules adapt to changes
\end{itemize}

\subsubsection{Schema Change Detection}
\label{sec:python-change-detection}

The system provides built-in tools for schema change management:

\begin{pythonexample}{Schema Change Detection}
\pythoncode{# Check current schema status
client = create_client()
schema_info = client.get_schema_info()

# Validate against current schema
validation = client.validate_all()
if not validation['valid']:
    print("Schema changes detected - validation errors:")
    for error in validation['errors']:
        print(f"  - {error}")

# Refresh schemas after updates
client.refresh_schemas()}
\end{pythonexample}

\subsection{Usage Examples}
\label{sec:python-examples}

\subsubsection{Basic Workflow}
\label{sec:python-basic-workflow}

Complete example demonstrating fundamental BOOST operations:

\begin{pythonexample}{Basic Workflow Example}
\pythoncode{from boost_client import create_client

# Initialize BOOST client
client = create_client()

# Create organizations with schema validation
harvester = client.create_organization(
    organization_id="ORG-001",
    name="Forest Products Inc",
    org_type="harvester",
    contact_email="ops@forestproducts.com"
)

processor = client.create_organization(
    organization_id="ORG-002", 
    name="Sawmill Operations LLC",
    org_type="processor",
    contact_email="info@sawmill.com"
)

# Create traceable units with automatic model generation
log_pile = client.create_traceable_unit(
    traceable_unit_id="TRU-LOGS-001",
    unit_type="pile",
    harvester_id="ORG-001",
    total_volume_m3=125.5,
    sustainability_certification="FSC Mix Credit 70%"
)

# Process materials with conservation validation
lumber = client.create_material_processing(
    processing_id="MP-001",
    input_tru_id="TRU-LOGS-001",
    process_type="sawing",
    processor_id="ORG-002",
    output_volume_m3=95.2  # Validates against conservation rules
)

# Execute transaction with comprehensive validation
transaction = client.create_transaction(
    transaction_id="TXN-001",
    organization_id="ORG-002",
    customer_id="CUST-001",
    transaction_date="2025-08-12",
    quantity_m3=50.0
)

# Comprehensive validation using all dynamic rules
validation = client.validate_all()
if validation['valid']:
    print("âœ“ All entities validated successfully!")
    
# Export to JSON-LD with semantic annotations
jsonld_output = client.export_to_jsonld(include_context=True)}
\end{pythonexample}

\subsubsection{Certification Management}
\label{sec:python-certification}

Example showing certification claim management:

\begin{pythonexample}{Certification Management Example}
\pythoncode{# Create FSC certified organization
fsc_harvester = client.create_organization(
    organization_id="ORG-FSC-001",
    name="Certified Forest Management",
    org_type="harvester",
    certifications=["FSC-FM/COC-001234"]
)

# Create certified traceable unit
certified_logs = client.create_traceable_unit(
    traceable_unit_id="TRU-FSC-001",
    unit_type="pile",
    harvester_id="ORG-FSC-001",
    total_volume_m3=200.0,
    sustainability_certification="FSC Mix Credit 70%",
    certification_claims=["FSC-FM/COC-001234"]
)

# Validate certification chain integrity
cert_validation = client.validate_certification_chain("TRU-FSC-001")
print(f"Certification valid: {cert_validation['valid']}")}
\end{pythonexample}

\subsubsection{Mass Balance Validation}
\label{sec:python-mass-balance}

Example demonstrating conservation law validation:

\begin{pythonexample}{Mass Balance Validation Example}
\pythoncode{# Multiple input materials
input_tru_1 = client.create_traceable_unit(
    traceable_unit_id="TRU-INPUT-001",
    unit_type="pile", 
    total_volume_m3=100.0
)

input_tru_2 = client.create_traceable_unit(
    traceable_unit_id="TRU-INPUT-002",
    unit_type="pile",
    total_volume_m3=75.0
)

# Processing with multiple inputs
pellet_production = client.create_material_processing(
    processing_id="MP-PELLETS-001",
    input_tru_ids=["TRU-INPUT-001", "TRU-INPUT-002"],
    process_type="pelletizing",
    total_input_volume_m3=175.0,
    total_output_volume_m3=140.0,  # Within tolerance for pelletizing
    efficiency_percent=80.0
)

# Validate mass balance with configurable tolerance
balance_validation = client.validate_mass_balance("MP-PELLETS-001")
print(f"Mass balance valid: {balance_validation['valid']}")
print(f"Efficiency: {balance_validation['efficiency']}%")}
\end{pythonexample}

\subsection{Integration Guidance}
\label{sec:python-integration}

\subsubsection{API Development}
\label{sec:python-api-development}

Using the reference implementation for API development:

\begin{pythonexample}{API Development Example}
\pythoncode{from boost_client import create_client
from flask import Flask, jsonify, request

app = Flask(__name__)
boost_client = create_client()

@app.route('/organizations', methods=['POST'])
def create_organization():
    data = request.json
    try:
        # Dynamic validation using current schema
        org = boost_client.create_organization(**data)
        return jsonify(org.model_dump(by_alias=True))
    except ValueError as e:
        return jsonify({"error": str(e)}), 400

@app.route('/validate/<entity_type>', methods=['POST'])
def validate_entity(entity_type):
    data = request.json
    validation = boost_client.validator.validate_entity(entity_type, data)
    return jsonify({
        "valid": validation[0],
        "errors": validation[1]
    })

# Schema introspection endpoint
@app.route('/schema/info')
def schema_info():
    return jsonify(boost_client.get_schema_info())}
\end{pythonexample}

\subsection{Configuration}
\label{sec:python-configuration}

\subsubsection{Schema Path Configuration}
\label{sec:python-schema-config}

Customize schema loading:

\begin{pythonexample}{Schema Path Configuration}
\pythoncode{# Default: automatic discovery from ../schema/
client = create_client()

# Custom schema path
client = create_client(schema_path="/path/to/boost/schemas")

# Multiple schema sources
loader = SchemaLoader()
loader.add_schema_source("/additional/schemas")}
\end{pythonexample}

\subsubsection{Business Logic Configuration}
\label{sec:python-business-config}

Business logic rules are defined in configuration files:

\begin{jsonexample}{Business Logic Configuration}
\jsoncode{{
  "volumeMassConservation": {
    "materialProcessing": {
      "sawing": {
        "tolerance": 0.05,
        "efficiency_range": [0.7, 0.9]
      },
      "pelletizing": {
        "tolerance": 0.10,
        "efficiency_range": [0.75, 0.85]
      }
    }
  },
  "temporalLogic": {
    "processingWindows": {
      "harvest_to_processing_max_days": 90
    }
  }
}}
\end{jsonexample}

\subsection{Testing and Validation}
\label{sec:python-testing}

\subsubsection{Comprehensive Test Suite}
\label{sec:python-test-suite}

The implementation includes comprehensive tests:

\begin{pythonexample}{Running Tests}
\pythoncode{# Run all tests
python test_enhanced_entities.py

# Test specific validation categories
python -m unittest test_enhanced_entities.TestDynamicValidation.test_mass_balance_validation

# Test schema change robustness
python -m unittest test_enhanced_entities.TestSchemaRobustness}
\end{pythonexample}

\subsubsection{Validation Examples}
\label{sec:python-validation-examples}

Test validation with example data:

\begin{pythonexample}{Validation Examples}
\pythoncode{# Load and validate example data
with open('examples/validation/comprehensive_validation_test_suite.json') as f:
    test_data = json.load(f)

validator = DynamicBOOSTValidator()
results = validator.comprehensive_validation(test_data)

print(f"Validation results: {results['summary']}")
for category, result in results['by_category'].items():
    print(f"  {category}: {'PASS' if result['valid'] else 'FAIL'}")}
\end{pythonexample}

\subsection{Performance Characteristics}
\label{sec:python-performance}

\subsubsection{Initialization Performance}
\label{sec:python-init-performance}

\begin{itemize}
    \item \textbf{Schema Loading}: O(n) where n = number of schema files
    \item \textbf{Model Generation}: O(m) where m = number of entity properties  
    \item \textbf{Caching}: Models cached after first generation for O(1) access
\end{itemize}

\subsubsection{Runtime Performance}
\label{sec:python-runtime-performance}

\begin{itemize}
    \item \textbf{Validation}: O(1) for schema validation, O(r) for relationship validation where r = relationships
    \item \textbf{Entity Creation}: O(1) with cached models
    \item \textbf{Memory Usage}: Moderate (dynamic models cached in memory)
\end{itemize}

\subsubsection{Scalability Considerations}
\label{sec:python-scalability}

\begin{itemize}
    \item \textbf{Large Datasets}: Supports batch validation operations
    \item \textbf{Memory Management}: Efficient caching with configurable limits
    \item \textbf{Concurrent Access}: Thread-safe validation operations
\end{itemize}

\subsection{Standards Compliance}
\label{sec:python-standards}

The Python reference implementation fully supports:

\begin{itemize}
    \item \textbf{BOOST Data Standard} (with automatic adaptation to schema updates)
    \item \textbf{JSON-LD 1.1 Specification}
    \item \textbf{JSON Schema Draft-07}
    \item \textbf{Schema.org Vocabulary} for semantic annotations
    \item \textbf{W3C PROV Ontology} for provenance tracking
\end{itemize}