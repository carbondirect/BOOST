<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BOOST Entity Schema Navigator</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=SF+Pro+Display:wght@300;400;500;600&family=SF+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f6f8fa;
            color: #24292e;
        }
        .container {
            max-width: 3200px;
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.12);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 1px solid #e1e4e8;
            padding-bottom: 20px;
        }
        .header h1 {
            margin: 0 0 10px 0;
            color: #0366d6;
        }
        .header p {
            margin: 0;
            color: #586069;
            font-size: 16px;
        }
        .instructions {
            background-color: #f1f8ff;
            border: 1px solid #c8e1ff;
            border-radius: 6px;
            padding: 16px;
            margin-bottom: 30px;
        }
        .instructions h3 {
            margin-top: 0;
            color: #0366d6;
        }
        .info-section {
            background-color: #f6f8fa;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 20px;
            margin-bottom: 25px;
        }
        .info-section h3 {
            margin-top: 0;
            color: #0366d6;
            font-size: 18px;
        }
        .legend {
            background-color: #fff5f5;
            border: 1px solid #fed7d7;
            border-radius: 6px;
            padding: 16px;
            margin-bottom: 25px;
        }
        .legend h3 {
            margin-top: 0;
            color: #c53030;
            font-size: 16px;
        }
        .legend-item {
            display: inline-block;
            margin-right: 25px;
            margin-bottom: 8px;
            font-size: 14px;
        }
        .github-guide {
            background-color: #f0f4ff;
            border: 1px solid #b6d7ff;
            border-radius: 6px;
            padding: 18px;
            margin-bottom: 25px;
        }
        .github-guide h3 {
            margin-top: 0;
            color: #0969da;
            font-size: 17px;
        }
        .github-guide .signup-link {
            display: inline-block;
            padding: 8px 16px;
            background-color: #0969da;
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-weight: bold;
            margin: 10px 10px 10px 0;
        }
        .github-guide .signup-link:hover {
            background-color: #0860ca;
            text-decoration: none;
        }
        .connector-legend {
            background-color: #f8f9fa;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 16px;
            margin: 15px 0;
            font-size: 13px;
        }
        .connector-legend h4 {
            margin-top: 0;
            margin-bottom: 12px;
            color: #0366d6;
            font-size: 14px;
        }
        .connector-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .connector-visual {
            font-family: monospace;
            background-color: white;
            border: 1px solid #ddd;
            padding: 4px 8px;
            margin-right: 12px;
            border-radius: 3px;
            min-width: 60px;
            text-align: center;
        }
        .connector-description {
            color: #555;
        }
        /* Interactive ERD Styles */
        .controls {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 8px 16px;
            border: 1px solid #d1d9e0;
            border-radius: 6px;
            background: white;
            color: #374151;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            font-family: inherit;
            transition: all 0.15s ease;
        }
        
        .btn:hover {
            background: #f9fafb;
            border-color: #9ca3af;
        }
        
        .btn.active {
            background: #1f2937;
            color: white;
            border-color: #1f2937;
        }
        
        .svg-container {
            background: white;
            border-radius: 12px;
            border: 1px solid #d1d9e0;
            box-shadow: 0 1px 3px rgba(16, 24, 40, 0.04);
            overflow: hidden;
            position: relative;
            cursor: grab;
            height: 800px;
            margin-bottom: 30px;
        }
        
        .svg-container.panning {
            cursor: grabbing;
        }
        
        .entity {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .entity:hover {
            filter: drop-shadow(0 4px 12px rgba(0,0,0,0.1));
        }
        
        .entity-header {
            font-family: 'SF Pro Display', system-ui, sans-serif;
            font-weight: 600;
            font-size: 11px;
            letter-spacing: -0.01em;
        }
        
        .entity-field {
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 9px;
            fill: #374151;
            font-weight: 400;
        }
        
        .entity-pk {
            font-family: 'SF Mono', monospace;
            font-weight: 500;
            font-size: 9px;
            fill: #dc2626;
        }
        
        .entity-fk {
            font-family: 'SF Mono', monospace;
            font-weight: 500;
            font-size: 9px;
            fill: #2563eb;
        }
        
        .entity-required {
            font-family: 'SF Mono', monospace;
            font-weight: 500;
            font-size: 9px;
            fill: #1f2937;
        }
        
        .relationship {
            fill: none;
            transition: all 0.25s ease;
        }
        
        .relationship-identifying {
            stroke: #374151;
            stroke-width: 1.5;
        }
        
        .relationship-non-identifying {
            stroke: #9ca3af;
            stroke-width: 1.2;
            stroke-dasharray: 5,3;
        }
        
        .relationship:hover {
            stroke: #1f2937 !important;
            stroke-width: 2.5 !important;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }
        
        .relationship-label {
            font-size: 8px;
            fill: #6b7280;
            text-anchor: middle;
            pointer-events: none;
            font-weight: 500;
        }
        
        .label-background {
            fill: rgba(255, 255, 255, 0.9);
            stroke: #e5e7eb;
            stroke-width: 0.5;
        }
        
        .discussion-icon {
            fill: #4f46e5;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.8;
            stroke: #ffffff;
            stroke-width: 0.5;
        }
        
        .discussion-icon:hover {
            fill: #3730a3;
            opacity: 1;
            stroke: #ffffff;
            stroke-width: 1;
            rx: 3;
        }
        
        .crowsfoot-line {
            stroke: #374151;
            stroke-width: 1.2;
            fill: none;
        }
        
        .tooltip {
            position: absolute;
            padding: 12px;
            background: rgba(17, 24, 39, 0.95);
            color: white;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 1000;
            max-width: 400px;
            font-weight: 400;
            line-height: 1.4;
            backdrop-filter: blur(8px);
        }
        
        .tooltip code {
            background: rgba(255,255,255,0.1);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'SF Mono', monospace;
        }

        .zoom-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .area-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-width: 200px;
        }

        .control-btn {
            padding: 6px 12px;
            border: 1px solid #d1d9e0;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.95);
            color: #374151;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            font-family: inherit;
            transition: all 0.15s ease;
            backdrop-filter: blur(4px);
            text-align: left;
        }

        .control-btn:hover {
            background: white;
            border-color: #9ca3af;
            transform: translateY(-1px);
        }

        .control-btn.active {
            background: #1f2937;
            color: white;
            border-color: #1f2937;
        }

        .zoom-indicator {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            color: #6b7280;
            backdrop-filter: blur(4px);
        }

        .help-text {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            font-size: 10px;
            color: #6b7280;
            backdrop-filter: blur(4px);
            max-width: 200px;
            text-align: center;
        }

        .legend {
            position: absolute;
            bottom: 80px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 12px;
            font-size: 10px;
            color: #6b7280;
            backdrop-filter: blur(4px);
            max-width: 200px;
        }

        .legend-hidden {
            display: none !important;
        }

        .legend h4 {
            margin: 0 0 8px 0;
            font-size: 11px;
            font-weight: 600;
            color: #374151;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        
        .labels-hidden .relationship-label,
        .labels-hidden .label-background {
            display: none;
        }
        
        .tru-focus .relationship-group {
            opacity: 0.2;
        }
        
        .tru-focus .relationship-group[data-essential="true"] {
            opacity: 1;
            stroke-width: 2;
        }
        
        .tru-focus .entity {
            opacity: 0.4;
        }
        
        .tru-focus .entity[data-id="TraceableUnit"],
        .tru-focus .entity[data-essential="true"] {
            opacity: 1;
        }
        .entity-box {
            cursor: pointer;
            transition: opacity 0.2s;
        }
        .entity-box:hover {
            opacity: 0.8;
        }
        .domain-section {
            margin-bottom: 40px;
            padding: 25px;
            background-color: #f8f9fa;
            border: 1px solid #e1e4e8;
            border-radius: 8px;
        }
        .domain-header {
            margin: 0 0 10px 0;
            color: #0366d6;
            font-size: 20px;
            font-weight: 600;
        }
        .domain-description {
            margin: 0 0 20px 0;
            color: #586069;
            font-style: italic;
            font-size: 14px;
        }
        .entity-links {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }
        .entity-link {
            display: block;
            padding: 12px 16px;
            background-color: #ffffff;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            text-decoration: none;
            color: #24292e;
            transition: all 0.2s;
        }
        .entity-link:hover {
            background-color: #f6f8fa;
            border-color: #c8e1ff;
            text-decoration: none;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .entity-link strong {
            color: #0366d6;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        }
        .footer {
            margin-top: 40px;
            text-align: center;
            color: #586069;
            font-size: 14px;
            border-top: 1px solid #e1e4e8;
            padding-top: 20px;
        }
        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: #0366d6;
            text-decoration: none;
        }
        .back-link:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="../" class="back-link">← Back to BOOST Specification</a>
        
        <div class="header">
            <h1>🗂️ BOOST Entity Schema Navigator</h1>
            <p>Interactive Entity Relationship Diagram for Stakeholder Feedback</p>
        </div>


        <div class="github-guide">
            <h3>💬 Join the Discussion</h3>
            <p><strong>Why GitHub?</strong> We use GitHub Discussions to collect structured feedback from stakeholders across the biomass supply chain. It's free, open, and designed for collaborative input on technical standards.</p>
            <p><strong>New to GitHub?</strong> No problem! Creating an account takes just 2 minutes:</p>
            <a href="https://github.com/signup" target="_blank" class="signup-link">Create Free GitHub Account →</a>
            <p style="margin-top: 15px; margin-bottom: 0; font-size: 14px;">
                <strong>Prefer email?</strong> You can also send feedback to the BOOST working group at 
                <a href="mailto:public-boost-01@w3.org">public-boost-01@w3.org</a>
            </p>
        </div>

        <div class="info-section">
            <h3>🏗️ Understanding the Entity Relationship Diagram</h3>
            <p><strong>Entities</strong> represent the core data objects in biomass supply chains - things like Organizations, Certificates, Material Feedstock, and Transactions. Each entity captures specific information needed for chain of custody tracking.</p>
            <p><strong>Attributes</strong> are the data fields within each entity (like organization name, certificate expiry date, or biomass quantity). These define what information must be recorded and tracked.</p>
            <p><strong>Relationships</strong> show how entities connect to each other - for example, how a Certificate relates to an Organization, or how Material Feedstock flows through Transactions. These connections enable complete supply chain traceability.</p>
            <p style="margin-left: 20px; font-size: 14px; color: #555;">
                <strong>Reading the Diagram:</strong> Entities are shown as rectangular boxes containing their names (like Organization, Certificate, MaterialFeedstock). Lines connect related entities to show how they interact - for example, an Organization "is issued" a Certificate, or a Supplier "provides" MaterialFeedstock. Text along the lines describes the nature of each relationship in the biomass supply chain.
            </p>
            <div class="connector-legend">
                <h4>🔗 Relationship Connectors</h4>
                <div class="connector-item">
                    <div class="connector-visual">--||-||</div>
                    <div class="connector-description">One-to-one relationship (e.g., Organization has one Certificate)</div>
                </div>
                <div class="connector-item">
                    <div class="connector-visual">--||o{</div>
                    <div class="connector-description">One-to-many relationship (e.g., Organization has many Transactions)</div>
                </div>
                <div class="connector-item">
                    <div class="connector-visual">}|--||</div>
                    <div class="connector-description">Many-to-one relationship (e.g., many Materials from one Supplier)</div>
                </div>
                <div class="connector-item">
                    <div class="connector-visual">}|--|{</div>
                    <div class="connector-description">Many-to-many relationship (e.g., Materials can have multiple Claims)</div>
                </div>
                <div class="connector-item">
                    <div class="connector-visual">--||o|</div>
                    <div class="connector-description">Optional relationship (e.g., Organization may have Certificate)</div>
                </div>
            </div>
            <p style="margin-bottom: 0;"><strong>Purpose:</strong> This diagram maps the complete data structure needed to track biomass from source to end use, supporting regulatory compliance, sustainability verification, and carbon accounting.</p>
        </div>

        <div class="instructions">
            <h3>📋 How to Provide Feedback</h3>
            <p><strong>Our Goal:</strong> Collect real-world input from stakeholders to ensure the BOOST data standard meets practical biomass supply chain needs.</p>
            <p><strong>Explore the interactive diagram below</strong> to understand the complete BOOST data model. You can zoom in/out, pan around, and use the filtering controls to examine entity relationships in detail.</p>
            <p><strong>To provide feedback on a specific entity</strong>, click on the purple 💬 discussion icon in any entity header to jump directly to its GitHub discussion thread.</p>
            <p><strong>💡 What we're looking for:</strong> Field completeness, data types, real-world applicability, missing attributes, validation requirements, and integration challenges.</p>
        </div>

        <div class="info-section">
            <h3>🎯 Using the Interactive ERD</h3>
            <p><strong>Navigation:</strong> Use your mouse wheel to zoom, click and drag to pan around the diagram. The purple 💬 icons in entity headers link directly to GitHub discussions for that entity.</p>
            <p><strong>Filtering:</strong> Use the colored filter buttons to focus on specific areas of the data model (Core Traceability, Organizational, Material & Supply, etc.).</p>
            <p><strong>Focus Mode:</strong> Click the 🎯 button in the controls to highlight only essential TraceableUnit relationships, reducing visual clutter.</p>
            <p><strong>Field Legend:</strong> PK = Primary Key (red), FK = Foreign Key (blue), ● = Required Field, ○ = Optional Field</p>
        </div>
        
        <div class="controls">
            <button class="btn active" onclick="showAll()">All Entities</button>
            <button class="btn" onclick="filterByArea('core_traceability')">🟢 Core Traceability</button>
            <button class="btn" onclick="filterByArea('organizational_foundation')">🔵 Organizational</button>
            <button class="btn" onclick="filterByArea('material_supply_chain')">🟤 Material & Supply</button>
            <button class="btn" onclick="filterByArea('transaction_management')">🟠 Transactions</button>
            <button class="btn" onclick="filterByArea('measurement_verification')">🟡 Measurement</button>
            <button class="btn" onclick="filterByArea('geographic_tracking')">🟣 Geographic</button>
            <button class="btn" onclick="filterByArea('compliance_reporting')">🔴 Reporting</button>
            <button class="btn" onclick="fitToScreen()">Fit to Screen</button>
        </div>

        <div class="svg-container" id="svg-container">
            <div class="zoom-controls">
                <button class="control-btn" onclick="zoomIn()" title="Zoom In">🔍+</button>
                <button class="control-btn" onclick="zoomOut()" title="Zoom Out">🔍−</button>
                <button class="control-btn" onclick="resetZoom()" title="Reset Zoom">⌂</button>
                <button class="control-btn" onclick="toggleLabels()" title="Toggle relationship labels" id="label-toggle">🏷️</button>
                <button class="control-btn" onclick="toggleTruFocus()" title="Focus on essential TraceableUnit relationships" id="tru-focus">🎯</button>
                <button class="control-btn" onclick="toggleLegend()" title="Toggle legend visibility" id="legend-toggle">📋</button>
            </div>
            
            <div class="area-controls">
                <button class="control-btn active" onclick="setCurveType('curveBasis')" title="Smooth curves">Smooth</button>
                <button class="control-btn" onclick="setCurveType('curveCardinal')" title="Cardinal curves">Cardinal</button>
                <button class="control-btn" onclick="setCurveType('curveBundle')" title="Bundle curves">Bundle</button>
            </div>
            
            <div class="zoom-indicator" id="zoom-indicator">100%</div>
            
            <div class="help-text">
                Mouse wheel: zoom<br/>
                Click & drag: pan<br/>
                Click entity: highlight<br/>
                Click relationship: focus<br/>
                Hover: details
            </div>

            <div class="legend">
                <h4>Field Types</h4>
                <div class="legend-item">
                    <span style="color: #dc2626; font-weight: 600;">PK</span>
                    <span>Primary Key</span>
                </div>
                <div class="legend-item">
                    <span style="color: #2563eb; font-weight: 600;">FK</span>
                    <span>Foreign Key</span>
                </div>
                <div class="legend-item">
                    <span style="color: #1f2937;">●</span>
                    <span>Required Field</span>
                </div>
                <div class="legend-item">
                    <span style="color: #9ca3af;">○</span>
                    <span>Optional Field</span>
                </div>
                
                <h4 style="margin-top: 15px;">Relationship Types</h4>
                <div class="legend-item">
                    <svg width="30" height="2" style="margin-right: 8px;">
                        <line x1="0" y1="1" x2="30" y2="1" stroke="#374151" stroke-width="1.5"/>
                    </svg>
                    <span>Identifying (FK is part of PK)</span>
                </div>
                <div class="legend-item">
                    <svg width="30" height="2" style="margin-right: 8px;">
                        <line x1="0" y1="1" x2="30" y2="1" stroke="#9ca3af" stroke-width="1.2" stroke-dasharray="5,3"/>
                    </svg>
                    <span>Non-identifying (FK references only)</span>
                </div>
                <div style="font-size: 10px; color: #6b7280; margin-top: 5px; line-height: 1.3;">
                    <strong>Solid:</strong> Child entity depends on parent for identity (owns/contains)<br/>
                    <strong>Dashed:</strong> Child entity references parent independently (uses/links to)
                </div>
            </div>
            
            <svg id="erd-svg" width="3600" height="2000"></svg>
        </div>
        
        <div class="tooltip" id="tooltip"></div>

        <div class="info-section">
            <h3>💬 Entity Discussion Access</h3>
            <p><strong>Direct Links in ERD:</strong> Each entity in the interactive diagram above has a purple 💬 discussion icon in its header. Click these icons to go directly to the GitHub discussion for that specific entity.</p>
            <p><strong>Complete Coverage:</strong> All 29 entities in the BOOST data model have dedicated discussion threads where you can provide feedback on schemas, relationships, and real-world applicability.</p>
            <p style="text-align: center; margin-top: 20px;">
                <strong>💡 Pro Tip:</strong> Use the thematic filter buttons above the diagram to focus on specific areas, then click the discussion icons for targeted feedback.
            </p>
        </div>

        <!-- General Feedback Section -->
        <div class="info-section">
            <h3>🏗️ General ERD Structure Feedback</h3>
            <p><strong>Beyond Individual Entities:</strong> While the entity links above are for specific schema feedback, we also welcome input on the overall data model structure and organization.</p>
            <p><strong>Structural Questions:</strong> Are these the right entities in the right relationships? Should any entities be consolidated or split? Are there missing supply chain stages or processes?</p>
            <p><strong>Implementation Considerations:</strong> Will this structure work well for real-world deployments? How does it compare to existing industry data models?</p>
            <div style="text-align: center; margin-top: 20px;">
                <a href="https://github.com/carbondirect/BOOST/discussions/117" target="_blank" style="display: inline-block; padding: 12px 24px; background-color: #0969da; color: white; text-decoration: none; border-radius: 6px; font-weight: bold;">
                    💬 Discuss Overall ERD Structure →
                </a>
            </div>
        </div>

        <!-- Q&A Section -->
        <div class="info-section">
            <h3>❓ Questions & Answers</h3>
            <p><strong>Have Questions?</strong> Use our Q&A section for general questions about the BOOST data model, implementation guidance, or clarifications about entity relationships.</p>
            <p><strong>Examples:</strong> "How do I implement mass balance tracking?" or "What's the difference between Claim and VerificationStatement?" or "How does BOOST compare to other standards?"</p>
            <p><strong>Community Support:</strong> Get help from other stakeholders, implementers, and the BOOST working group.</p>
            <div style="text-align: center; margin-top: 20px;">
                <a href="https://github.com/carbondirect/BOOST/discussions/categories/q-a" target="_blank" style="display: inline-block; padding: 12px 24px; background-color: #6f42c1; color: white; text-decoration: none; border-radius: 6px; font-weight: bold;">
                    🙋 Ask a Question →
                </a>
            </div>
        </div>

        <div class="footer">
            <p>This ERD navigator is part of the BOOST data standard development process.<br>
            Your feedback helps ensure the standard meets real-world biomass chain of custody needs.</p>
            <p><a href="https://github.com/carbondirect/BOOST">📂 View full repository</a> | 
            <a href="https://github.com/carbondirect/BOOST/issues/61">🎯 Parent Issue #61</a></p>
        </div>
    </div>

    <script>
        // Configuration based on schema
        const config = {
            width: 3200,
            height: 2000,
            entityWidth: 180,
            entityFieldHeight: 12,
            entityPadding: 6,
            headerHeight: 20,
            curveType: 'curveBasis',
            colors: {
                'core_traceability': { 
                    fill: 'rgba(22, 163, 74, 0.1)', 
                    stroke: '#16A34A', 
                    header: '#15803D'
                },
                'organizational_foundation': { 
                    fill: 'rgba(37, 99, 235, 0.1)', 
                    stroke: '#2563EB', 
                    header: '#1D4ED8'
                },
                'material_supply_chain': { 
                    fill: 'rgba(161, 98, 7, 0.1)', 
                    stroke: '#A16207', 
                    header: '#92400E'
                },
                'transaction_management': { 
                    fill: 'rgba(234, 88, 12, 0.1)', 
                    stroke: '#EA580C', 
                    header: '#C2410C'
                },
                'measurement_verification': { 
                    fill: 'rgba(234, 179, 8, 0.1)', 
                    stroke: '#EAB308', 
                    header: '#CA8A04'
                },
                'geographic_tracking': { 
                    fill: 'rgba(147, 51, 234, 0.1)', 
                    stroke: '#9333EA', 
                    header: '#7C3AED'
                },
                'compliance_reporting': { 
                    fill: 'rgba(220, 38, 38, 0.1)', 
                    stroke: '#DC2626', 
                    header: '#B91C1C'
                }
            }
        };

        // Strategic positioning with increased spacing to reduce overlaps
        const entityPositions = {
            // 🟢 CORE TRACEABILITY - Central cluster with more spacing (9 entities)
            'TraceableUnit': { x: 1600, y: 1000 },
            'MaterialProcessing': { x: 1200, y: 1400 },
            'ProcessingHistory': { x: 2000, y: 1400 },
            'SpeciesComponent': { x: 1200, y: 600 },
            'MeasurementRecord': { x: 2000, y: 600 },
            'LocationHistory': { x: 1600, y: 600 },
            'BiometricIdentifier': { x: 1600, y: 1400 },
            'TrackingPoint': { x: 900, y: 1000 },
            'DataReconciliation': { x: 2300, y: 1000 },

            // 🔵 ORGANIZATIONAL FOUNDATION - Far left (4 entities)
            'Organization': { x: 100, y: 1000 },
            'Certificate': { x: 100, y: 600 },
            'CertificationScheme': { x: 100, y: 200 },
            'CertificationBody': { x: 100, y: 1400 },

            // 🟤 MATERIAL & SUPPLY CHAIN - Left side with more spacing (4 entities)
            'Material': { x: 500, y: 200 },
            'SupplyBase': { x: 500, y: 600 },
            'Supplier': { x: 500, y: 1000 },
            'Customer': { x: 500, y: 1400 },

            // 🟠 TRANSACTION MANAGEMENT - Far right (3 entities)
            'Transaction': { x: 2700, y: 1000 },
            'TransactionBatch': { x: 2700, y: 1400 },
            'SalesDeliveryDocument': { x: 2700, y: 600 },

            // 🟡 SUSTAINABILITY & CLAIMS - Top center (1 entity)
            'Claim': { x: 1600, y: 200 },

            // 🟣 GEOGRAPHIC & LOCATION - Center left (1 entity)
            'GeographicData': { x: 900, y: 600 },

            // 🔴 REPORTING & COMPLIANCE - Lower right with spacing (3 entities)
            'SupplyBaseReport': { x: 2700, y: 1800 },
            'VerificationStatement': { x: 2300, y: 1800 },
            'Audit': { x: 1900, y: 1800 },

            // ⚫ ANALYTICS & DATA MANAGEMENT - Lower center with spacing (3 entities)
            'ProductGroup': { x: 1200, y: 1800 },
            'MassBalanceAccount': { x: 900, y: 1800 },
            'EnergyCarbonData': { x: 1600, y: 1800 },

            // 👥 PERSONNEL MANAGEMENT - Lower left (1 entity)
            'Operator': { x: 500, y: 1800 }
        };

        // Auto-discovery functions - uses manifest file for reliable cross-platform discovery
        async function discoverSchemaDirectories() {
            try {
                // Try manifest file first (recommended approach)
                const manifestResponse = await fetch('../drafts/current/schema/directories.json');
                if (manifestResponse.ok) {
                    const manifest = await manifestResponse.json();
                    console.log(`Loaded ${manifest.total_entities} schema directories from manifest (updated: ${manifest.last_updated})`);
                    return manifest.schema_directories;
                }
                
                console.warn('Manifest file not found, falling back to directory discovery');
                
                // Fallback to raw directory listing (local development)
                const response = await fetch('../drafts/current/schema/');
                const text = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(text, 'text/html');
                
                const directories = Array.from(doc.querySelectorAll('a'))
                    .map(a => a.textContent.trim())
                    .filter(name => name && !name.includes('.') && name !== '../' && name !== 'README.md')
                    .map(name => name.replace('/', ''));
                    
                console.log(`Fallback discovery found ${directories.length} directories: ${directories.join(', ')}`);
                return directories;
            } catch (error) {
                console.error('Schema discovery failed:', error);
                return [];
            }
        }

        function directoryToEntityName(directory) {
            // Convert snake_case to PascalCase
            return directory.split('_')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join('');
        }

        // Schema loading functions
        async function loadSchemaFile(entityName) {
            try {
                const schemaPath = `../drafts/current/schema/${entityName.replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2').replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase()}/validation_schema.json?cb=${Date.now()}`;
                const response = await fetch(schemaPath);
                if (!response.ok) {
                    console.warn(`Could not load schema for ${entityName}: ${response.status}`);
                    return null;
                }
                return await response.json();
            } catch (error) {
                console.warn(`Error loading schema for ${entityName}:`, error);
                return null;
            }
        }

        async function loadERDConfig() {
            try {
                const response = await fetch('./erd-config.json');
                if (!response.ok) {
                    throw new Error(`Failed to load ERD config: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error('Failed to load ERD configuration:', error);
                throw error;
            }
        }

        function extractMetadataFromSchema(entityName, schema, erdConfig) {
            const schemaData = schema.schema || schema;
            
            // Find area for this entity from ERD config
            let entityArea = null;
            for (const [areaName, areaConfig] of Object.entries(erdConfig.areas)) {
                if (areaConfig.entities.includes(entityName)) {
                    entityArea = areaName;
                    break;
                }
            }
            
            if (!entityArea) {
                console.error(`Entity ${entityName} not found in any area configuration`);
                return null;
            }
            
            // Get display config
            const displayConfig = erdConfig.entity_display[entityName];
            if (!displayConfig) {
                console.error(`Entity ${entityName} missing display configuration`);
                return null;
            }
            
            return {
                area: entityArea,
                description: `${displayConfig.emoji || '📋'} ${schemaData.description || schemaData.title || entityName}`,
                position: displayConfig.position || { x: 1600, y: 1000 },
                relationships: []
            };
        }

        function calculateAutoPosition(area, entityIndex, entitiesInArea) {
            const areaLayouts = {
                'core_traceability': { startX: 1400, startY: 800, cols: 2, spacing: 400 },
                'organizational_foundation': { startX: 100, startY: 400, cols: 1, spacing: 400 },
                'material_supply_chain': { startX: 800, startY: 600, cols: 2, spacing: 400 },
                'transaction_management': { startX: 2400, startY: 800, cols: 1, spacing: 400 },
                'sustainability_claims': { startX: 1400, startY: 200, cols: 3, spacing: 400 },
                'geographic_location': { startX: 500, startY: 1200, cols: 2, spacing: 400 },
                'reporting_compliance': { startX: 2800, startY: 400, cols: 1, spacing: 500 },
                'analytics_data': { startX: 1000, startY: 1800, cols: 3, spacing: 300 },
                'personnel': { startX: 400, startY: 1800, cols: 1, spacing: 400 }
            };
            
            const layout = areaLayouts[area] || areaLayouts['analytics_data'];
            const col = entityIndex % layout.cols;
            const row = Math.floor(entityIndex / layout.cols);
            
            return {
                x: layout.startX + (col * layout.spacing),
                y: layout.startY + (row * layout.spacing)
            };
        }

        function convertSchemaToEntity(entityName, schema, area, description, position) {
            if (!schema || !schema.schema || !schema.schema.properties) {
                return null;
            }

            const properties = schema.schema.properties;
            const required = schema.schema.required || [];
            const fields = [];

            // Convert schema properties to ERD fields
            Object.entries(properties).forEach(([fieldName, fieldDef]) => {
                // Skip JSON-LD context fields
                if (fieldName.startsWith('@')) return;

                let fieldType = fieldDef.type || 'string';
                let isPK = false;
                let isFK = false;
                let isRequired = required.includes(fieldName);

                // Enhanced primary key detection using configuration
                if (fieldName.toLowerCase().includes('id')) {
                    // Check if field name contains entity name (common pattern)
                    const entityLower = entityName.toLowerCase();
                    if (fieldName.toLowerCase().includes(entityLower) || fieldName === 'id') {
                        isPK = true;
                    }
                    // Check configuration for entity-specific primary key patterns
                    else if (globalErdConfig && globalErdConfig.primary_key_mappings && 
                             globalErdConfig.primary_key_mappings[entityName] === fieldName) {
                        isPK = true;
                    }
                }

                // Enhanced FK detection with multiple patterns
                if (!isPK && fieldName !== 'id') {
                    // Check if field follows any FK naming pattern
                    const fkPatterns = [
                        /^[A-Z][a-zA-Z]*Id$/, // OrganizationId, CustomerId
                        /^[a-z][a-zA-Z]*Id$/, // operatorId, materialTypeId
                        /^[a-z]+[A-Z][a-zA-Z]*Id$/, // currentGeographicDataId
                        /^regulatedEntityId$/, // special case
                        /^harvesterId$/, // special case
                        /^cbId$/, // special case
                        /^pathwayId$/, // special case
                        /Id$/  // fallback: any field ending in Id
                    ];
                    
                    isFK = fkPatterns.some(pattern => pattern.test(fieldName));
                }

                // Handle enum types
                if (fieldDef.enum) {
                    fieldType = 'enum';
                }

                // Handle array types
                if (fieldType === 'array') {
                    fieldType = 'array';
                }

                // Handle number types
                if (fieldType === 'number') {
                    fieldType = fieldDef.format === 'date-time' ? 'datetime' : 'decimal';
                }

                fields.push({
                    name: fieldName,
                    type: fieldType,
                    isPK: isPK,
                    isFK: isFK,
                    required: isRequired
                });
            });

            return {
                id: entityName,
                name: entityName,
                area: area,
                description: description,
                fields: fields,
                x: position.x,
                y: position.y
            };
        }

        // Generate automatic relationships from FK fields using EntityNameId convention
        function generateAutomaticFKRelationships(entities, existingRelationships) {
            const automaticRelationships = [];
            const entityNameSet = new Set(entities.map(e => e.id));
            
            // Create lookup for existing relationships to avoid duplicates
            const existingRelLookup = new Set(
                existingRelationships.map(rel => `${rel.from}-${rel.to}`)
            );
            
            for (const entity of entities) {
                // Find all FK fields in this entity
                const fkFields = entity.fields.filter(field => field.isFK);
                
                for (const fkField of fkFields) {
                    // Use EntityNameId convention for trivial matching
                    const targetEntityName = inferTargetEntityFromFK(fkField.name, entityNameSet);
                    
                    if (targetEntityName) {
                        const relationshipKey = `${entity.id}-${targetEntityName}`;
                        
                        // Skip if relationship already exists from metadata
                        if (!existingRelLookup.has(relationshipKey)) {
                            const semanticLabel = convertToSemanticRelationship(fkField.name);
                            const isRequired = entity.schema?.required?.includes(fkField.name);
                            
                            automaticRelationships.push({
                                from: entity.id,
                                to: targetEntityName,
                                label: semanticLabel,
                                type: isRequired ? 'identifying' : 'non-identifying',
                                fromCard: 'many',
                                toCard: 'one'
                            });
                        }
                    }
                }
            }
            
            return automaticRelationships;
        }
        
        // Convert FK field name to semantic relationship label
        function convertToSemanticRelationship(fieldName) {
            // Remove 'Id' suffix if present
            const baseName = fieldName.replace(/Id$/, '');
            
            // Convert PascalCase to snake_case semantic form
            const semantic = baseName
                .replace(/([A-Z])/g, '_$1')  // Insert underscore before capitals
                .toLowerCase()               // Convert to lowercase
                .replace(/^_/, '');          // Remove leading underscore if present
            
            // Return semantic relationship name
            return `references_${semantic}`;
        }
        
        // Enhanced FK matching using multiple naming conventions
        function inferTargetEntityFromFK(fieldName, entityNameSet) {
            // Primary convention: EntityNameId pattern
            if (fieldName.endsWith('Id')) {
                const targetName = fieldName.slice(0, -2);
                if (entityNameSet.has(targetName)) {
                    return targetName;
                }
            }
            
            // Handle common variations and patterns
            const patterns = [
                // Standard patterns
                { pattern: /^([A-Z][a-zA-Z]+)Id$/, transform: (match) => match[1] }, // OrganizationId → Organization
                { pattern: /^([a-z][a-zA-Z]+)Id$/, transform: (match) => capitalizeFirst(match[1]) }, // operatorId → Operator
                
                // Compound patterns
                { pattern: /^([a-z]+)([A-Z][a-zA-Z]+)Id$/, transform: (match) => match[2] }, // materialTypeId → Material, currentGeographicDataId → GeographicData
                { pattern: /^([a-z]+)([A-Z][a-zA-Z]+)DataId$/, transform: (match) => match[2] + 'Data' }, // harvestGeographicDataId → GeographicData
                
                // Generic special cases (specific mappings now in erd-config.json)
                { pattern: /^regulatedEntityId$/, transform: () => 'Organization' },
                { pattern: /^harvesterId$/, transform: () => 'Organization' },
                { pattern: /^cbId$/, transform: () => 'CertificationBody' },
                { pattern: /^pathwayId$/, transform: () => 'LcfsPathway' },
                
                // Underscore patterns (convert to PascalCase)
                { pattern: /^([a-z]+)_([a-z]+)_id$/i, transform: (match) => capitalizeFirst(match[1]) + capitalizeFirst(match[2]) }
            ];
            
            for (const {pattern, transform} of patterns) {
                const match = fieldName.match(pattern);
                if (match) {
                    const targetName = transform(match);
                    if (entityNameSet.has(targetName)) {
                        return targetName;
                    }
                }
            }
            
            return null;
        }
        
        // Helper function to capitalize first letter
        function capitalizeFirst(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }

        // Dynamic Network Analysis Engine
        class NetworkAnalysisEngine {
            constructor(entities, relationships, config = {}) {
                this.entities = entities;
                this.relationships = relationships;
                this.adjacencyList = this.buildAdjacencyList();
                this.entityMap = new Map(entities.map(e => [e.name, e]));
                
                // Configurable network metric weights
                this.networkWeights = {
                    degree: 0.6,        // Primary importance for visual hubs
                    betweenness: 0.3,   // Secondary importance for bottlenecks  
                    closeness: 0.1,     // Tertiary importance for accessibility
                    normalize: true,    // Enable min-max normalization
                    ...config.networkWeights
                };
                
                console.log('NetworkAnalysisEngine initialized with weights:', this.networkWeights);
            }

            buildAdjacencyList() {
                const adjacencyList = new Map();
                
                // Initialize adjacency list
                this.entities.forEach(entity => {
                    adjacencyList.set(entity.name, new Set());
                });

                // Add relationships
                this.relationships.forEach(rel => {
                    if (adjacencyList.has(rel.from) && adjacencyList.has(rel.to)) {
                        adjacencyList.get(rel.from).add(rel.to);
                        adjacencyList.get(rel.to).add(rel.from); // Undirected for layout purposes
                    }
                });

                return adjacencyList;
            }

            // Normalize values to 0-1 range using min-max normalization
            normalizeValues(values) {
                if (values.length === 0) return values;
                
                const min = Math.min(...values);
                const max = Math.max(...values);
                const range = max - min;
                
                if (range === 0) return values.map(() => 0.5); // All values equal
                
                return values.map(value => (value - min) / range);
            }

            // Calculate all centrality metrics for all entities
            calculateAllCentralityMetrics() {
                const degreeValues = [];
                const betweennessValues = [];
                const closenessValues = [];
                const entityNames = [];
                
                // Calculate raw values for all entities
                this.entities.forEach(entity => {
                    const name = entity.name;
                    entityNames.push(name);
                    
                    const degree = this.adjacencyList.get(name).size;
                    const betweenness = this.calculateBetweennessCentrality(name);
                    const closeness = this.calculateClosenessCentrality(name);
                    
                    degreeValues.push(degree);
                    betweennessValues.push(betweenness);
                    closenessValues.push(closeness);
                });
                
                // Normalize if enabled
                const normalizedDegree = this.networkWeights.normalize ? 
                    this.normalizeValues(degreeValues) : degreeValues;
                const normalizedBetweenness = this.networkWeights.normalize ? 
                    this.normalizeValues(betweennessValues) : betweennessValues;
                const normalizedCloseness = this.networkWeights.normalize ? 
                    this.normalizeValues(closenessValues) : closenessValues;
                
                // Create metrics map with weighted scores
                const metrics = new Map();
                entityNames.forEach((name, index) => {
                    const weightedConnectivity = 
                        (normalizedDegree[index] * this.networkWeights.degree) +
                        (normalizedBetweenness[index] * this.networkWeights.betweenness) +
                        (normalizedCloseness[index] * this.networkWeights.closeness);
                    
                    metrics.set(name, {
                        degree: degreeValues[index],
                        betweenness: betweennessValues[index],
                        closeness: closenessValues[index],
                        normalizedDegree: normalizedDegree[index],
                        normalizedBetweenness: normalizedBetweenness[index],
                        normalizedCloseness: normalizedCloseness[index],
                        weightedConnectivity: weightedConnectivity,
                        totalConnectivity: weightedConnectivity // Use weighted score as total
                    });
                });
                
                return metrics;
            }

            calculateConnectivityMetrics() {
                // Use the new weighted approach
                return this.calculateAllCentralityMetrics();
            }

            calculateBetweennessCentrality(targetNode) {
                let betweenness = 0;
                const nodes = Array.from(this.adjacencyList.keys());
                
                // Simplified betweenness centrality calculation
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const source = nodes[i];
                        const target = nodes[j];
                        
                        if (source !== targetNode && target !== targetNode) {
                            const pathsThrough = this.countShortestPathsThrough(source, target, targetNode);
                            const totalPaths = this.countShortestPaths(source, target);
                            
                            if (totalPaths > 0) {
                                betweenness += pathsThrough / totalPaths;
                            }
                        }
                    }
                }
                
                return betweenness;
            }

            calculateClosenessCentrality(targetNode) {
                let totalDistance = 0;
                let reachableNodes = 0;
                
                this.entities.forEach(entity => {
                    if (entity.name !== targetNode) {
                        const distance = this.shortestPathDistance(targetNode, entity.name);
                        if (distance < Infinity) {
                            totalDistance += distance;
                            reachableNodes++;
                        }
                    }
                });
                
                return reachableNodes > 0 ? reachableNodes / totalDistance : 0;
            }

            countShortestPathsThrough(source, target, throughNode) {
                // Simplified implementation - counts if throughNode is on any shortest path
                const pathToThrough = this.shortestPathDistance(source, throughNode);
                const throughToTarget = this.shortestPathDistance(throughNode, target);
                const directPath = this.shortestPathDistance(source, target);
                
                return (pathToThrough + throughToTarget === directPath) ? 1 : 0;
            }

            countShortestPaths(source, target) {
                return this.shortestPathDistance(source, target) < Infinity ? 1 : 0;
            }

            shortestPathDistance(start, end) {
                if (start === end) return 0;
                
                const visited = new Set();
                const queue = [{node: start, distance: 0}];
                
                while (queue.length > 0) {
                    const {node, distance} = queue.shift();
                    
                    if (visited.has(node)) continue;
                    visited.add(node);
                    
                    if (node === end) return distance;
                    
                    const neighbors = this.adjacencyList.get(node) || new Set();
                    neighbors.forEach(neighbor => {
                        if (!visited.has(neighbor)) {
                            queue.push({node: neighbor, distance: distance + 1});
                        }
                    });
                }
                
                return Infinity;
            }

            identifyHubs(threshold = 0.7) {
                const metrics = this.calculateConnectivityMetrics();
                const sortedByConnectivity = Array.from(metrics.entries())
                    .sort((a, b) => b[1].totalConnectivity - a[1].totalConnectivity);
                
                const topN = Math.ceil(sortedByConnectivity.length * threshold);
                const hubs = sortedByConnectivity.slice(0, topN).map(([name, metrics]) => ({
                    name,
                    ...metrics,
                    entity: this.entityMap.get(name)
                }));
                
                console.log('Identified network hubs:', hubs.map(h => 
                    `${h.name} (degree: ${h.degree}, weighted: ${h.weightedConnectivity.toFixed(3)})`));
                return hubs;
            }

            detectCommunitiesLouvain() {
                // Simplified community detection using modularity optimization
                const communities = new Map();
                let communityId = 0;
                
                // Initialize each node as its own community
                this.entities.forEach(entity => {
                    communities.set(entity.name, communityId++);
                });
                
                // Iteratively move nodes to communities that maximize modularity
                let improved = true;
                let iterations = 0;
                const maxIterations = 10;
                
                while (improved && iterations < maxIterations) {
                    improved = false;
                    iterations++;
                    
                    this.entities.forEach(entity => {
                        const currentCommunity = communities.get(entity.name);
                        let bestCommunity = currentCommunity;
                        let bestModularityGain = 0;
                        
                        // Check all neighboring communities
                        const neighbors = this.adjacencyList.get(entity.name);
                        const neighborCommunities = new Set();
                        
                        neighbors.forEach(neighbor => {
                            neighborCommunities.add(communities.get(neighbor));
                        });
                        
                        neighborCommunities.forEach(communityId => {
                            if (communityId !== currentCommunity) {
                                const modularityGain = this.calculateModularityGain(entity.name, communityId, communities);
                                if (modularityGain > bestModularityGain) {
                                    bestModularityGain = modularityGain;
                                    bestCommunity = communityId;
                                    improved = true;
                                }
                            }
                        });
                        
                        communities.set(entity.name, bestCommunity);
                    });
                }
                
                // Group entities by community
                const communityGroups = new Map();
                communities.forEach((communityId, entityName) => {
                    if (!communityGroups.has(communityId)) {
                        communityGroups.set(communityId, []);
                    }
                    communityGroups.get(communityId).push(entityName);
                });
                
                console.log('Detected communities:', Array.from(communityGroups.values()));
                return communityGroups;
            }

            calculateModularityGain(node, targetCommunity, communities) {
                // Simplified modularity gain calculation
                const currentCommunity = communities.get(node);
                const neighbors = this.adjacencyList.get(node);
                
                let currentCommunityEdges = 0;
                let targetCommunityEdges = 0;
                
                neighbors.forEach(neighbor => {
                    if (communities.get(neighbor) === currentCommunity) {
                        currentCommunityEdges++;
                    }
                    if (communities.get(neighbor) === targetCommunity) {
                        targetCommunityEdges++;
                    }
                });
                
                return targetCommunityEdges - currentCommunityEdges;
            }
        }

        // Dynamic Layout Engine with Force-Directed Algorithm
        class DynamicLayoutEngine {
            constructor(entities, relationships, erdConfig, config = {}) {
                this.entities = entities;
                this.relationships = relationships;
                this.erdConfig = erdConfig;
                
                // Initialize NetworkAnalysisEngine with configuration
                this.networkAnalysis = new NetworkAnalysisEngine(entities, relationships, config);
                
                // Layout parameters (adaptive based on network size)
                this.canvasWidth = 3200;
                this.canvasHeight = 1800;
                this.categoryPadding = 400;
                this.entitySpacing = 200;
                
                // Multi-force weighting configuration
                this.forceWeights = {
                    repulsive: 0.4,      // Balanced node separation (exponential scaling handles close distances)
                    attractive: 0.25,    // Moderate connection strength for relationships
                    categorical: 0.15,   // Reduced category grouping to prioritize connectivity
                    hub: 0.6,           // Very strong hub centralization for network structure
                    baseK: 150,         // Base force constant
                    ...config.forceWeights
                };
                
                // Layout priority configuration
                this.layoutPriorities = {
                    connectivity: 0.4,    // Algorithmic network optimization
                    categorization: 0.3,  // Functional grouping maintenance  
                    aesthetics: 0.3,     // Visual appeal (spacing, symmetry)
                    ...config.layoutPriorities
                };
                
                // Adaptive force parameters
                const networkDensity = (relationships.length * 2) / (entities.length * (entities.length - 1));
                this.iterations = Math.max(80, Math.min(200, 120 + Math.floor(networkDensity * 100))); // More iterations
                this.coolingFactor = 0.98; // Slower cooling for more stability
                this.initialTemperature = 150; // Higher initial temperature
                this.k = this.forceWeights.baseK * Math.sqrt(networkDensity + 0.1); // Adaptive k based on density
                
                console.log('DynamicLayoutEngine initialized:', {
                    entities: entities.length,
                    relationships: relationships.length,
                    networkDensity: networkDensity.toFixed(3),
                    adaptiveK: this.k.toFixed(1),
                    iterations: this.iterations,
                    forceWeights: this.forceWeights
                });
            }

            calculateDynamicLayout() {
                console.log('Starting dynamic layout calculation...');
                const startTime = performance.now();
                
                // Phase 1: Network analysis
                const hubs = this.networkAnalysis.identifyHubs(0.3); // Top 30% as hubs
                console.log('Network hubs identified:', hubs.map(h => h.name));
                
                // Phase 2: Create simple initial spread to avoid overlaps
                let positions = this.createInitialSpreadLayout();
                
                // Phase 3: Force-directed layout with hub preservation integrated
                positions = this.applyForceDirectedLayoutWithHubs(positions, hubs);
                
                // Phase 4: Final collision elimination (guaranteed no overlaps)
                positions = this.eliminateAllCollisions(positions);
                
                const endTime = performance.now();
                console.log(`Dynamic layout calculated in ${Math.round(endTime - startTime)}ms`);
                
                return positions;
            }

            createInitialSpreadLayout() {
                const positions = new Map();
                
                // Use category-based initial layout instead of random grid
                // This gives much better starting positions that align with the final layout goals
                const categoryRegions = this.calculateCategoryRegions();
                
                Object.entries(this.erdConfig.areas).forEach(([areaKey, area]) => {
                    const region = categoryRegions[areaKey];
                    const entitiesInArea = area.entities.filter(entityName => 
                        this.entities.some(e => e.name === entityName)
                    );
                    
                    // Arrange entities within their category region
                    entitiesInArea.forEach((entityName, index) => {
                        const position = this.calculateEntityPositionInRegion(region, index, entitiesInArea.length);
                        
                        // Debug: Log initial positions for problem entity
                        if (entityName === 'SalesDeliveryDocument') {
                            console.log(`SalesDeliveryDocument initial position: area=${areaKey}, center=(${Math.round(region.centerX)}, ${Math.round(region.centerY)}), pos=(${Math.round(position.x)}, ${Math.round(position.y)})`);
                        }
                        
                        positions.set(entityName, position);
                    });
                });
                
                console.log(`Initial category-based layout: ${Object.keys(this.erdConfig.areas).length} category regions`);
                return positions;
            }

            applyForceDirectedLayoutWithHubs(initialPositions, hubs) {
                let positions = new Map(initialPositions);
                let temperature = this.initialTemperature;
                
                console.log('Starting integrated force-directed layout with hub preservation');
                
                for (let iteration = 0; iteration < this.iterations; iteration++) {
                    const forces = this.calculateForcesWithHubs(positions, hubs);
                    positions = this.updatePositionsWithCollisionAvoidance(positions, forces, temperature);
                    temperature *= this.coolingFactor;
                    
                    if (iteration % 20 === 0) {
                        console.log(`Iteration ${iteration}, temp: ${temperature.toFixed(2)}, hub positions:`, 
                            hubs.slice(0, 3).map(h => {
                                const pos = positions.get(h.name);
                                return `${h.name}(${Math.round(pos.x)},${Math.round(pos.y)})`;
                            }).join(', ')
                        );
                    }
                }
                
                return positions;
            }

            calculateForcesWithHubs(positions, hubs) {
                const forces = new Map();
                
                // Initialize forces
                this.entities.forEach(entity => {
                    forces.set(entity.name, { x: 0, y: 0 });
                });
                
                // Repulsive forces with distance-based scaling
                this.entities.forEach(entity1 => {
                    this.entities.forEach(entity2 => {
                        if (entity1.name !== entity2.name) {
                            const pos1 = positions.get(entity1.name);
                            const pos2 = positions.get(entity2.name);
                            const distance = Math.sqrt((pos1.x - pos2.x) ** 2 + (pos1.y - pos2.y) ** 2);
                            
                            // Use the new enhanced repulsive force calculation (handles distance scaling internally)
                            const force = this.calculateRepulsiveForce(pos1, pos2);
                            const weightedForce = {
                                x: force.x * this.forceWeights.repulsive,
                                y: force.y * this.forceWeights.repulsive
                            };
                            
                            const currentForce = forces.get(entity1.name);
                            forces.set(entity1.name, {
                                x: currentForce.x + weightedForce.x,
                                y: currentForce.y + weightedForce.y
                            });
                        }
                    });
                });
                
                // Attractive forces for relationships
                this.relationships.forEach(rel => {
                    const pos1 = positions.get(rel.from);
                    const pos2 = positions.get(rel.to);
                    
                    if (pos1 && pos2) {
                        const force = this.calculateAttractiveForce(pos1, pos2);
                        const weightedForce = {
                            x: force.x * this.forceWeights.attractive,
                            y: force.y * this.forceWeights.attractive
                        };
                        
                        const force1 = forces.get(rel.from);
                        const force2 = forces.get(rel.to);
                        
                        forces.set(rel.from, {
                            x: force1.x - weightedForce.x, // Attractive force pulls towards
                            y: force1.y - weightedForce.y
                        });
                        
                        forces.set(rel.to, {
                            x: force2.x + weightedForce.x,
                            y: force2.y + weightedForce.y
                        });
                    }
                });
                
                // Strong central forces for hubs
                const centerX = this.canvasWidth / 2;
                const centerY = this.canvasHeight / 2;
                
                hubs.forEach((hub, index) => {
                    if (index < 3) { // Focus on top 3 hubs
                        const pos = positions.get(hub.name);
                        const idealPos = this.calculateHubPosition(hub, index);
                        
                        const dx = idealPos.x - pos.x;
                        const dy = idealPos.y - pos.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 20) { // Only apply if hub is significantly displaced
                            const force = forces.get(hub.name);
                            // Very strong hub centralization force based on connectivity
                            const hubForceStrength = hub.weightedConnectivity * this.forceWeights.hub * 20;
                            
                            forces.set(hub.name, {
                                x: force.x + (dx / distance) * hubForceStrength,
                                y: force.y + (dy / distance) * hubForceStrength
                            });
                        }
                    }
                });
                
                return forces;
            }

            updatePositionsWithCollisionAvoidance(positions, forces, temperature) {
                const newPositions = new Map();
                const minDistance = 130; // Minimum distance between entities
                
                // First pass: calculate intended positions
                const intendedPositions = new Map();
                this.entities.forEach(entity => {
                    const currentPos = positions.get(entity.name);
                    const force = forces.get(entity.name);
                    
                    const displacement = Math.sqrt(force.x * force.x + force.y * force.y);
                    const maxDisplacement = Math.min(displacement, temperature);
                    
                    let newX = currentPos.x;
                    let newY = currentPos.y;
                    
                    if (displacement > 0) {
                        newX += (force.x / displacement) * maxDisplacement;
                        newY += (force.y / displacement) * maxDisplacement;
                    }
                    
                    // Keep within canvas bounds with margin
                    newX = Math.max(120, Math.min(this.canvasWidth - 120, newX));
                    newY = Math.max(120, Math.min(this.canvasHeight - 120, newY));
                    
                    intendedPositions.set(entity.name, { x: newX, y: newY });
                });
                
                // Second pass: resolve collisions by pushing apart
                this.entities.forEach(entity => {
                    const intendedPos = intendedPositions.get(entity.name);
                    let finalX = intendedPos.x;
                    let finalY = intendedPos.y;
                    
                    // Check all other entities for potential collisions
                    this.entities.forEach(otherEntity => {
                        if (otherEntity.name !== entity.name) {
                            const otherIntendedPos = intendedPositions.get(otherEntity.name);
                            const dx = finalX - otherIntendedPos.x;
                            const dy = finalY - otherIntendedPos.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < minDistance && distance > 0) {
                                // Push entities apart by half the overlap distance each
                                const overlap = minDistance - distance;
                                const pushDistance = overlap / 2 + 5;
                                
                                const unitX = dx / distance;
                                const unitY = dy / distance;
                                
                                finalX += unitX * pushDistance;
                                finalY += unitY * pushDistance;
                            }
                        }
                    });
                    
                    // Ensure still within bounds after collision resolution
                    finalX = Math.max(120, Math.min(this.canvasWidth - 120, finalX));
                    finalY = Math.max(120, Math.min(this.canvasHeight - 120, finalY));
                    
                    newPositions.set(entity.name, { x: finalX, y: finalY });
                });
                
                return newPositions;
            }

            createInitialCategoricalLayout() {
                const positions = new Map();
                const categoryRegions = this.calculateCategoryRegions();
                
                // Distribute entities within their category regions
                Object.entries(this.erdConfig.areas).forEach(([areaKey, area]) => {
                    const region = categoryRegions[areaKey];
                    const entitiesInArea = area.entities.filter(entityName => 
                        this.entities.some(e => e.name === entityName)
                    );
                    
                    entitiesInArea.forEach((entityName, index) => {
                        const position = this.calculateEntityPositionInRegion(region, index, entitiesInArea.length);
                        positions.set(entityName, position);
                    });
                });
                
                return positions;
            }

            calculateCategoryRegions() {
                const areas = Object.keys(this.erdConfig.areas);
                const regions = {};
                
                // Use a strategic layout that avoids placing any category at exact canvas center
                // Position categories in a ring pattern around the center, leaving center for hubs
                const canvasCenterX = this.canvasWidth / 2;
                const canvasCenterY = this.canvasHeight / 2;
                const ringRadius = 600; // Distance from center
                
                areas.forEach((areaKey, index) => {
                    // Position categories in a circle around the center
                    const angle = (2 * Math.PI * index) / areas.length;
                    const centerX = canvasCenterX + ringRadius * Math.cos(angle);
                    const centerY = canvasCenterY + ringRadius * Math.sin(angle);
                    
                    // Each category gets a circular region
                    const regionRadius = 400;
                    
                    regions[areaKey] = {
                        x: centerX - regionRadius,
                        y: centerY - regionRadius,
                        width: regionRadius * 2,
                        height: regionRadius * 2,
                        centerX: centerX,
                        centerY: centerY
                    };
                    
                    console.log(`Category ${areaKey}: center=(${Math.round(centerX)}, ${Math.round(centerY)}), angle=${Math.round(angle * 180 / Math.PI)}°`);
                });
                
                return regions;
            }

            calculateEntityPositionInRegion(region, index, total) {
                // Arrange entities in a rough circle within the region
                const centerX = region.centerX;
                const centerY = region.centerY;
                const radius = Math.min(region.width, region.height) * 0.3;
                
                if (total === 1) {
                    return { x: centerX, y: centerY };
                }
                
                const angle = (2 * Math.PI * index) / total;
                return {
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle)
                };
            }

            adjustForHubs(positions, hubs) {
                // Move high-connectivity hubs to more central positions
                const adjustedPositions = new Map(positions);
                
                hubs.forEach((hub, index) => {
                    if (index < 3) { // Top 3 hubs get special treatment
                        const hubPosition = this.calculateHubPosition(hub, index);
                        adjustedPositions.set(hub.name, hubPosition);
                    }
                });
                
                return adjustedPositions;
            }

            calculateHubPosition(hub, hubIndex) {
                const centerX = this.canvasWidth / 2;
                const centerY = this.canvasHeight / 2;
                
                // FIXED: Top hubs should be positioned AT the center, not around it
                if (hubIndex < 3) { // Top 3 hubs go to center
                    const hubRadius = 100; // Very small radius for tight central clustering
                    
                    // Slight offset to prevent exact overlap
                    const angles = [0, 2 * Math.PI / 3, 4 * Math.PI / 3];
                    const angle = angles[hubIndex] || 0;
                    
                    return {
                        x: centerX + hubRadius * Math.cos(angle),
                        y: centerY + hubRadius * Math.sin(angle)
                    };
                }
                
                // Lower priority hubs positioned in wider ring
                const hubRadius = 300;
                const angles = [0, 2 * Math.PI / 3, 4 * Math.PI / 3];
                const angle = angles[hubIndex % 3] || 0;
                
                return {
                    x: centerX + hubRadius * Math.cos(angle),
                    y: centerY + hubRadius * Math.sin(angle)
                };
            }

            applyForceDirectedLayout(initialPositions) {
                let positions = new Map(initialPositions);
                let temperature = this.initialTemperature;
                
                for (let iteration = 0; iteration < this.iterations; iteration++) {
                    const forces = this.calculateForces(positions);
                    positions = this.updatePositions(positions, forces, temperature);
                    temperature *= this.coolingFactor;
                    
                    if (iteration % 20 === 0) {
                        console.log(`Force-directed iteration ${iteration}, temperature: ${temperature.toFixed(2)}`);
                        
                        // Debug: Track TraceableUnit position during iterations
                        if (positions.has('TraceableUnit')) {
                            const traceablePos = positions.get('TraceableUnit');
                            console.log(`  Iteration ${iteration}: TraceableUnit(${Math.round(traceablePos.x)},${Math.round(traceablePos.y)})`);
                        }
                    }
                }
                
                return positions;
            }

            calculateForces(positions) {
                const forces = new Map();
                
                // Initialize forces
                this.entities.forEach(entity => {
                    forces.set(entity.name, { x: 0, y: 0 });
                });
                
                // Debug: Track force components for TraceableUnit
                const debugEntity = 'TraceableUnit';
                let debugForces = { repulsive: {x: 0, y: 0}, attractive: {x: 0, y: 0}, hub: {x: 0, y: 0}, categorical: {x: 0, y: 0} };
                
                // Repulsive forces between all entities (weighted)
                this.entities.forEach(entity1 => {
                    this.entities.forEach(entity2 => {
                        if (entity1.name !== entity2.name) {
                            const pos1 = positions.get(entity1.name);
                            const pos2 = positions.get(entity2.name);
                            const force = this.calculateRepulsiveForce(pos1, pos2);
                            
                            // Apply repulsive force weight
                            const weightedForce = {
                                x: force.x * this.forceWeights.repulsive,
                                y: force.y * this.forceWeights.repulsive
                            };
                            
                            // Debug: Track repulsive forces for TraceableUnit
                            if (entity1.name === debugEntity) {
                                debugForces.repulsive.x += weightedForce.x;
                                debugForces.repulsive.y += weightedForce.y;
                            }
                            
                            const currentForce = forces.get(entity1.name);
                            forces.set(entity1.name, {
                                x: currentForce.x + weightedForce.x,
                                y: currentForce.y + weightedForce.y
                            });
                        }
                    });
                });
                
                // Attractive forces for connected entities (weighted)
                this.relationships.forEach(rel => {
                    const pos1 = positions.get(rel.from);
                    const pos2 = positions.get(rel.to);
                    
                    if (pos1 && pos2) {
                        const force = this.calculateAttractiveForce(pos1, pos2);
                        
                        // Apply attractive force weight
                        const weightedForce = {
                            x: force.x * this.forceWeights.attractive,
                            y: force.y * this.forceWeights.attractive
                        };
                        
                        // Debug: Track attractive forces for TraceableUnit
                        if (rel.from === debugEntity) {
                            debugForces.attractive.x += weightedForce.x;
                            debugForces.attractive.y += weightedForce.y;
                        } else if (rel.to === debugEntity) {
                            debugForces.attractive.x -= weightedForce.x;
                            debugForces.attractive.y -= weightedForce.y;
                        }
                        
                        // Apply force to both entities
                        const force1 = forces.get(rel.from);
                        const force2 = forces.get(rel.to);
                        
                        forces.set(rel.from, {
                            x: force1.x + weightedForce.x,
                            y: force1.y + weightedForce.y
                        });
                        
                        forces.set(rel.to, {
                            x: force2.x - weightedForce.x,
                            y: force2.y - weightedForce.y
                        });
                    }
                });
                
                // Hub preservation forces (weighted)
                this.applyHubPreservationForces(positions, forces, debugForces);
                
                // Categorical grouping forces (weighted)
                this.applyCategoricalForces(positions, forces, debugForces);
                
                // Debug: Log force breakdown for TraceableUnit
                if (forces.has(debugEntity)) {
                    const totalForce = forces.get(debugEntity);
                    const totalMagnitude = Math.sqrt(totalForce.x * totalForce.x + totalForce.y * totalForce.y);
                    const repulsiveMag = Math.sqrt(debugForces.repulsive.x * debugForces.repulsive.x + debugForces.repulsive.y * debugForces.repulsive.y);
                    const attractiveMag = Math.sqrt(debugForces.attractive.x * debugForces.attractive.x + debugForces.attractive.y * debugForces.attractive.y);
                    const hubMag = Math.sqrt(debugForces.hub.x * debugForces.hub.x + debugForces.hub.y * debugForces.hub.y);
                    const catMag = Math.sqrt(debugForces.categorical.x * debugForces.categorical.x + debugForces.categorical.y * debugForces.categorical.y);
                    
                    console.log(`🔍 ${debugEntity} Force Analysis:`);
                    console.log(`  Repulsive: (${debugForces.repulsive.x.toFixed(1)}, ${debugForces.repulsive.y.toFixed(1)}) mag=${repulsiveMag.toFixed(1)}`);
                    console.log(`  Attractive: (${debugForces.attractive.x.toFixed(1)}, ${debugForces.attractive.y.toFixed(1)}) mag=${attractiveMag.toFixed(1)}`);
                    console.log(`  Hub: (${debugForces.hub.x.toFixed(1)}, ${debugForces.hub.y.toFixed(1)}) mag=${hubMag.toFixed(1)}`);
                    console.log(`  Categorical: (${debugForces.categorical.x.toFixed(1)}, ${debugForces.categorical.y.toFixed(1)}) mag=${catMag.toFixed(1)}`);
                    console.log(`  TOTAL: (${totalForce.x.toFixed(1)}, ${totalForce.y.toFixed(1)}) mag=${totalMagnitude.toFixed(1)}`);
                }
                
                return forces;
            }

            calculateRepulsiveForce(pos1, pos2) {
                const dx = pos1.x - pos2.x;
                const dy = pos1.y - pos2.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Handle zero distance case with strong random separation
                if (distance < 1) {
                    const randomAngle = Math.random() * 2 * Math.PI;
                    return {
                        x: Math.cos(randomAngle) * 1000, // Very strong force
                        y: Math.sin(randomAngle) * 1000
                    };
                }
                
                const unitX = dx / distance;
                const unitY = dy / distance;
                
                // Exponentially increasing repulsive force as distance decreases
                // This creates a "hard boundary" that prevents overlaps
                const minDistance = 140; // Our target minimum distance
                let force;
                
                if (distance < minDistance) {
                    // Exponential repulsion that becomes extremely strong as distance approaches 0
                    const ratio = minDistance / distance;
                    force = Math.pow(ratio, 3) * 2000; // Cubic growth for very strong repulsion
                } else if (distance < minDistance * 1.5) {
                    // Strong repulsion in the warning zone
                    force = (this.k * this.k) / (distance * distance) * 10;
                } else {
                    // Standard Fruchterman-Reingold formula for distant entities
                    force = (this.k * this.k) / (distance * distance);
                }
                
                return {
                    x: force * unitX,
                    y: force * unitY
                };
            }

            calculateAttractiveForce(pos1, pos2) {
                const dx = pos1.x - pos2.x;
                const dy = pos1.y - pos2.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 1) return { x: 0, y: 0 };
                
                const unitX = dx / distance;
                const unitY = dy / distance;
                
                // Balanced attractive force to create connectivity-based cohesion
                // Cap the attractive force but allow reasonable pulling power
                const maxAttractiveDistance = 600; // Increased range for better connectivity grouping
                const effectiveDistance = Math.min(distance, maxAttractiveDistance);
                
                // Moderate attractive force formula with better scaling
                const baseForce = effectiveDistance / (this.k * 1.5); // Less weakened than before
                const force = Math.min(baseForce, 80); // Increased cap for better cohesion
                
                return {
                    x: -force * unitX, // Negative because we want to pull towards each other
                    y: -force * unitY
                };
            }

            applyHubPreservationForces(positions, forces, debugForces = null) {
                // Get hub entities based on weighted connectivity
                const hubs = this.networkAnalysis.identifyHubs(0.3); // Top 30% as hubs
                const centerX = this.canvasWidth / 2;
                const centerY = this.canvasHeight / 2;
                
                hubs.forEach((hub, index) => {
                    if (positions.has(hub.name) && index < 3) { // Focus on top 3 hubs
                        const pos = positions.get(hub.name);
                        const idealHubPos = this.calculateHubPosition(hub, index);
                        
                        // Debug: Log hub positions
                        console.log(`Hub ${index + 1}: ${hub.name} → ideal=(${Math.round(idealHubPos.x)}, ${Math.round(idealHubPos.y)}), current=(${Math.round(pos.x)}, ${Math.round(pos.y)})`);
                        
                        const dx = idealHubPos.x - pos.x;
                        const dy = idealHubPos.y - pos.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 50) { // Only apply if hub is displaced from ideal position
                            const force = forces.get(hub.name);
                            // NUCLEAR hub preservation force strength - must overpower repulsive forces
                            const hubStrength = hub.weightedConnectivity * this.forceWeights.hub * 100; // 4x stronger
                            
                            const hubForceX = (dx / distance) * hubStrength;
                            const hubForceY = (dy / distance) * hubStrength;
                            
                            // Debug: Log force calculations for TraceableUnit
                            if (hub.name === 'TraceableUnit') {
                                console.log(`TraceableUnit hub force: connectivity=${hub.weightedConnectivity.toFixed(3)}, hubWeight=${this.forceWeights.hub}, multiplier=25, hubStrength=${hubStrength.toFixed(1)}, distance=${Math.round(distance)}`);
                                console.log(`TraceableUnit hub force components: (${hubForceX.toFixed(1)}, ${hubForceY.toFixed(1)})`);
                            }
                            
                            // Track debug forces for TraceableUnit
                            if (debugForces && hub.name === 'TraceableUnit') {
                                debugForces.hub.x += hubForceX;
                                debugForces.hub.y += hubForceY;
                            }
                            
                            forces.set(hub.name, {
                                x: force.x + hubForceX,
                                y: force.y + hubForceY
                            });
                        }
                    }
                });
            }

            applyCategoricalForces(positions, forces, debugForces = null) {
                const categoryRegions = this.calculateCategoryRegions();
                
                // Get list of hub entities to exclude from categorical forces
                const hubs = this.networkAnalysis.identifyHubs(0.3);
                const hubNames = new Set(hubs.slice(0, 3).map(hub => hub.name)); // Top 3 hubs
                
                // Debug: Log category centers
                console.log('Category centers:', Object.entries(categoryRegions).map(([key, region]) => 
                    `${key}: (${Math.round(region.centerX)}, ${Math.round(region.centerY)})`
                ).join(', '));
                console.log('🔍 Hub entities excluded from categorical forces:', Array.from(hubNames).join(', '));
                
                Object.entries(this.erdConfig.areas).forEach(([areaKey, area]) => {
                    const region = categoryRegions[areaKey];
                    const centerX = region.centerX;
                    const centerY = region.centerY;
                    
                    area.entities.forEach(entityName => {
                        if (positions.has(entityName)) {
                            // Hub entities get much weaker categorical forces (10% strength)
                            const isHub = hubNames.has(entityName);
                            const hubReduction = isHub ? 0.1 : 1.0;
                            
                            if (isHub) {
                                console.log(`🔽 Applying weak categorical force for hub: ${entityName} (${(hubReduction * 100).toFixed(0)}% strength)`);
                            }
                            
                            const pos = positions.get(entityName);
                            const dx = centerX - pos.x;
                            const dy = centerY - pos.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            // Debug: Log entity-to-center assignments for problem entities
                            if (entityName === 'SalesDeliveryDocument' || entityName === 'TraceableUnit') {
                                console.log(`${entityName}: area=${areaKey}, center=(${Math.round(centerX)}, ${Math.round(centerY)}), current=(${Math.round(pos.x)}, ${Math.round(pos.y)}), distance=${Math.round(distance)}`);
                            }
                            
                            // Apply categorical force with distance-based scaling
                            const force = forces.get(entityName);
                            
                            // Stronger categorical pull with distance-based scaling
                            let basePullStrength = 0.5; // Increased from 0.1
                            
                            // Scale force based on distance from category center
                            if (distance > region.width * 0.6) {
                                basePullStrength *= 2.0; // Very strong pull for distant entities
                            } else if (distance > region.width * 0.4) {
                                basePullStrength *= 1.5; // Strong pull for moderately distant entities
                            } else {
                                basePullStrength *= 0.8; // Gentle pull for entities already near center
                            }
                            
                            const weightedPullStrength = basePullStrength * this.forceWeights.categorical * hubReduction;
                            const catForceX = dx * weightedPullStrength;
                            const catForceY = dy * weightedPullStrength;
                            
                            // Track debug forces for TraceableUnit (should be 0 now)
                            if (debugForces && entityName === 'TraceableUnit') {
                                debugForces.categorical.x += catForceX;
                                debugForces.categorical.y += catForceY;
                            }
                            
                            forces.set(entityName, {
                                x: force.x + catForceX,
                                y: force.y + catForceY
                            });
                        }
                    });
                });
            }

            updatePositions(positions, forces, temperature) {
                const newPositions = new Map();
                
                this.entities.forEach(entity => {
                    const currentPos = positions.get(entity.name);
                    const force = forces.get(entity.name);
                    
                    const displacement = Math.sqrt(force.x * force.x + force.y * force.y);
                    const maxDisplacement = Math.min(displacement, temperature);
                    
                    let newX = currentPos.x;
                    let newY = currentPos.y;
                    
                    if (displacement > 0) {
                        newX += (force.x / displacement) * maxDisplacement;
                        newY += (force.y / displacement) * maxDisplacement;
                    }
                    
                    // Keep within canvas bounds
                    newX = Math.max(50, Math.min(this.canvasWidth - 50, newX));
                    newY = Math.max(50, Math.min(this.canvasHeight - 50, newY));
                    
                    newPositions.set(entity.name, { x: newX, y: newY });
                });
                
                return newPositions;
            }

            resolveCollisions(positions) {
                const resolvedPositions = new Map(positions);
                // Adaptive minimum distance based on layout priorities
                const baseMinDistance = 120;
                const aestheticsWeight = this.layoutPriorities.aesthetics;
                const minDistance = baseMinDistance * (0.8 + aestheticsWeight * 0.4); // 96-144 range
                
                let hasCollisions = true;
                let iterations = 0;
                const maxIterations = 30; // Reduced from 50
                
                while (hasCollisions && iterations < maxIterations) {
                    hasCollisions = false;
                    iterations++;
                    
                    this.entities.forEach(entity1 => {
                        this.entities.forEach(entity2 => {
                            if (entity1.name !== entity2.name) {
                                const pos1 = resolvedPositions.get(entity1.name);
                                const pos2 = resolvedPositions.get(entity2.name);
                                
                                const dx = pos1.x - pos2.x;
                                const dy = pos1.y - pos2.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                
                                if (distance < minDistance) {
                                    hasCollisions = true;
                                    
                                    // Move entities apart
                                    const overlap = minDistance - distance;
                                    const moveDistance = overlap / 2 + 10;
                                    
                                    const unitX = dx / distance || Math.random() - 0.5;
                                    const unitY = dy / distance || Math.random() - 0.5;
                                    
                                    resolvedPositions.set(entity1.name, {
                                        x: pos1.x + unitX * moveDistance,
                                        y: pos1.y + unitY * moveDistance
                                    });
                                    
                                    resolvedPositions.set(entity2.name, {
                                        x: pos2.x - unitX * moveDistance,
                                        y: pos2.y - unitY * moveDistance
                                    });
                                }
                            }
                        });
                    });
                }
                
                console.log(`Collision resolution completed in ${iterations} iterations`);
                return resolvedPositions;
            }

            eliminateAllCollisions(positions) {
                console.log('Starting guaranteed collision elimination phase...');
                const startTime = performance.now();
                let eliminatedPositions = new Map(positions);
                const minDistance = 140; // Minimum distance for final pass
                let totalMoves = 0;
                let maxPasses = 15; // Increased maximum passes
                let previousCollisionCount = Infinity;
                let stuckCount = 0;
                
                for (let pass = 0; pass < maxPasses; pass++) {
                    let movesMadeThisPass = 0;
                    let collisionsDetected = [];
                    
                    // First, detect all collisions
                    const entityList = Array.from(eliminatedPositions.keys());
                    for (let i = 0; i < entityList.length; i++) {
                        for (let j = i + 1; j < entityList.length; j++) {
                            const entity1 = entityList[i];
                            const entity2 = entityList[j];
                            const pos1 = eliminatedPositions.get(entity1);
                            const pos2 = eliminatedPositions.get(entity2);
                            
                            const dx = pos1.x - pos2.x;
                            const dy = pos1.y - pos2.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < minDistance) {
                                collisionsDetected.push({
                                    entity1, entity2, pos1, pos2, 
                                    distance, dx, dy,
                                    overlap: minDistance - distance
                                });
                            }
                        }
                    }
                    
                    if (collisionsDetected.length === 0) {
                        console.log(`Collision elimination completed after ${pass + 1} passes with no remaining overlaps`);
                        break;
                    }
                    
                    console.log(`Pass ${pass + 1}: Found ${collisionsDetected.length} collisions`);
                    
                    // Check if we're stuck (same number of collisions as last pass)
                    if (collisionsDetected.length === previousCollisionCount) {
                        stuckCount++;
                        if (stuckCount >= 3) {
                            // We're stuck - use more aggressive separation
                            console.log(`Pass ${pass + 1}: Stuck with ${collisionsDetected.length} collisions - switching to aggressive mode`);
                        }
                    } else {
                        stuckCount = 0; // Reset stuck counter if we made progress
                    }
                    previousCollisionCount = collisionsDetected.length;
                    
                    // Sort collisions by overlap amount (resolve worst overlaps first)
                    collisionsDetected.sort((a, b) => b.overlap - a.overlap);
                    
                    // Resolve each collision by moving both entities apart
                    collisionsDetected.forEach((collision, index) => {
                        const { entity1, entity2, dx, dy, distance, overlap } = collision;
                        
                        if (distance > 0) {
                            // Calculate unit vector for separation direction
                            const unitX = dx / distance;
                            const unitY = dy / distance;
                            
                            // Aggressive separation when stuck, normal otherwise
                            let separationMultiplier = 1.0;
                            if (stuckCount >= 3) {
                                separationMultiplier = 1.5 + (stuckCount * 0.2); // Increasingly aggressive
                            }
                            
                            // Move each entity by half the required separation distance plus buffer
                            const separationDistance = ((overlap / 2) + 15) * separationMultiplier;
                            
                            const currentPos1 = eliminatedPositions.get(entity1);
                            const currentPos2 = eliminatedPositions.get(entity2);
                            
                            let newPos1 = {
                                x: currentPos1.x + unitX * separationDistance,
                                y: currentPos1.y + unitY * separationDistance
                            };
                            
                            let newPos2 = {
                                x: currentPos2.x - unitX * separationDistance,
                                y: currentPos2.y - unitY * separationDistance
                            };
                            
                            // For stuck situations, try alternative separation patterns
                            if (stuckCount >= 5 && index % 2 === 0) {
                                // For every other collision, try perpendicular separation
                                const perpX = -unitY;
                                const perpY = unitX;
                                const perpSeparation = separationDistance * 0.7;
                                
                                newPos1.x += perpX * perpSeparation;
                                newPos1.y += perpY * perpSeparation;
                                newPos2.x -= perpX * perpSeparation;
                                newPos2.y -= perpY * perpSeparation;
                            }
                            
                            // Ensure positions stay within canvas bounds with more room at edges
                            const margin = 180; // Larger margin to prevent edge clustering
                            newPos1.x = Math.max(margin, Math.min(this.canvasWidth - margin, newPos1.x));
                            newPos1.y = Math.max(margin, Math.min(this.canvasHeight - margin, newPos1.y));
                            newPos2.x = Math.max(margin, Math.min(this.canvasWidth - margin, newPos2.x));
                            newPos2.y = Math.max(margin, Math.min(this.canvasHeight - margin, newPos2.y));
                            
                            eliminatedPositions.set(entity1, newPos1);
                            eliminatedPositions.set(entity2, newPos2);
                            
                            movesMadeThisPass++;
                            totalMoves++;
                        } else {
                            // Handle edge case where entities are at exactly the same position
                            console.log(`Pass ${pass + 1}: Entities ${entity1} and ${entity2} at identical position - applying random separation`);
                            const currentPos1 = eliminatedPositions.get(entity1);
                            const currentPos2 = eliminatedPositions.get(entity2);
                            
                            const randomAngle = Math.random() * 2 * Math.PI;
                            const separationDistance = minDistance / 2 + 20;
                            
                            const newPos1 = {
                                x: currentPos1.x + Math.cos(randomAngle) * separationDistance,
                                y: currentPos1.y + Math.sin(randomAngle) * separationDistance
                            };
                            
                            const newPos2 = {
                                x: currentPos2.x - Math.cos(randomAngle) * separationDistance,
                                y: currentPos2.y - Math.sin(randomAngle) * separationDistance
                            };
                            
                            const margin = 180;
                            newPos1.x = Math.max(margin, Math.min(this.canvasWidth - margin, newPos1.x));
                            newPos1.y = Math.max(margin, Math.min(this.canvasHeight - margin, newPos1.y));
                            newPos2.x = Math.max(margin, Math.min(this.canvasWidth - margin, newPos2.x));
                            newPos2.y = Math.max(margin, Math.min(this.canvasHeight - margin, newPos2.y));
                            
                            eliminatedPositions.set(entity1, newPos1);
                            eliminatedPositions.set(entity2, newPos2);
                            
                            movesMadeThisPass++;
                            totalMoves++;
                        }
                    });
                    
                    console.log(`Pass ${pass + 1}: Made ${movesMadeThisPass} entity moves (separation multiplier: ${(stuckCount >= 3 ? (1.5 + stuckCount * 0.2) : 1.0).toFixed(1)})`);
                    
                    // Early exit only if we have zero collisions, don't give up easily
                    if (collisionsDetected.length === 0) {
                        break;
                    }
                }
                
                const endTime = performance.now();
                console.log(`Collision elimination completed: ${totalMoves} total moves in ${Math.round(endTime - startTime)}ms`);
                
                // Final verification pass
                let finalCollisions = 0;
                const finalCollisionPairs = [];
                const entityList = Array.from(eliminatedPositions.keys());
                for (let i = 0; i < entityList.length; i++) {
                    for (let j = i + 1; j < entityList.length; j++) {
                        const entity1 = entityList[i];
                        const entity2 = entityList[j];
                        const pos1 = eliminatedPositions.get(entity1);
                        const pos2 = eliminatedPositions.get(entity2);
                        const distance = Math.sqrt((pos1.x - pos2.x) ** 2 + (pos1.y - pos2.y) ** 2);
                        
                        if (distance < minDistance) {
                            finalCollisions++;
                            finalCollisionPairs.push(`${entity1}↔${entity2} (${Math.round(distance)}px)`);
                        }
                    }
                }
                
                if (finalCollisions === 0) {
                    console.log('✅ SUCCESS: All entity overlaps eliminated!');
                } else {
                    console.log(`⚠️ WARNING: ${finalCollisions} overlaps remain (< ${minDistance}px separation)`);
                    console.log('Remaining collision pairs:', finalCollisionPairs.slice(0, 5).join(', '));
                    if (finalCollisionPairs.length > 5) {
                        console.log(`... and ${finalCollisionPairs.length - 5} more`);
                    }
                }
                
                return eliminatedPositions;
            }
        }

        // Load entities from schema files with auto-discovery
        async function loadEntitiesFromSchema() {
            console.log('Starting schema-based entity loading...');
            
            // Load ERD configuration first
            const erdConfig = await loadERDConfig();
            globalErdConfig = erdConfig; // Store globally for use in connection points
            console.log('Loaded ERD configuration');
            
            const entities = [];
            const discoveredRelationships = [];
            
            // Add manual relationships from ERD config
            erdConfig.manual_relationships.forEach(rel => {
                discoveredRelationships.push({
                    from: rel.from,
                    to: rel.to,
                    label: rel.label,
                    type: rel.type,
                    fromCard: rel.from_cardinality,
                    toCard: rel.to_cardinality
                });
            });
            console.log(`Loaded ${erdConfig.manual_relationships.length} manual relationships from config`);
            
            // Try auto-discovery first
            const directories = await discoverSchemaDirectories();
            const discoveredEntities = new Set();
            
            if (!directories || directories.length === 0) {
                console.error('No schema directories found - cannot continue');
                throw new Error('Schema directories not found');
            }
            
            for (const directory of directories) {
                const entityName = directoryToEntityName(directory);
                const schema = await loadSchemaFile(entityName);
                
                if (schema) {
                    console.log(`Processing entity: ${entityName}`);
                    const metadata = extractMetadataFromSchema(entityName, schema, erdConfig);
                    
                    if (metadata) {
                        console.log(`✅ ${entityName} loaded successfully in area: ${metadata.area}`);
                        
                        const entity = convertSchemaToEntity(entityName, schema, metadata.area, metadata.description, metadata.position);
                        if (entity) {
                            entities.push(entity);
                            discoveredEntities.add(entityName);
                        }
                    } else {
                        console.error(`FAILED to process ${entityName} - check ERD configuration`);
                        throw new Error(`Entity ${entityName} not properly configured`);
                    }
                } else {
                    console.error(`FAILED to load schema for ${entityName} from directory ${directory}`);
                    throw new Error(`Schema not found for ${entityName}`);
                }
            }
            
            // Generate automatic relationships from FK fields using generic conventions
            const automaticRelationships = generateAutomaticFKRelationships(entities, discoveredRelationships);
            console.log(`Generated ${automaticRelationships.length} automatic FK relationships`);
            
            // Merge all relationships: manual + automatic FK
            const allDiscoveredRelationships = [...discoveredRelationships, ...automaticRelationships];
            relationships.push(...allDiscoveredRelationships);
            console.log(`Total relationships: ${relationships.length}`);
            
            // Apply dynamic layout calculation
            console.log('Applying dynamic network-based layout...');
            let dynamicPositions;
            try {
                // Configuration for weighted network layout
                const layoutConfig = {
                    networkWeights: {
                        degree: 0.6,        // Emphasize highly connected entities
                        betweenness: 0.3,   // Consider bottleneck entities  
                        closeness: 0.1,     // Minor consideration for central accessibility
                        normalize: true     // Enable normalization for fair comparison
                    },
                    forceWeights: {
                        repulsive: 0.4,     // Balanced entity separation (exponential scaling handles close distances)
                        attractive: 0.25,   // Moderate connection pull for relationships
                        categorical: 0.15,  // Reduced category grouping to prioritize connectivity
                        hub: 0.6,          // Very strong hub centralization for network structure
                        baseK: 150         // Base force constant
                    },
                    layoutPriorities: {
                        connectivity: 0.4,   // Primary focus on network structure
                        categorization: 0.3, // Secondary focus on functional groups
                        aesthetics: 0.3     // Tertiary focus on visual appeal
                    }
                };
                
                const layoutEngine = new DynamicLayoutEngine(entities, relationships, erdConfig, layoutConfig);
                console.log('Created DynamicLayoutEngine successfully');
                dynamicPositions = layoutEngine.calculateDynamicLayout();
                console.log('Dynamic layout calculation completed successfully');
            } catch (error) {
                console.error('Error in dynamic layout calculation:', error);
                // Fall back to original positioning logic if dynamic layout fails
                console.log('Falling back to original positioning logic');
                dynamicPositions = new Map();
                entities.forEach(entity => {
                    // Try to get position from ERD config, fallback to auto calculation
                    const configPos = erdConfig.entity_display[entity.name]?.position;
                    if (configPos) {
                        dynamicPositions.set(entity.name, {x: configPos.x, y: configPos.y});
                    } else {
                        // Simple fallback positioning
                        dynamicPositions.set(entity.name, {
                            x: 100 + Math.random() * 2800,
                            y: 100 + Math.random() * 1400
                        });
                    }
                });
            }
            
            // Update entity positions with dynamic layout results
            entities.forEach(entity => {
                const dynamicPos = dynamicPositions.get(entity.name);
                if (dynamicPos) {
                    entity.x = dynamicPos.x;
                    entity.y = dynamicPos.y;
                    console.log(`${entity.name}: positioned at (${Math.round(dynamicPos.x)}, ${Math.round(dynamicPos.y)})`);
                }
            });
            
            console.log(`Successfully loaded ${entities.length} entities with dynamic positioning`);
            return entities;
        }


        // D3 Setup with zoom and pan
        const svg = d3.select('#erd-svg');
        const tooltip = d3.select('#tooltip');
        const container = d3.select('#svg-container');
        
        // Add SVG definitions for icons
        const defs = svg.append('defs');
        
        // GitHub discussion icon definition (chat bubble with GitHub mark)
        defs.append('g')
            .attr('id', 'github-discussion-icon')
            .html(`
                <rect x="1" y="2" width="10" height="7" rx="1.5" ry="1.5" fill="currentColor" opacity="0.9"/>
                <path d="M3 11 L6 9 L9 11" fill="currentColor" opacity="0.9"/>
                <circle cx="4" cy="5.5" r="0.8" fill="white"/>
                <circle cx="8" cy="5.5" r="0.8" fill="white"/>
                <path d="M5.5 6.8 Q6 7.3 6.5 6.8" stroke="white" stroke-width="0.4" fill="none"/>
            `);
        
        // Create main group for zoom/pan transforms
        const g = svg.append('g').attr('class', 'main-group');
        
        // Zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 3])
            .on('zoom', handleZoom);
        
        // Apply zoom to SVG
        svg.call(zoom);
        
        // Track zoom level for indicator
        let currentZoom = 1;
        
        function handleZoom(event) {
            const { transform } = event;
            g.attr('transform', transform);
            currentZoom = transform.k;
            updateZoomIndicator();
            
            // Update cursor during pan
            if (event.sourceEvent && event.sourceEvent.type === 'mousemove') {
                container.classed('panning', true);
            } else {
                container.classed('panning', false);
            }
        }
        
        function updateZoomIndicator() {
            d3.select('#zoom-indicator').text(`${Math.round(currentZoom * 100)}%`);
        }

        // Zoom control functions
        function zoomIn() {
            svg.transition().duration(300).call(zoom.scaleBy, 1.5);
        }
        
        function zoomOut() {
            svg.transition().duration(300).call(zoom.scaleBy, 1 / 1.5);
        }
        
        function resetZoom() {
            svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity);
        }
        
        function fitToScreen() {
            // Debug: Log some entity positions
            console.log('Sample entity positions:');
            entities.slice(0, 5).forEach(e => {
                console.log(`${e.name}: (${e.x}, ${e.y})`);
            });
            
            // Calculate bounding box of all entities
            const bounds = {
                minX: Math.min(...entities.map(e => e.x)),
                maxX: Math.max(...entities.map(e => e.x + config.entityWidth)),
                minY: Math.min(...entities.map(e => e.y)),
                maxY: Math.max(...entities.map(e => e.y + config.headerHeight + (e.fields.length * config.entityFieldHeight) + (config.entityPadding * 2) + 4))
            };
            
            // Check actual browser viewport size FIRST
            const svgElement = document.getElementById('erd-svg');
            const svgContainer = svgElement.parentElement;
            const actualWidth = svgContainer.clientWidth;
            const actualHeight = svgContainer.clientHeight;
            
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;
            
            // Use actual browser viewport size instead of config size
            const calculatedScale = Math.min(actualWidth / width, actualHeight / height) * 0.85;
            const scale = Math.max(calculatedScale, 0.1); // Ensure minimum 0.1x zoom, no maximum cap
            
            console.log('Fit to screen - Bounds:', bounds);
            console.log('Fit to screen - Calculated scale:', calculatedScale, 'Final scale:', scale);
            
            // Use the actual bounds center to fit ALL entities
            const centerX = (bounds.minX + bounds.maxX) / 2;
            const centerY = (bounds.minY + bounds.maxY) / 2;
            
            console.log('Fit to screen - Content center:', centerX, centerY);
            
            console.log('Fit to screen - Canvas size:', config.width, 'x', config.height);
            console.log('Fit to screen - SVG element size:', actualWidth, 'x', actualHeight);
            console.log('Fit to screen - Browser window size:', window.innerWidth, 'x', window.innerHeight);
            console.log('Fit to screen - SVG container size:', svgElement.parentElement.clientWidth, 'x', svgElement.parentElement.clientHeight);
            console.log('Fit to screen - Content size:', width, 'x', height);
            
            const translateX = actualWidth / 2 - centerX * scale;
            const translateY = actualHeight / 2 - centerY * scale;
            
            console.log('Fit to screen - Translation:', translateX, translateY);
            
            // Calculate where the bounds will appear on screen
            const screenMinX = bounds.minX * scale + translateX;
            const screenMinY = bounds.minY * scale + translateY;
            const screenMaxX = bounds.maxX * scale + translateX;
            const screenMaxY = bounds.maxY * scale + translateY;
            
            console.log('Content will appear on screen from:', screenMinX, screenMinY, 'to', screenMaxX, screenMaxY);
            console.log('Screen viewport is 0,0 to', config.width, config.height);
            
            // Add visual indicators at the calculated bounds
            g.selectAll('.debug-bounds').remove();
            g.append('rect')
                .attr('class', 'debug-bounds')
                .attr('x', bounds.minX)
                .attr('y', bounds.minY)
                .attr('width', bounds.maxX - bounds.minX)
                .attr('height', bounds.maxY - bounds.minY)
                .attr('fill', 'none')
                .attr('stroke', 'red')
                .attr('stroke-width', 3)
                .attr('stroke-dasharray', '10,5');
                
            // Remove debug bounds after 3 seconds
            setTimeout(() => g.selectAll('.debug-bounds').remove(), 3000);
            
            svg.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity.translate(translateX, translateY).scale(scale)
            );
        }

        // Enhanced connection points that connect to specific fields
        function getConnectionPoint(entity, targetEntity, relationship, isFromEntity = true, erdConfig = null) {
            const entityHeight = config.headerHeight + (entity.fields.length * config.entityFieldHeight) + (config.entityPadding * 2) + 4;
            
            // Find the relevant field for this relationship
            let fieldIndex = -1;
            let targetFieldName = null;
            
            if (isFromEntity) {
                // Look for FK field that references the target entity
                const targetEntityName = targetEntity.id;
                
                // Use configuration-based field mapping if available
                if (erdConfig && erdConfig.field_mappings && erdConfig.field_mappings[targetEntityName]) {
                    const possibleFieldNames = erdConfig.field_mappings[targetEntityName];
                    fieldIndex = entity.fields.findIndex(field => 
                        field.isFK && possibleFieldNames.includes(field.name)
                    );
                }
                
                // Fallback to generic pattern matching if no configuration mapping found
                if (fieldIndex === -1) {
                    fieldIndex = entity.fields.findIndex(field => 
                        field.isFK && (
                            field.name === targetEntityName + 'Id' ||
                            field.name === targetEntityName.toLowerCase() + 'Id' ||
                            field.name.toLowerCase().includes(targetEntityName.replace('Data', '').toLowerCase())
                        )
                    );
                }
                
                // Debug logging for unmatched relationships
                if (fieldIndex === -1) {
                    console.warn(`⚠️ Could not find FK field in ${entity.id} for relationship to ${targetEntityName}. Available FK fields:`, 
                        entity.fields.filter(f => f.isFK).map(f => f.name));
                }
            } else {
                // For target entity, use primary key
                fieldIndex = entity.fields.findIndex(field => field.isPK);
            }
            
            // Fallback to appropriate edge if no specific field found
            if (fieldIndex === -1) {
                return getEntityEdgePoint(entity, targetEntity);
            }
            
            // Calculate field position
            const fieldY = entity.y + config.headerHeight + config.entityPadding + (fieldIndex * config.entityFieldHeight) + 6;
            
            // Determine which side of the entity to connect to
            const entityCenter = {
                x: entity.x + (entity.actualWidth || config.entityWidth) / 2,
                y: entity.y + entityHeight / 2
            };
            
            const targetCenter = {
                x: targetEntity.x + (targetEntity.actualWidth || config.entityWidth) / 2,
                y: targetEntity.y + (config.headerHeight + (targetEntity.fields.length * config.entityFieldHeight) + (config.entityPadding * 2) + 4) / 2
            };
            
            let connectionX;
            if (targetCenter.x > entityCenter.x) {
                // Target is to the right, connect from right edge
                connectionX = entity.x + (entity.actualWidth || config.entityWidth);
            } else {
                // Target is to the left, connect from left edge
                connectionX = entity.x;
            }
            
            return {
                x: connectionX,
                y: fieldY,
                fieldIndex: fieldIndex,
                fieldName: entity.fields[fieldIndex]?.name
            };
        }
        
        function getEntityEdgePoint(entity, targetEntity) {
            const entityHeight = config.headerHeight + (entity.fields.length * config.entityFieldHeight) + (config.entityPadding * 2) + 4;
            const targetHeight = config.headerHeight + (targetEntity.fields.length * config.entityFieldHeight) + (config.entityPadding * 2) + 4;
            
            const entityCenter = {
                x: entity.x + (entity.actualWidth || config.entityWidth) / 2,
                y: entity.y + entityHeight / 2
            };
            
            const targetCenter = {
                x: targetEntity.x + (targetEntity.actualWidth || config.entityWidth) / 2,
                y: targetEntity.y + targetHeight / 2
            };
            
            const dx = targetCenter.x - entityCenter.x;
            const dy = targetCenter.y - entityCenter.y;
            
            // Determine which edge to connect to
            if (Math.abs(dx) > Math.abs(dy)) {
                // Horizontal connection
                if (dx > 0) {
                    return { x: entity.x + (entity.actualWidth || config.entityWidth), y: entityCenter.y };
                } else {
                    return { x: entity.x, y: entityCenter.y };
                }
            } else {
                // Vertical connection
                if (dy > 0) {
                    return { x: entityCenter.x, y: entity.y + entityHeight };
                } else {
                    return { x: entityCenter.x, y: entity.y };
                }
            }
        }

        // Check if a point is inside an entity's bounding box
        function isPointInsideEntity(point, entity) {
            const entityHeight = config.headerHeight + (entity.fields.length * config.entityFieldHeight) + (config.entityPadding * 2) + 4;
            return point.x >= entity.x - 10 && 
                   point.x <= entity.x + (entity.actualWidth || config.entityWidth) + 10 && 
                   point.y >= entity.y - 10 && 
                   point.y <= entity.y + entityHeight + 10;
        }

        // Check if a line segment intersects with an entity
        function lineIntersectsEntity(p1, p2, entity, excludeEntities = []) {
            if (excludeEntities.includes(entity.id)) return false;
            
            const entityHeight = config.headerHeight + (entity.fields.length * config.entityFieldHeight) + (config.entityPadding * 2) + 4;
            const buffer = 15; // Add buffer around entities
            
            const entityBounds = {
                left: entity.x - buffer,
                right: entity.x + (entity.actualWidth || config.entityWidth) + buffer,
                top: entity.y - buffer,
                bottom: entity.y + entityHeight + buffer
            };
            
            // Check if line segment intersects the entity rectangle
            return lineSegmentIntersectsRect(p1, p2, entityBounds);
        }

        // Find the best position for a relationship label to avoid entity overlaps
        function findBestLabelPosition(path, label, fromEntity, toEntity) {
            const pathLength = path.node().getTotalLength();
            const excludeEntities = [fromEntity.id, toEntity.id];
            const textWidth = label.length * 4.5;
            const textHeight = 14;
            
            // Try multiple positions along the path
            const positions = [0.5, 0.4, 0.6, 0.3, 0.7, 0.25, 0.75];
            
            for (const pos of positions) {
                const testPoint = path.node().getPointAtLength(pathLength * pos);
                
                // Check if this position would overlap with any entity
                const labelBounds = {
                    left: testPoint.x - textWidth/2 - 3,
                    right: testPoint.x + textWidth/2 + 3,
                    top: testPoint.y - 7,
                    bottom: testPoint.y + 7
                };
                
                let hasOverlap = false;
                for (const entity of entities) {
                    if (excludeEntities.includes(entity.id)) continue;
                    
                    const entityHeight = config.headerHeight + (entity.fields.length * config.entityFieldHeight) + (config.entityPadding * 2) + 4;
                    const entityBounds = {
                        left: entity.x - 10,
                        right: entity.x + (entity.actualWidth || config.entityWidth) + 10,
                        top: entity.y - 10,
                        bottom: entity.y + entityHeight + 10
                    };
                    
                    if (rectanglesOverlap(labelBounds, entityBounds)) {
                        hasOverlap = true;
                        break;
                    }
                }
                
                if (!hasOverlap) {
                    return testPoint;
                }
            }
            
            // If no good position found, return the midpoint
            return path.node().getPointAtLength(pathLength / 2);
        }
        
        // Check if two rectangles overlap
        function rectanglesOverlap(rect1, rect2) {
            return !(rect1.right < rect2.left || 
                     rect2.right < rect1.left || 
                     rect1.bottom < rect2.top || 
                     rect2.bottom < rect1.top);
        }
        
        // Determine if a label should be displayed to reduce clutter
        function shouldDisplayLabel(labelPoint, rel, fromEntity, toEntity) {
            // TraceableUnit has massive clutter - be very aggressive about hiding labels
            const isTraceableUnitRelationship = fromEntity.id === 'TraceableUnit' || toEntity.id === 'TraceableUnit';
            
            if (isTraceableUnitRelationship) {
                // Only show the most critical TraceableUnit relationships
                const criticalTruLabels = ['material_type_reference', 'includes_tru', 'originates_tru'];
                if (!criticalTruLabels.includes(rel.label)) {
                    return false; // Hide all other TraceableUnit relationship labels
                }
            }
            
            // Other central entities - be selective  
            const centralEntities = ['Material', 'Organization', 'Transaction'];
            const isCentralRelationship = centralEntities.includes(fromEntity.id) || centralEntities.includes(toEntity.id);
            
            // Always show labels for important non-TRU relationships
            const importantLabels = ['manages_supply_base', 'sources_from', 'sells_to'];
            if (importantLabels.includes(rel.label)) {
                return true;
            }
            
            // In central areas, be very selective
            if (isCentralRelationship) {
                return rel.label.length <= 12 || labelPoint.y < 150 || labelPoint.y > 900;
            }
            
            return true;
        }
        
        // Generate control points for central area routes with wider avoidance
        function generateCentralAvoidanceRoute(fromPoint, toPoint, fromEntity, toEntity, excludeEntities) {
            const dx = toPoint.x - fromPoint.x;
            const dy = toPoint.y - fromPoint.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // TraceableUnit needs MASSIVE avoidance zones
            const isTraceableUnitRoute = fromEntity.id === 'TraceableUnit' || toEntity.id === 'TraceableUnit';
            
            // Use much larger offsets for TraceableUnit routes
            let offset;
            if (isTraceableUnitRoute) {
                offset = Math.min(distance * 0.7, 250); // Much larger offset for TRU
            } else {
                offset = Math.min(distance * 0.4, 150); // Normal offset for others
            }
            
            // Get TraceableUnit position for exclusion zone
            const truEntity = entities.find(e => e.id === 'TraceableUnit');
            const truCenterX = truEntity ? truEntity.x + 150 : 600;
            const truCenterY = truEntity ? truEntity.y + 100 : 400;
            
            // Create large exclusion zone around TraceableUnit
            const exclusionRadius = isTraceableUnitRoute ? 200 : 100;
            
            let control1, control2;
            
            if (isTraceableUnitRoute) {
                // For TraceableUnit routes, use extreme avoidance
                const angle = Math.atan2(dy, dx);
                const perpAngle = angle + Math.PI / 2;
                
                // Route far around TraceableUnit
                const avoidanceDistance = 300;
                const xAvoid = Math.cos(perpAngle) * avoidanceDistance;
                const yAvoid = Math.sin(perpAngle) * avoidanceDistance;
                
                control1 = {
                    x: fromPoint.x + dx * 0.2 + xAvoid,
                    y: fromPoint.y + dy * 0.2 + yAvoid
                };
                control2 = {
                    x: toPoint.x - dx * 0.2 + xAvoid,
                    y: toPoint.y - dy * 0.2 + yAvoid
                };
            } else {
                // Standard avoidance for non-TRU routes
                if (Math.abs(dx) > Math.abs(dy)) {
                    // Horizontal dominant - route above or below
                    const routeAbove = fromPoint.y < truCenterY || toPoint.y < truCenterY;
                    const yOffset = routeAbove ? -offset : offset;
                    
                    control1 = { 
                        x: fromPoint.x + dx * 0.3, 
                        y: fromPoint.y + yOffset 
                    };
                    control2 = { 
                        x: toPoint.x - dx * 0.3, 
                        y: toPoint.y + yOffset 
                    };
                } else {
                    // Vertical dominant - route left or right
                    const routeLeft = fromPoint.x < truCenterX || toPoint.x < truCenterX;
                    const xOffset = routeLeft ? -offset : offset;
                    
                    control1 = { 
                        x: fromPoint.x + xOffset, 
                        y: fromPoint.y + dy * 0.3 
                    };
                    control2 = { 
                        x: toPoint.x + xOffset, 
                        y: toPoint.y - dy * 0.3 
                    };
                }
            }
            
            return [fromPoint, control1, control2, toPoint];
        }
        
        // Enhanced simple control points with central awareness
        function generateSimpleControlPoints(fromPoint, toPoint, isCentralRoute = false) {
            const dx = toPoint.x - fromPoint.x;
            const dy = toPoint.y - fromPoint.y;
            
            // Use smaller curves for non-central routes, larger for central
            const curveIntensity = isCentralRoute ? 0.4 : 0.3;
            
            return [
                fromPoint,
                { 
                    x: fromPoint.x + dx * curveIntensity, 
                    y: fromPoint.y + dy * curveIntensity 
                },
                { 
                    x: toPoint.x - dx * curveIntensity, 
                    y: toPoint.y - dy * curveIntensity 
                },
                toPoint
            ];
        }

        function lineSegmentIntersectsRect(p1, p2, rect) {
            // Check if either endpoint is inside the rectangle
            if ((p1.x >= rect.left && p1.x <= rect.right && p1.y >= rect.top && p1.y <= rect.bottom) ||
                (p2.x >= rect.left && p2.x <= rect.right && p2.y >= rect.top && p2.y <= rect.bottom)) {
                return true;
            }
            
            // Check intersection with each edge of the rectangle
            const edges = [
                { p1: { x: rect.left, y: rect.top }, p2: { x: rect.right, y: rect.top } },     // top
                { p1: { x: rect.right, y: rect.top }, p2: { x: rect.right, y: rect.bottom } }, // right
                { p1: { x: rect.right, y: rect.bottom }, p2: { x: rect.left, y: rect.bottom } }, // bottom
                { p1: { x: rect.left, y: rect.bottom }, p2: { x: rect.left, y: rect.top } }     // left
            ];
            
            return edges.some(edge => lineSegmentsIntersect(p1, p2, edge.p1, edge.p2));
        }

        function lineSegmentsIntersect(p1, q1, p2, q2) {
            function onSegment(p, q, r) {
                return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) &&
                       q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
            }
            
            function orientation(p, q, r) {
                const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
                if (val === 0) return 0;
                return (val > 0) ? 1 : 2;
            }
            
            const o1 = orientation(p1, q1, p2);
            const o2 = orientation(p1, q1, q2);
            const o3 = orientation(p2, q2, p1);
            const o4 = orientation(p2, q2, q1);
            
            if (o1 !== o2 && o3 !== o4) return true;
            if (o1 === 0 && onSegment(p1, p2, q1)) return true;
            if (o2 === 0 && onSegment(p1, q2, q1)) return true;
            if (o3 === 0 && onSegment(p2, p1, q2)) return true;
            if (o4 === 0 && onSegment(p2, q1, q2)) return true;
            
            return false;
        }

        // Find a route around entities with enhanced avoidance and central area awareness
        function findRouteAroundEntities(fromPoint, toPoint, fromEntity, toEntity, relationship) {
            const excludeEntities = [fromEntity.id, toEntity.id];
            const centralEntities = ['TraceableUnit', 'Material', 'Organization', 'Transaction'];
            const isCentralRoute = centralEntities.includes(fromEntity.id) || centralEntities.includes(toEntity.id);
            
            // Check for direct path first
            const directObstructions = entities.filter(entity => 
                !excludeEntities.includes(entity.id) && 
                lineIntersectsEntity(fromPoint, toPoint, entity, excludeEntities)
            );
            
            if (directObstructions.length === 0) {
                return generateSimpleControlPoints(fromPoint, toPoint, isCentralRoute);
            }
            
            // For central routes, use wider avoidance paths
            if (isCentralRoute) {
                return generateCentralAvoidanceRoute(fromPoint, toPoint, fromEntity, toEntity, excludeEntities);
            }
            
            // Enhanced routing with multiple waypoints for complex scenarios
            const routes = [];
            
            // Strategy 1: High arc over obstructions
            const highRoute = createHighArcRoute(fromPoint, toPoint, directObstructions, excludeEntities);
            if (highRoute) routes.push(highRoute);
            
            // Strategy 2: Low arc under obstructions
            const lowRoute = createLowArcRoute(fromPoint, toPoint, directObstructions, excludeEntities);
            if (lowRoute) routes.push(lowRoute);
            
            // Strategy 3: Left detour
            const leftRoute = createLeftDetourRoute(fromPoint, toPoint, directObstructions, excludeEntities);
            if (leftRoute) routes.push(leftRoute);
            
            // Strategy 4: Right detour
            const rightRoute = createRightDetourRoute(fromPoint, toPoint, directObstructions, excludeEntities);
            if (rightRoute) routes.push(rightRoute);
            
            // Strategy 5: Complex multi-waypoint routing
            const complexRoute = createComplexRoute(fromPoint, toPoint, directObstructions, excludeEntities);
            if (complexRoute) routes.push(complexRoute);
            
            if (routes.length === 0) {
                console.log(`No clear route found for ${fromEntity.id} -> ${toEntity.id}, using direct path`);
                return generateSimpleControlPoints(fromPoint, toPoint);
            }
            
            // Choose the route with minimum total path length
            const bestRoute = routes.reduce((best, current) => {
                const bestLength = calculateRouteLength(best);
                const currentLength = calculateRouteLength(current);
                return currentLength < bestLength ? current : best;
            });
            
            console.log(`Found route for ${fromEntity.id} -> ${toEntity.id} with ${bestRoute.length} waypoints`);
            return bestRoute;
        }
        
        function createHighArcRoute(fromPoint, toPoint, obstructions, excludeEntities) {
            const minY = Math.min(...obstructions.map(e => e.y)) - 50; // Higher clearance
            const midX = (fromPoint.x + toPoint.x) / 2;
            
            // Create smooth arc with multiple control points
            const route = [
                fromPoint,
                { x: fromPoint.x + (midX - fromPoint.x) * 0.3, y: fromPoint.y - 20 },
                { x: midX, y: minY },
                { x: toPoint.x - (toPoint.x - midX) * 0.3, y: toPoint.y - 20 },
                toPoint
            ];
            
            return isRouteValid(route, excludeEntities) ? route : null;
        }
        
        function createLowArcRoute(fromPoint, toPoint, obstructions, excludeEntities) {
            const maxY = Math.max(...obstructions.map(e => {
                const entityHeight = config.headerHeight + (e.fields.length * config.entityFieldHeight) + (config.entityPadding * 2) + 4;
                return e.y + entityHeight;
            })) + 50; // Lower clearance
            const midX = (fromPoint.x + toPoint.x) / 2;
            
            const route = [
                fromPoint,
                { x: fromPoint.x + (midX - fromPoint.x) * 0.3, y: fromPoint.y + 20 },
                { x: midX, y: maxY },
                { x: toPoint.x - (toPoint.x - midX) * 0.3, y: toPoint.y + 20 },
                toPoint
            ];
            
            return isRouteValid(route, excludeEntities) ? route : null;
        }
        
        function createLeftDetourRoute(fromPoint, toPoint, obstructions, excludeEntities) {
            const minX = Math.min(...obstructions.map(e => e.x)) - 50;
            const midY = (fromPoint.y + toPoint.y) / 2;
            
            const route = [
                fromPoint,
                { x: minX, y: fromPoint.y },
                { x: minX, y: midY },
                { x: minX, y: toPoint.y },
                toPoint
            ];
            
            return isRouteValid(route, excludeEntities) ? route : null;
        }
        
        function createRightDetourRoute(fromPoint, toPoint, obstructions, excludeEntities) {
            const maxX = Math.max(...obstructions.map(e => e.x + config.entityWidth)) + 50;
            const midY = (fromPoint.y + toPoint.y) / 2;
            
            const route = [
                fromPoint,
                { x: maxX, y: fromPoint.y },
                { x: maxX, y: midY },
                { x: maxX, y: toPoint.y },
                toPoint
            ];
            
            return isRouteValid(route, excludeEntities) ? route : null;
        }
        
        function createComplexRoute(fromPoint, toPoint, obstructions, excludeEntities) {
            // For very complex scenarios, create a route that goes around the cluster
            const bounds = {
                minX: Math.min(...obstructions.map(e => e.x)) - 60,
                maxX: Math.max(...obstructions.map(e => e.x + config.entityWidth)) + 60,
                minY: Math.min(...obstructions.map(e => e.y)) - 60,
                maxY: Math.max(...obstructions.map(e => {
                    const entityHeight = config.headerHeight + (e.fields.length * config.entityFieldHeight) + (config.entityPadding * 2) + 4;
                    return e.y + entityHeight;
                })) + 60
            };
            
            // Choose best corner route based on from/to positions
            const routes = [];
            
            // Top-left corner route
            routes.push([
                fromPoint,
                { x: bounds.minX, y: fromPoint.y },
                { x: bounds.minX, y: bounds.minY },
                { x: toPoint.x, y: bounds.minY },
                toPoint
            ]);
            
            // Bottom-right corner route
            routes.push([
                fromPoint,
                { x: bounds.maxX, y: fromPoint.y },
                { x: bounds.maxX, y: bounds.maxY },
                { x: toPoint.x, y: bounds.maxY },
                toPoint
            ]);
            
            const validRoutes = routes.filter(route => isRouteValid(route, excludeEntities));
            if (validRoutes.length === 0) return null;
            
            return validRoutes.reduce((best, current) => {
                return calculateRouteLength(current) < calculateRouteLength(best) ? current : best;
            });
        }
        
        function isRouteValid(route, excludeEntities) {
            for (let i = 0; i < route.length - 1; i++) {
                const segmentObstructed = entities.some(entity => 
                    !excludeEntities.includes(entity.id) && 
                    lineIntersectsEntity(route[i], route[i + 1], entity, excludeEntities)
                );
                if (segmentObstructed) return false;
            }
            return true;
        }


        function calculateRouteLength(route) {
            let length = 0;
            for (let i = 0; i < route.length - 1; i++) {
                const dx = route[i + 1].x - route[i].x;
                const dy = route[i + 1].y - route[i].y;
                length += Math.sqrt(dx * dx + dy * dy);
            }
            return length;
        }

        function generateSimpleControlPoints(fromPoint, toPoint) {
            const dx = toPoint.x - fromPoint.x;
            const dy = toPoint.y - fromPoint.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Use smaller control distance for cleaner curves
            const controlDistance = Math.min(distance * 0.2, 80);
            
            let cp1, cp2;
            
            // Create gentle S-curves that are less likely to intersect entities
            if (Math.abs(dx) > Math.abs(dy)) {
                // Horizontal dominant
                cp1 = {
                    x: fromPoint.x + Math.sign(dx) * controlDistance,
                    y: fromPoint.y + Math.sign(dy) * 10
                };
                cp2 = {
                    x: toPoint.x - Math.sign(dx) * controlDistance,
                    y: toPoint.y - Math.sign(dy) * 10
                };
            } else {
                // Vertical dominant
                cp1 = {
                    x: fromPoint.x + Math.sign(dx) * 10,
                    y: fromPoint.y + Math.sign(dy) * controlDistance
                };
                cp2 = {
                    x: toPoint.x - Math.sign(dx) * 10,
                    y: toPoint.y - Math.sign(dy) * controlDistance
                };
            }
            
            return [fromPoint, cp1, cp2, toPoint];
        }

        function generateControlPoints(fromPoint, toPoint, relationship, fromEntity, toEntity) {
            return findRouteAroundEntities(fromPoint, toPoint, fromEntity, toEntity, relationship);
        }

        // Draw entity function
        function drawEntity(entity) {
            const color = config.colors[entity.area] || { fill: '#f3f4f6', stroke: '#9ca3af', header: '#6b7280' };
            const visibleFields = entity.fields; // Show all fields comprehensively
            
            // Calculate dynamic entity width based on text content
            let maxTextWidth = 0;
            
            // Create temporary group to measure text
            const tempGroup = g.append('g').style('opacity', 0);
            
            // Measure entity name width (accounting for icon space)
            const entityNameText = tempGroup.append('text')
                .attr('class', 'entity-header')
                .text(entity.name);
            maxTextWidth = Math.max(maxTextWidth, entityNameText.node().getComputedTextLength() + 30); // Add space for larger icon
            
            // Measure all field text widths
            visibleFields.forEach((field, i) => {
                const prefix = field.isPK ? 'PK ' : field.isFK ? 'FK ' : field.required ? '• ' : '  ';
                let fullText = `${prefix}${field.name}: ${field.type}`;
                
                const tempText = tempGroup.append('text')
                    .attr('class', 'entity-field')
                    .text(fullText);
                
                const textWidth = tempText.node().getComputedTextLength();
                maxTextWidth = Math.max(maxTextWidth, textWidth);
            });
            
            tempGroup.remove(); // Remove temporary group
            
            // Calculate entity width with padding (minimum 180px, or text width + padding)
            const entityWidth = Math.max(config.entityWidth, maxTextWidth + 16); // 8px padding on each side
            const entityHeight = config.headerHeight + (visibleFields.length * config.entityFieldHeight) + (config.entityPadding * 2) + 4;
            
            // Store dynamic width on entity for other functions to use
            entity.actualWidth = entityWidth;
            
            const entityGroup = g.append('g')
                .attr('class', 'entity')
                .attr('data-area', entity.area)
                .attr('data-id', entity.id)
                .attr('transform', `translate(${entity.x}, ${entity.y})`);

            // Entity background
            entityGroup.append('rect')
                .attr('width', entityWidth)
                .attr('height', entityHeight)
                .attr('fill', color.fill)
                .attr('stroke', color.stroke)
                .attr('stroke-width', 1)
                .attr('rx', 6);

            // Header
            entityGroup.append('rect')
                .attr('width', entityWidth)
                .attr('height', config.headerHeight)
                .attr('fill', color.header)
                .attr('rx', 6);
                
            entityGroup.append('rect')
                .attr('y', config.headerHeight - 6)
                .attr('width', entityWidth)
                .attr('height', 6)
                .attr('fill', color.header);

            // Entity name
            entityGroup.append('text')
                .attr('class', 'entity-header')
                .attr('x', (entityWidth - 26) / 2) // Shift left to account for larger icon
                .attr('y', config.headerHeight / 2 + 3)
                .attr('text-anchor', 'middle')
                .attr('fill', 'white')
                .text(entity.name);
            
            // GitHub discussion icon
            const discussionIcon = entityGroup.append('use')
                .attr('class', 'discussion-icon')
                .attr('href', '#github-discussion-icon')
                .attr('x', entityWidth - 22)
                .attr('y', config.headerHeight / 2 - 8)
                .attr('width', 16)
                .attr('height', 16)
                .style('cursor', 'pointer');
            
            // Add tooltip for discussion icon
            discussionIcon.append('title')
                .text(`Discuss ${entity.name} schema on GitHub`);
            
            // Discussion icon click handler
            discussionIcon.on('click', function(event) {
                event.stopPropagation(); // Prevent entity click
                
                // Entity to discussion URL mapping
                const discussionUrls = {
                    'TraceableUnit': 'https://github.com/carbondirect/BOOST/discussions/166',
                    'GeographicData': 'https://github.com/carbondirect/BOOST/discussions/167',
                    'TrackingPoint': 'https://github.com/carbondirect/BOOST/discussions/168',
                    'MeasurementRecord': 'https://github.com/carbondirect/BOOST/discussions/169',
                    'LocationHistory': 'https://github.com/carbondirect/BOOST/discussions/170',
                    'DataReconciliation': 'https://github.com/carbondirect/BOOST/discussions/171',
                    'SpeciesComponent': 'https://github.com/carbondirect/BOOST/discussions/172',
                    'MaterialProcessing': 'https://github.com/carbondirect/BOOST/discussions/173',
                    'ProcessingHistory': 'https://github.com/carbondirect/BOOST/discussions/174',
                    'MoistureContent': 'https://github.com/carbondirect/BOOST/discussions/175',
                    'Transaction': 'https://github.com/carbondirect/BOOST/discussions/176',
                    'Operator': 'https://github.com/carbondirect/BOOST/discussions/177',
                    'SupplyBase': 'https://github.com/carbondirect/BOOST/discussions/178',
                    'BiometricIdentifier': 'https://github.com/carbondirect/BOOST/discussions/179',
                    // Existing discussions for other entities
                    'SupplyBaseReport': 'https://github.com/carbondirect/BOOST/discussions/106',
                    'ProductGroup': 'https://github.com/carbondirect/BOOST/discussions/105',
                    'Material': 'https://github.com/carbondirect/BOOST/discussions/94',
                    'Organization': 'https://github.com/carbondirect/BOOST/discussions/90',
                    'Customer': 'https://github.com/carbondirect/BOOST/discussions/96',
                    'Supplier': 'https://github.com/carbondirect/BOOST/discussions/95',
                    'EnergyCarbonData': 'https://github.com/carbondirect/BOOST/discussions/101',
                    'TransactionBatch': 'https://github.com/carbondirect/BOOST/discussions/98',
                    'SalesDeliveryDocument': 'https://github.com/carbondirect/BOOST/discussions/100',
                    'CertificationScheme': 'https://github.com/carbondirect/BOOST/discussions/91',
                    'Certificate': 'https://github.com/carbondirect/BOOST/discussions/92',
                    'CertificationBody': 'https://github.com/carbondirect/BOOST/discussions/93',
                    'Audit': 'https://github.com/carbondirect/BOOST/discussions/107',
                    'VerificationStatement': 'https://github.com/carbondirect/BOOST/discussions/103',
                    'MassBalanceAccount': 'https://github.com/carbondirect/BOOST/discussions/104',
                    'Claim': 'https://github.com/carbondirect/BOOST/discussions/99',
                    'DTSTransaction': 'https://github.com/carbondirect/BOOST/discussions/97'
                };
                
                const discussionUrl = discussionUrls[entity.name] || 'https://github.com/carbondirect/BOOST/discussions';
                window.open(discussionUrl, '_blank');
            });

            // Fields - simple single line text
            visibleFields.forEach((field, i) => {
                const fieldY = config.headerHeight + config.entityPadding + (i * config.entityFieldHeight) + 8;
                let fieldClass = 'entity-field';
                
                if (field.isPK) fieldClass = 'entity-pk';
                else if (field.isFK) fieldClass = 'entity-fk';
                else if (field.required) fieldClass = 'entity-required';
                
                const prefix = field.isPK ? 'PK ' : field.isFK ? 'FK ' : field.required ? '• ' : '  ';
                
                entityGroup.append('text')
                    .attr('class', fieldClass)
                    .attr('x', 4)
                    .attr('y', fieldY)
                    .text(`${prefix}${field.name}: ${field.type}`);
            });


            // Events
            entityGroup.on('mouseover', function(event) {
                const fieldsList = entity.fields
                    .map(f => `<code>${f.name}</code>: ${f.type}${f.required ? ' *' : ''}${f.isPK ? ' (PK)' : ''}${f.isFK ? ' (FK)' : ''}`)
                    .join('<br/>');
                
                tooltip.style('opacity', 1)
                    .html(`<strong>${entity.name}</strong><br/><em>${entity.area.replace('_', ' ')}</em><br/><br/>${entity.description}<br/><br/>${fieldsList}`)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
            })
            .on('mouseout', () => tooltip.style('opacity', 0))
            .on('click', () => highlightRelationships(entity.id));

            return entityGroup;
        }

        // Draw curved relationships
        function drawRelationships() {
            g.selectAll('.relationship-group').remove();
            
            relationships.forEach((rel, index) => {
                const fromEntity = entities.find(e => e.id === rel.from);
                const toEntity = entities.find(e => e.id === rel.to);
                
                if (fromEntity && toEntity) {
                    drawCurvedRelationship(fromEntity, toEntity, rel);
                }
            });
        }

        function drawCurvedRelationship(fromEntity, toEntity, rel) {
            const fromPoint = getConnectionPoint(fromEntity, toEntity, rel, true, globalErdConfig);
            const toPoint = getConnectionPoint(toEntity, fromEntity, rel, false, globalErdConfig);
            const controlPoints = generateControlPoints(fromPoint, toPoint, rel, fromEntity, toEntity);
            
            const relationshipGroup = g.append('g')
                .attr('class', 'relationship-group')
                .attr('data-from', rel.from)
                .attr('data-to', rel.to);

            // Create curved path
            const line = d3.line()
                .x(d => d.x)
                .y(d => d.y)
                .curve(d3[config.curveType]);

            const path = relationshipGroup.append('path')
                .attr('class', `relationship relationship-${rel.type}`)
                .attr('d', line(controlPoints));

            // Enhanced Crow's foot notation with proper angles
            const lastPoint = controlPoints[controlPoints.length - 1];
            const secondLastPoint = controlPoints[controlPoints.length - 2];
            const endAngle = Math.atan2(lastPoint.y - secondLastPoint.y, lastPoint.x - secondLastPoint.x);
            
            // Draw notation at the "to" end (many side)
            if (rel.toCard === 'many') {
                drawCrowsFoot(relationshipGroup, toPoint.x, toPoint.y, endAngle);
            } else {
                drawSingleMark(relationshipGroup, toPoint.x, toPoint.y, endAngle);
            }
            
            // Draw notation at the "from" end (one side)
            const firstPoint = controlPoints[0];
            const secondPoint = controlPoints[1];
            const startAngle = Math.atan2(secondPoint.y - firstPoint.y, secondPoint.x - firstPoint.x);
            
            if (rel.fromCard === 'many') {
                drawCrowsFoot(relationshipGroup, fromPoint.x, fromPoint.y, startAngle + Math.PI);
            } else {
                drawSingleMark(relationshipGroup, fromPoint.x, fromPoint.y, startAngle + Math.PI);
            }

            // Add field connection indicators
            if (fromPoint.fieldName) {
                relationshipGroup.append('circle')
                    .attr('cx', fromPoint.x)
                    .attr('cy', fromPoint.y)
                    .attr('r', 2)
                    .attr('fill', '#2563eb')
                    .attr('stroke', 'white')
                    .attr('stroke-width', 1);
            }
            
            if (toPoint.fieldName) {
                relationshipGroup.append('circle')
                    .attr('cx', toPoint.x)
                    .attr('cy', toPoint.y)
                    .attr('r', 2)
                    .attr('fill', '#dc2626')
                    .attr('stroke', 'white')
                    .attr('stroke-width', 1);
            }

            // Smart label positioning to avoid entity overlaps
            const pathLength = path.node().getTotalLength();
            let labelPoint = path.node().getPointAtLength(pathLength / 2);
            
            // Check if label would overlap with any entity and adjust position
            labelPoint = findBestLabelPosition(path, rel.label, fromEntity, toEntity);
            
            const textWidth = rel.label.length * 4.5;
            
            // Only show label if it doesn't cause clutter in central areas
            const shouldShowLabel = shouldDisplayLabel(labelPoint, rel, fromEntity, toEntity);
            
            if (shouldShowLabel) {
                relationshipGroup.append('rect')
                    .attr('class', 'label-background')
                    .attr('x', labelPoint.x - textWidth/2 - 3)
                    .attr('y', labelPoint.y - 7)
                    .attr('width', textWidth + 6)
                    .attr('height', 14)
                    .attr('rx', 3);
                    
                relationshipGroup.append('text')
                    .attr('class', 'relationship-label')
                    .attr('x', labelPoint.x)
                    .attr('y', labelPoint.y + 3)
                    .text(rel.label);
            }
                
            // Add tooltip functionality to the entire relationship group
            relationshipGroup
                .on('mouseover', function(event) {
                    const relationshipDescription = generateRelationshipDescription(rel, fromEntity, toEntity, fromPoint, toPoint);
                    
                    tooltip.style('opacity', 1)
                        .html(relationshipDescription)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                        
                    // Highlight the relationship
                    d3.select(this).selectAll('.relationship')
                        .style('stroke-width', '3px')
                        .style('filter', 'drop-shadow(0 2px 6px rgba(0,0,0,0.3))');
                })
                .on('mouseout', function() {
                    tooltip.style('opacity', 0);
                    
                    // Reset relationship styling
                    d3.select(this).selectAll('.relationship-identifying')
                        .style('stroke-width', '1.5px')
                        .style('filter', 'none');
                    d3.select(this).selectAll('.relationship-non-identifying')
                        .style('stroke-width', '1.2px')
                        .style('filter', 'none');
                })
                .on('click', function(event) {
                    event.stopPropagation();
                    highlightRelationshipEntities(fromEntity.id, toEntity.id);
                    showRelationshipFocusMessage(rel, fromEntity, toEntity);
                })
                .style('cursor', 'pointer');
        }
        
        function generateRelationshipDescription(rel, fromEntity, toEntity, fromPoint, toPoint) {
            const cardinalityText = getCardinalityText(rel.fromCard, rel.toCard);
            const relationshipTypeText = rel.type === 'identifying' ? 'Identifying' : 'Non-identifying';
            
            let description = `<div style="max-width: 350px;">`;
            description += `<strong>${rel.label}</strong><br/>`;
            description += `<em>${relationshipTypeText} Relationship</em><br/><br/>`;
            
            description += `<strong>From:</strong> ${fromEntity.name}<br/>`;
            if (fromPoint.fieldName) {
                description += `<strong>Field:</strong> <code>${fromPoint.fieldName}</code><br/>`;
            }
            
            description += `<strong>To:</strong> ${toEntity.name}<br/>`;
            if (toPoint.fieldName) {
                description += `<strong>Field:</strong> <code>${toPoint.fieldName}</code><br/>`;
            }
            
            description += `<br/><strong>Cardinality:</strong> ${cardinalityText}<br/>`;
            
            // Add business context based on relationship
            const businessContext = getBusinessContext(rel, fromEntity, toEntity);
            if (businessContext) {
                description += `<br/><strong>Business Rule:</strong><br/>${businessContext}`;
            }
            
            description += `</div>`;
            return description;
        }
        
        function getCardinalityText(fromCard, toCard) {
            const fromText = fromCard === 'many' ? 'Many' : 'One';
            const toText = toCard === 'many' ? 'Many' : 'One';
            return `${fromText} to ${toText}`;
        }
        
        function getBusinessContext(rel, fromEntity, toEntity) {
            const contexts = {
                // Core traceability relationships
                'has_processing_timeline': `Each ${fromEntity.name} maintains a complete chronological record of all processing events through ${toEntity.name} entries.`,
                'undergoes_processing': `${fromEntity.name} records are transformed through ${toEntity.name} operations, creating an audit trail of material transformations.`,
                'contains_species': `Each ${fromEntity.name} can contain multiple ${toEntity.name} entries, allowing for mixed-species biomass tracking.`,
                'generates_measurements': `${fromEntity.name} operations produce quantitative ${toEntity.name} data for quality control and verification.`,
                'identified_by': `${fromEntity.name} entities use ${toEntity.name} for media-interruption-free tracking via biometric signatures.`,
                'has_location_history': `${fromEntity.name} movements are tracked through ${toEntity.name} records for complete supply chain visibility.`,
                
                // Organizational relationships
                'has': `${fromEntity.name} entities possess ${toEntity.name} documents that validate their operational credentials and compliance status.`,
                'certifies_against': `${toEntity.name} documents reference specific ${toEntity.name} standards for sustainability validation.`,
                'issued_by': `${toEntity.name} documents are officially issued and validated by accredited ${toEntity.name} organizations.`,
                'employs': `${fromEntity.name} entities maintain ${toEntity.name} records for personnel management and operational oversight.`,
                
                // Material and supply chain
                'manages_supply_base': `${fromEntity.name} entities oversee ${toEntity.name} areas for sustainable biomass sourcing and harvesting operations.`,
                'originates_tru': `${fromEntity.name} areas serve as the source locations where ${toEntity.name} entities are initially created and harvested.`,
                'material_type_reference': `${fromEntity.name} specifications define the material characteristics and properties for ${toEntity.name} entities.`,
                
                // Transaction management
                'contains': `${fromEntity.name} records group multiple ${toEntity.name} entries for efficient transaction processing and logistics.`,
                'includes_tru': `${fromEntity.name} records can include multiple ${toEntity.name} entities for bulk material transfers.`,
                'documented_by': `${fromEntity.name} operations are formally recorded through ${toEntity.name} for legal and compliance purposes.`,
                
                // Geographic and location
                'provides_harvest_location': `${fromEntity.name} entries specify the exact geographic coordinates where ${toEntity.name} entities were originally harvested.`,
                'provides_current_location': `${fromEntity.name} entries track the present geographic position of ${toEntity.name} entities in the supply chain.`,
                'defines_operational_area': `${fromEntity.name} entries establish the geographic boundaries for ${toEntity.name} operational activities.`,
                
                // Analytics and data
                'tracks': `${fromEntity.name} systems monitor and record ${toEntity.name} volumes for mass balance compliance and reporting.`,
                'categorizes': `${fromEntity.name} classifications organize ${toEntity.name} types for standardized processing and certification.`,
                'characterized_by': `${fromEntity.name} entities have associated ${toEntity.name} metrics for environmental impact assessment.`
            };
            
            return contexts[rel.label] || `${fromEntity.name} and ${toEntity.name} are connected through the "${rel.label}" relationship in the BOOST biomass traceability system.`;
        }
        
        function highlightRelationshipEntities(fromEntityId, toEntityId) {
            // Dim all entities except the connected ones
            g.selectAll('.entity').style('opacity', function() {
                const id = d3.select(this).attr('data-id');
                return (id === fromEntityId || id === toEntityId) ? 1 : 0.3;
            });
            
            // Highlight only the relevant relationship
            g.selectAll('.relationship-group').style('opacity', function() {
                const from = d3.select(this).attr('data-from');
                const to = d3.select(this).attr('data-to');
                return (from === fromEntityId && to === toEntityId) || 
                       (from === toEntityId && to === fromEntityId) ? 1 : 0.2;
            });
            
            // Reset after a delay
            setTimeout(() => {
                g.selectAll('.entity').style('opacity', 1);
                g.selectAll('.relationship-group').style('opacity', 0.8);
            }, 2000);
        }
        
        function showRelationshipFocusMessage(relationship, fromEntity, toEntity) {
            // Create a temporary message overlay
            const messageContainer = d3.select('body').append('div')
                .style('position', 'fixed')
                .style('top', '20px')
                .style('left', '50%')
                .style('transform', 'translateX(-50%)')
                .style('background', 'rgba(17, 24, 39, 0.95)')
                .style('color', 'white')
                .style('padding', '12px 20px')
                .style('border-radius', '8px')
                .style('font-size', '14px')
                .style('font-weight', '500')
                .style('z-index', '9999')
                .style('backdrop-filter', 'blur(8px)')
                .style('box-shadow', '0 4px 12px rgba(0,0,0,0.3)')
                .style('opacity', '0');
                
            messageContainer.html(`
                <div style="text-align: center;">
                    <div style="font-weight: 600; margin-bottom: 4px;">Relationship Focus</div>
                    <div style="font-size: 12px; color: #d1d5db;">
                        ${fromEntity.name} <span style="color: #60a5fa;">→</span> ${toEntity.name}
                    </div>
                    <div style="font-size: 11px; color: #9ca3af; margin-top: 4px;">
                        "${relationship.label}"
                    </div>
                </div>
            `);
                
            // Animate in
            messageContainer.transition()
                .duration(300)
                .style('opacity', '1');
                
            // Animate out and remove after delay
            setTimeout(() => {
                messageContainer.transition()
                    .duration(500)
                    .style('opacity', '0')
                    .remove();
            }, 2500);
        }

        function drawCrowsFoot(g, x, y, angle) {
            const size = 7;  // Increased size for better visibility
            const length = 12; // Increased length
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            
            // Draw the three lines of the crow's foot
            const offsets = [-size, 0, size];
            offsets.forEach(offset => {
                const perpCos = Math.cos(angle + Math.PI / 2);
                const perpSin = Math.sin(angle + Math.PI / 2);
                
                g.append('line')
                    .attr('class', 'crowsfoot-line')
                    .attr('x1', x)
                    .attr('y1', y)
                    .attr('x2', x - cos * length + perpCos * offset)
                    .attr('y2', y - sin * length + perpSin * offset);
            });
            
            // Add a small circle at the connection point for "many" relationships
            g.append('circle')
                .attr('cx', x)
                .attr('cy', y)
                .attr('r', 2)
                .attr('fill', 'white')
                .attr('stroke', '#374151')
                .attr('stroke-width', 1.5);
        }

        function drawSingleMark(g, x, y, angle) {
            const perpCos = Math.cos(angle + Math.PI / 2);
            const perpSin = Math.sin(angle + Math.PI / 2);
            const length = 6; // Length of the single mark
            
            // Draw perpendicular line for "one" relationship
            g.append('line')
                .attr('class', 'crowsfoot-line')
                .attr('x1', x + perpCos * length)
                .attr('y1', y + perpSin * length)
                .attr('x2', x - perpCos * length)
                .attr('y2', y - perpSin * length);
                
            // Add a small circle at the connection point for "one" relationships
            g.append('circle')
                .attr('cx', x)
                .attr('cy', y)
                .attr('r', 1.5)
                .attr('fill', '#374151')
                .attr('stroke', 'white')
                .attr('stroke-width', 0.5);
        }

        // Control functions
        function setCurveType(curveType) {
            config.curveType = curveType;
            drawRelationships();
            
            d3.selectAll('.area-controls .control-btn').classed('active', false);
            d3.select(event.target).classed('active', true);
        }
        
        function toggleLabels() {
            const container = d3.select('#svg-container');
            const button = d3.select('#label-toggle');
            const isHidden = container.classed('labels-hidden');
            
            container.classed('labels-hidden', !isHidden);
            button.text(isHidden ? '🏷️' : '🏷️⚹');
            button.attr('title', isHidden ? 'Toggle relationship labels' : 'Show relationship labels');
        }
        
        function toggleLegend() {
            const legend = d3.select('.legend');
            const button = d3.select('#legend-toggle');
            const isHidden = legend.classed('legend-hidden');
            
            legend.classed('legend-hidden', !isHidden);
            button.text(isHidden ? '📋' : '📋⚹');
            button.attr('title', isHidden ? 'Toggle legend visibility' : 'Hide legend');
        }
        
        function toggleTruFocus() {
            const container = d3.select('#svg-container');
            const button = d3.select('#tru-focus');
            const isFocused = container.classed('tru-focus');
            
            container.classed('tru-focus', !isFocused);
            button.text(isFocused ? '🎯' : '🔍');
            button.attr('title', isFocused ? 'Focus on essential TraceableUnit relationships' : 'Show all relationships');
            
            if (!isFocused) {
                // Mark essential relationships and entities
                markEssentialElements();
            }
        }
        
        function markEssentialElements() {
            // Essential TraceableUnit relationships (only the most critical)
            const essentialRelationships = [
                'material_type_reference',
                'includes_tru',
                'originates_tru',
                'manages'
            ];
            
            // Essential entities connected to TraceableUnit
            const essentialEntities = [
                'Material',
                'Transaction', 
                'SupplyBase',
                'Organization'
            ];
            
            // Mark essential relationship groups
            g.selectAll('.relationship-group').each(function() {
                const group = d3.select(this);
                const fromEntity = group.attr('data-from');
                const toEntity = group.attr('data-to');
                
                // Check if this is an essential TraceableUnit relationship
                const isEssential = (fromEntity === 'TraceableUnit' || toEntity === 'TraceableUnit') &&
                                   relationships.some(rel => 
                                       (rel.from === fromEntity && rel.to === toEntity || 
                                        rel.from === toEntity && rel.to === fromEntity) &&
                                       essentialRelationships.includes(rel.label)
                                   );
                
                group.attr('data-essential', isEssential);
            });
            
            // Mark essential entities
            g.selectAll('.entity').each(function() {
                const entity = d3.select(this);
                const entityId = entity.attr('data-id');
                const isEssential = entityId === 'TraceableUnit' || essentialEntities.includes(entityId);
                entity.attr('data-essential', isEssential);
            });
        }

        function showAll() {
            g.selectAll('.entity').style('opacity', 1);
            g.selectAll('.relationship-group').style('opacity', 0.8);
            updateActiveButton(0);
        }

        function filterByArea(area) {
            g.selectAll('.entity').style('opacity', function() {
                return d3.select(this).attr('data-area') === area ? 1 : 0.2;
            });
            g.selectAll('.relationship-group').style('opacity', 0.3);
        }

        function highlightRelationships(entityId) {
            g.selectAll('.relationship-group').style('opacity', function() {
                const from = d3.select(this).attr('data-from');
                const to = d3.select(this).attr('data-to');
                return (from === entityId || to === entityId) ? 1 : 0.2;
            });
            
            g.selectAll('.entity').style('opacity', function() {
                const id = d3.select(this).attr('data-id');
                const isConnected = relationships.some(rel => 
                    (rel.from === entityId && rel.to === id) || 
                    (rel.to === entityId && rel.from === id)
                );
                return (id === entityId || isConnected) ? 1 : 0.3;
            });
        }

        function updateActiveButton(index) {
            d3.selectAll('.controls .btn').classed('active', false);
            d3.selectAll('.controls .btn').nodes()[index].classList.add('active');
        }

        function exportDiagram() {
            const svgElement = document.getElementById('erd-svg');
            const serializer = new XMLSerializer();
            const svgString = serializer.serializeToString(svgElement);
            
            const blob = new Blob([svgString], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'boost-erd-interactive-v2-2-smart-routing.svg';
            a.click();
            
            URL.revokeObjectURL(url);
        }

        // Global variables
        let entities = [];
        let relationships = [];
        let globalErdConfig = null;

        // Initialize button tooltips
        function initializeButtonTooltips() {
            const tooltip = d3.select('#tooltip');
            
            // Toggle buttons with detailed tooltips
            const buttonTooltips = [
                {
                    id: '#label-toggle',
                    content: `<strong>🏷️ Relationship Labels</strong><br/>
                             Toggle visibility of relationship labels on connection lines.<br/>
                             <em>Helpful for understanding entity connections</em>`
                },
                {
                    id: '#tru-focus',
                    content: `<strong>🎯 TraceableUnit Focus</strong><br/>
                             Focus on essential TraceableUnit relationships only.<br/>
                             <em>Simplifies the diagram by showing core traceability flows</em>`
                },
                {
                    id: '#legend-toggle',
                    content: `<strong>📋 Legend</strong><br/>
                             Toggle legend showing relationship line types:<br/>
                             • <strong>Solid lines</strong> - Identifying relationships<br/>
                             • <strong>Dashed lines</strong> - Non-identifying relationships`
                }
            ];
            
            buttonTooltips.forEach(({ id, content }) => {
                d3.select(id)
                    .on('mouseover', function(event) {
                        tooltip.style('opacity', 1)
                            .html(content)
                            .style('left', (event.pageX + 10) + 'px')
                            .style('top', (event.pageY - 10) + 'px');
                    })
                    .on('mouseout', function() {
                        tooltip.style('opacity', 0);
                    })
                    .on('mousemove', function(event) {
                        tooltip.style('left', (event.pageX + 10) + 'px')
                            .style('top', (event.pageY - 10) + 'px');
                    });
            });
        }

        // Initialize
        async function initializeVisualization() {
            try {
                // Load entities from schema files
                entities = await loadEntitiesFromSchema();
                console.log(`Loaded ${entities.length} entities from schema files`);
                
                console.log(`Total relationships available: ${relationships.length}`);
                
                // No fallback - if schema loading fails, show error
                if (entities.length === 0) {
                    throw new Error('No entities loaded from schemas - check configuration and schema files');
                }
                
                // Draw entities
                entities.forEach(entity => {
                    drawEntity(entity);
                });
                
                drawRelationships();
                updateZoomIndicator();
                
                // Initialize button tooltips
                initializeButtonTooltips();
                
                // Initial fit to screen
                setTimeout(fitToScreen, 100);
            } catch (error) {
                console.error('CRITICAL ERROR initializing visualization:', error);
                // Show error message to user instead of fallback
                document.querySelector('.container').innerHTML = `
                    <div style="color: red; text-align: center; padding: 50px;">
                        <h2>❌ ERD Loading Failed</h2>
                        <p><strong>Error:</strong> ${error.message}</p>
                        <p>Please check the browser console for detailed debugging information.</p>
                        <p>Common issues:</p>
                        <ul style="text-align: left; display: inline-block;">
                            <li>Schema files not found or malformed</li>
                            <li>ERD configuration file missing or invalid</li>
                            <li>Entity not configured in ERD config</li>
                        </ul>
                    </div>
                `;
                throw error;
            }
        }

        // Start
        initializeVisualization();
    </script>
</body>
</html>
