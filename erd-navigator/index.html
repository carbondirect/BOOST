<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BOOST Entity Schema Navigator</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=SF+Pro+Display:wght@300;400;500;600&family=SF+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f6f8fa;
            color: #24292e;
        }
        .container {
            max-width: 3200px;
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.12);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 1px solid #e1e4e8;
            padding-bottom: 20px;
        }
        .header h1 {
            margin: 0 0 10px 0;
            color: #0366d6;
        }
        .header p {
            margin: 0;
            color: #586069;
            font-size: 16px;
        }
        .instructions {
            background-color: #f1f8ff;
            border: 1px solid #c8e1ff;
            border-radius: 6px;
            padding: 16px;
            margin-bottom: 30px;
        }
        .instructions h3 {
            margin-top: 0;
            color: #0366d6;
        }
        .info-section {
            background-color: #f6f8fa;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 20px;
            margin-bottom: 25px;
        }
        .info-section h3 {
            margin-top: 0;
            color: #0366d6;
            font-size: 18px;
        }
        .legend {
            background-color: #fff5f5;
            border: 1px solid #fed7d7;
            border-radius: 6px;
            padding: 16px;
            margin-bottom: 25px;
        }
        .legend h3 {
            margin-top: 0;
            color: #c53030;
            font-size: 16px;
        }
        .legend-item {
            display: inline-block;
            margin-right: 25px;
            margin-bottom: 8px;
            font-size: 14px;
        }
        .github-guide {
            background-color: #f0f4ff;
            border: 1px solid #b6d7ff;
            border-radius: 6px;
            padding: 18px;
            margin-bottom: 25px;
        }
        .github-guide h3 {
            margin-top: 0;
            color: #0969da;
            font-size: 17px;
        }
        .github-guide .signup-link {
            display: inline-block;
            padding: 8px 16px;
            background-color: #0969da;
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-weight: bold;
            margin: 10px 10px 10px 0;
        }
        .github-guide .signup-link:hover {
            background-color: #0860ca;
            text-decoration: none;
        }
        .connector-legend {
            background-color: #f8f9fa;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 16px;
            margin: 15px 0;
            font-size: 13px;
        }
        .connector-legend h4 {
            margin-top: 0;
            margin-bottom: 12px;
            color: #0366d6;
            font-size: 14px;
        }
        .connector-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .connector-visual {
            font-family: monospace;
            background-color: white;
            border: 1px solid #ddd;
            padding: 4px 8px;
            margin-right: 12px;
            border-radius: 3px;
            min-width: 60px;
            text-align: center;
        }
        .connector-description {
            color: #555;
        }
        /* Interactive ERD Styles */
        .controls {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 8px 16px;
            border: 1px solid #d1d9e0;
            border-radius: 6px;
            background: white;
            color: #374151;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            font-family: inherit;
            transition: all 0.15s ease;
        }
        
        .btn:hover {
            background: #f9fafb;
            border-color: #9ca3af;
        }
        
        .btn.active {
            background: #1f2937;
            color: white;
            border-color: #1f2937;
        }
        
        .svg-container {
            background: white;
            border-radius: 12px;
            border: 1px solid #d1d9e0;
            box-shadow: 0 1px 3px rgba(16, 24, 40, 0.04);
            overflow: hidden;
            position: relative;
            cursor: grab;
            height: 800px;
            margin-bottom: 30px;
        }
        
        .svg-container.panning {
            cursor: grabbing;
        }
        
        .entity {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .entity:hover {
            filter: drop-shadow(0 4px 12px rgba(0,0,0,0.1));
        }
        
        .entity-header {
            font-family: 'SF Pro Display', system-ui, sans-serif;
            font-weight: 600;
            font-size: 11px;
            letter-spacing: -0.01em;
        }
        
        .entity-field {
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 9px;
            fill: #374151;
            font-weight: 400;
        }
        
        .entity-pk {
            font-family: 'SF Mono', monospace;
            font-weight: 500;
            font-size: 9px;
            fill: #dc2626;
        }
        
        .entity-fk {
            font-family: 'SF Mono', monospace;
            font-weight: 500;
            font-size: 9px;
            fill: #2563eb;
        }
        
        .entity-required {
            font-family: 'SF Mono', monospace;
            font-weight: 500;
            font-size: 9px;
            fill: #1f2937;
        }
        
        .relationship {
            fill: none;
            transition: all 0.25s ease;
        }
        
        .relationship-identifying {
            stroke: #374151;
            stroke-width: 1.5;
        }
        
        .relationship-non-identifying {
            stroke: #9ca3af;
            stroke-width: 1.2;
            stroke-dasharray: 5,3;
        }
        
        .relationship:hover {
            stroke: #1f2937 !important;
            stroke-width: 2.5 !important;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }
        
        .relationship-label {
            font-size: 8px;
            fill: #6b7280;
            text-anchor: middle;
            pointer-events: none;
            font-weight: 500;
        }
        
        .label-background {
            fill: rgba(255, 255, 255, 0.9);
            stroke: #e5e7eb;
            stroke-width: 0.5;
        }
        
        .discussion-icon {
            fill: #4f46e5;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.8;
            stroke: #ffffff;
            stroke-width: 0.5;
        }
        
        .discussion-icon:hover {
            fill: #3730a3;
            opacity: 1;
            stroke: #ffffff;
            stroke-width: 1;
            rx: 3;
        }
        
        .crowsfoot-line {
            stroke: #374151;
            stroke-width: 1.2;
            fill: none;
        }
        
        .tooltip {
            position: absolute;
            padding: 12px;
            background: rgba(17, 24, 39, 0.95);
            color: white;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 1000;
            max-width: 400px;
            font-weight: 400;
            line-height: 1.4;
            backdrop-filter: blur(8px);
        }
        
        .tooltip code {
            background: rgba(255,255,255,0.1);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'SF Mono', monospace;
        }

        .zoom-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .area-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-width: 200px;
        }

        .control-btn {
            padding: 6px 12px;
            border: 1px solid #d1d9e0;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.95);
            color: #374151;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            font-family: inherit;
            transition: all 0.15s ease;
            backdrop-filter: blur(4px);
            text-align: left;
        }

        .control-btn:hover {
            background: white;
            border-color: #9ca3af;
            transform: translateY(-1px);
        }

        .control-btn.active {
            background: #1f2937;
            color: white;
            border-color: #1f2937;
        }

        .zoom-indicator {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            color: #6b7280;
            backdrop-filter: blur(4px);
        }

        .help-text {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            font-size: 10px;
            color: #6b7280;
            backdrop-filter: blur(4px);
            max-width: 200px;
            text-align: center;
        }

        .legend {
            position: absolute;
            bottom: 80px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 12px;
            font-size: 10px;
            color: #6b7280;
            backdrop-filter: blur(4px);
            max-width: 200px;
        }

        .legend h4 {
            margin: 0 0 8px 0;
            font-size: 11px;
            font-weight: 600;
            color: #374151;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        
        .labels-hidden .relationship-label,
        .labels-hidden .label-background {
            display: none;
        }
        
        .tru-focus .relationship-group {
            opacity: 0.2;
        }
        
        .tru-focus .relationship-group[data-essential="true"] {
            opacity: 1;
            stroke-width: 2;
        }
        
        .tru-focus .entity {
            opacity: 0.4;
        }
        
        .tru-focus .entity[data-id="TraceableUnit"],
        .tru-focus .entity[data-essential="true"] {
            opacity: 1;
        }
        .entity-box {
            cursor: pointer;
            transition: opacity 0.2s;
        }
        .entity-box:hover {
            opacity: 0.8;
        }
        .domain-section {
            margin-bottom: 40px;
            padding: 25px;
            background-color: #f8f9fa;
            border: 1px solid #e1e4e8;
            border-radius: 8px;
        }
        .domain-header {
            margin: 0 0 10px 0;
            color: #0366d6;
            font-size: 20px;
            font-weight: 600;
        }
        .domain-description {
            margin: 0 0 20px 0;
            color: #586069;
            font-style: italic;
            font-size: 14px;
        }
        .entity-links {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }
        .entity-link {
            display: block;
            padding: 12px 16px;
            background-color: #ffffff;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            text-decoration: none;
            color: #24292e;
            transition: all 0.2s;
        }
        .entity-link:hover {
            background-color: #f6f8fa;
            border-color: #c8e1ff;
            text-decoration: none;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .entity-link strong {
            color: #0366d6;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        }
        .footer {
            margin-top: 40px;
            text-align: center;
            color: #586069;
            font-size: 14px;
            border-top: 1px solid #e1e4e8;
            padding-top: 20px;
        }
        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: #0366d6;
            text-decoration: none;
        }
        .back-link:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="../" class="back-link">← Back to BOOST Specification</a>
        
        <div class="header">
            <h1>🗂️ BOOST Entity Schema Navigator</h1>
            <p>Interactive Entity Relationship Diagram for Stakeholder Feedback</p>
        </div>


        <div class="github-guide">
            <h3>💬 Join the Discussion</h3>
            <p><strong>Why GitHub?</strong> We use GitHub Discussions to collect structured feedback from stakeholders across the biomass supply chain. It's free, open, and designed for collaborative input on technical standards.</p>
            <p><strong>New to GitHub?</strong> No problem! Creating an account takes just 2 minutes:</p>
            <a href="https://github.com/signup" target="_blank" class="signup-link">Create Free GitHub Account →</a>
            <p style="margin-top: 15px; margin-bottom: 0; font-size: 14px;">
                <strong>Prefer email?</strong> You can also send feedback to the BOOST working group at 
                <a href="mailto:public-boost-01@w3.org">public-boost-01@w3.org</a>
            </p>
        </div>

        <div class="info-section">
            <h3>🏗️ Understanding the Entity Relationship Diagram</h3>
            <p><strong>Entities</strong> represent the core data objects in biomass supply chains - things like Organizations, Certificates, Material Feedstock, and Transactions. Each entity captures specific information needed for chain of custody tracking.</p>
            <p><strong>Attributes</strong> are the data fields within each entity (like organization name, certificate expiry date, or biomass quantity). These define what information must be recorded and tracked.</p>
            <p><strong>Relationships</strong> show how entities connect to each other - for example, how a Certificate relates to an Organization, or how Material Feedstock flows through Transactions. These connections enable complete supply chain traceability.</p>
            <p style="margin-left: 20px; font-size: 14px; color: #555;">
                <strong>Reading the Diagram:</strong> Entities are shown as rectangular boxes containing their names (like Organization, Certificate, MaterialFeedstock). Lines connect related entities to show how they interact - for example, an Organization "is issued" a Certificate, or a Supplier "provides" MaterialFeedstock. Text along the lines describes the nature of each relationship in the biomass supply chain.
            </p>
            <div class="connector-legend">
                <h4>🔗 Relationship Connectors</h4>
                <div class="connector-item">
                    <div class="connector-visual">--||-||</div>
                    <div class="connector-description">One-to-one relationship (e.g., Organization has one Certificate)</div>
                </div>
                <div class="connector-item">
                    <div class="connector-visual">--||o{</div>
                    <div class="connector-description">One-to-many relationship (e.g., Organization has many Transactions)</div>
                </div>
                <div class="connector-item">
                    <div class="connector-visual">}|--||</div>
                    <div class="connector-description">Many-to-one relationship (e.g., many Materials from one Supplier)</div>
                </div>
                <div class="connector-item">
                    <div class="connector-visual">}|--|{</div>
                    <div class="connector-description">Many-to-many relationship (e.g., Materials can have multiple Claims)</div>
                </div>
                <div class="connector-item">
                    <div class="connector-visual">--||o|</div>
                    <div class="connector-description">Optional relationship (e.g., Organization may have Certificate)</div>
                </div>
            </div>
            <p style="margin-bottom: 0;"><strong>Purpose:</strong> This diagram maps the complete data structure needed to track biomass from source to end use, supporting regulatory compliance, sustainability verification, and carbon accounting.</p>
        </div>

        <div class="instructions">
            <h3>📋 How to Provide Feedback</h3>
            <p><strong>Our Goal:</strong> Collect real-world input from stakeholders to ensure the BOOST data standard meets practical biomass supply chain needs.</p>
            <p><strong>Explore the interactive diagram below</strong> to understand the complete BOOST data model. You can zoom in/out, pan around, and use the filtering controls to examine entity relationships in detail.</p>
            <p><strong>To provide feedback on a specific entity</strong>, click on the purple 💬 discussion icon in any entity header to jump directly to its GitHub discussion thread.</p>
            <p><strong>💡 What we're looking for:</strong> Field completeness, data types, real-world applicability, missing attributes, validation requirements, and integration challenges.</p>
        </div>

        <div class="info-section">
            <h3>🎯 Using the Interactive ERD</h3>
            <p><strong>Navigation:</strong> Use your mouse wheel to zoom, click and drag to pan around the diagram. The purple 💬 icons in entity headers link directly to GitHub discussions for that entity.</p>
            <p><strong>Filtering:</strong> Use the colored filter buttons to focus on specific areas of the data model (Core Traceability, Organizational, Material & Supply, etc.).</p>
            <p><strong>Focus Mode:</strong> Click the 🎯 button in the controls to highlight only essential TraceableUnit relationships, reducing visual clutter.</p>
            <p><strong>Field Legend:</strong> PK = Primary Key (red), FK = Foreign Key (blue), ● = Required Field, ○ = Optional Field</p>
        </div>
        
        <div class="controls">
            <button class="btn active" onclick="showAll()">All Entities</button>
            <button class="btn" onclick="filterByArea('core_traceability')">🟢 Core Traceability</button>
            <button class="btn" onclick="filterByArea('organizational_foundation')">🔵 Organizational</button>
            <button class="btn" onclick="filterByArea('material_supply_chain')">🟤 Material & Supply</button>
            <button class="btn" onclick="filterByArea('transaction_management')">🟠 Transactions</button>
            <button class="btn" onclick="filterByArea('sustainability_claims')">🟡 Sustainability</button>
            <button class="btn" onclick="filterByArea('geographic_location')">🟣 Geographic</button>
            <button class="btn" onclick="filterByArea('reporting_compliance')">🔴 Reporting</button>
            <button class="btn" onclick="filterByArea('analytics_data')">⚫ Analytics</button>
            <button class="btn" onclick="filterByArea('personnel')">👥 Personnel</button>
            <button class="btn" onclick="fitToScreen()">Fit to Screen</button>
        </div>

        <div class="svg-container" id="svg-container">
            <div class="zoom-controls">
                <button class="control-btn" onclick="zoomIn()" title="Zoom In">🔍+</button>
                <button class="control-btn" onclick="zoomOut()" title="Zoom Out">🔍−</button>
                <button class="control-btn" onclick="resetZoom()" title="Reset Zoom">⌂</button>
                <button class="control-btn" onclick="toggleLabels()" title="Toggle relationship labels" id="label-toggle">🏷️</button>
                <button class="control-btn" onclick="toggleTruFocus()" title="Focus on essential TraceableUnit relationships" id="tru-focus">🎯</button>
            </div>
            
            <div class="area-controls">
                <button class="control-btn active" onclick="setCurveType('curveBasis')" title="Smooth curves">Smooth</button>
                <button class="control-btn" onclick="setCurveType('curveCardinal')" title="Cardinal curves">Cardinal</button>
                <button class="control-btn" onclick="setCurveType('curveBundle')" title="Bundle curves">Bundle</button>
            </div>
            
            <div class="zoom-indicator" id="zoom-indicator">100%</div>
            
            <div class="help-text">
                Mouse wheel: zoom<br/>
                Click & drag: pan<br/>
                Click entity: highlight<br/>
                Click relationship: focus<br/>
                Hover: details
            </div>

            <div class="legend">
                <h4>Field Types</h4>
                <div class="legend-item">
                    <span style="color: #dc2626; font-weight: 600;">PK</span>
                    <span>Primary Key</span>
                </div>
                <div class="legend-item">
                    <span style="color: #2563eb; font-weight: 600;">FK</span>
                    <span>Foreign Key</span>
                </div>
                <div class="legend-item">
                    <span style="color: #1f2937;">●</span>
                    <span>Required Field</span>
                </div>
                <div class="legend-item">
                    <span style="color: #9ca3af;">○</span>
                    <span>Optional Field</span>
                </div>
            </div>
            
            <svg id="erd-svg" width="3200" height="2000"></svg>
        </div>
        
        <div class="tooltip" id="tooltip"></div>

        <div class="info-section">
            <h3>💬 Entity Discussion Access</h3>
            <p><strong>Direct Links in ERD:</strong> Each entity in the interactive diagram above has a purple 💬 discussion icon in its header. Click these icons to go directly to the GitHub discussion for that specific entity.</p>
            <p><strong>Complete Coverage:</strong> All 29 entities in the BOOST data model have dedicated discussion threads where you can provide feedback on schemas, relationships, and real-world applicability.</p>
            <p style="text-align: center; margin-top: 20px;">
                <strong>💡 Pro Tip:</strong> Use the thematic filter buttons above the diagram to focus on specific areas, then click the discussion icons for targeted feedback.
            </p>
        </div>

        <!-- General Feedback Section -->
        <div class="info-section">
            <h3>🏗️ General ERD Structure Feedback</h3>
            <p><strong>Beyond Individual Entities:</strong> While the entity links above are for specific schema feedback, we also welcome input on the overall data model structure and organization.</p>
            <p><strong>Structural Questions:</strong> Are these the right entities in the right relationships? Should any entities be consolidated or split? Are there missing supply chain stages or processes?</p>
            <p><strong>Implementation Considerations:</strong> Will this structure work well for real-world deployments? How does it compare to existing industry data models?</p>
            <div style="text-align: center; margin-top: 20px;">
                <a href="https://github.com/carbondirect/BOOST/discussions/117" target="_blank" style="display: inline-block; padding: 12px 24px; background-color: #0969da; color: white; text-decoration: none; border-radius: 6px; font-weight: bold;">
                    💬 Discuss Overall ERD Structure →
                </a>
            </div>
        </div>

        <!-- Q&A Section -->
        <div class="info-section">
            <h3>❓ Questions & Answers</h3>
            <p><strong>Have Questions?</strong> Use our Q&A section for general questions about the BOOST data model, implementation guidance, or clarifications about entity relationships.</p>
            <p><strong>Examples:</strong> "How do I implement mass balance tracking?" or "What's the difference between Claim and VerificationStatement?" or "How does BOOST compare to other standards?"</p>
            <p><strong>Community Support:</strong> Get help from other stakeholders, implementers, and the BOOST working group.</p>
            <div style="text-align: center; margin-top: 20px;">
                <a href="https://github.com/carbondirect/BOOST/discussions/categories/q-a" target="_blank" style="display: inline-block; padding: 12px 24px; background-color: #6f42c1; color: white; text-decoration: none; border-radius: 6px; font-weight: bold;">
                    🙋 Ask a Question →
                </a>
            </div>
        </div>

        <div class="footer">
            <p>This ERD navigator is part of the BOOST data standard development process.<br>
            Your feedback helps ensure the standard meets real-world biomass chain of custody needs.</p>
            <p><a href="https://github.com/carbondirect/BOOST">📂 View full repository</a> | 
            <a href="https://github.com/carbondirect/BOOST/issues/61">🎯 Parent Issue #61</a></p>
        </div>
    </div>

    <script>
        // Configuration based on schema
        const config = {
            width: 3200,
            height: 2000,
            entityWidth: 180,
            entityFieldHeight: 12,
            entityPadding: 6,
            headerHeight: 20,
            curveType: 'curveBasis',
            colors: {
                'core_traceability': { 
                    fill: 'rgba(46, 125, 50, 0.1)', 
                    stroke: '#2E7D32', 
                    header: '#1B5E20'
                },
                'organizational_foundation': { 
                    fill: 'rgba(21, 101, 192, 0.1)', 
                    stroke: '#1565C0', 
                    header: '#0D47A1'
                },
                'material_supply_chain': { 
                    fill: 'rgba(93, 64, 55, 0.1)', 
                    stroke: '#5D4037', 
                    header: '#3E2723'
                },
                'transaction_management': { 
                    fill: 'rgba(245, 124, 0, 0.1)', 
                    stroke: '#F57C00', 
                    header: '#E65100'
                },
                'sustainability_claims': { 
                    fill: 'rgba(249, 168, 37, 0.1)', 
                    stroke: '#F9A825', 
                    header: '#F57F17'
                },
                'geographic_location': { 
                    fill: 'rgba(123, 31, 162, 0.1)', 
                    stroke: '#7B1FA2', 
                    header: '#4A148C'
                },
                'reporting_compliance': { 
                    fill: 'rgba(198, 40, 40, 0.1)', 
                    stroke: '#C62828', 
                    header: '#B71C1C'
                },
                'analytics_data': { 
                    fill: 'rgba(66, 66, 66, 0.1)', 
                    stroke: '#424242', 
                    header: '#212121'
                },
                'personnel': { 
                    fill: 'rgba(103, 58, 183, 0.1)', 
                    stroke: '#673AB7', 
                    header: '#512DA8'
                }
            }
        };

        // Strategic positioning with increased spacing to reduce overlaps
        const entityPositions = {
            // 🟢 CORE TRACEABILITY - Central cluster with more spacing (9 entities)
            'TraceableUnit': { x: 1600, y: 1000 },
            'MaterialProcessing': { x: 1200, y: 1400 },
            'ProcessingHistory': { x: 2000, y: 1400 },
            'SpeciesComponent': { x: 1200, y: 600 },
            'MeasurementRecord': { x: 2000, y: 600 },
            'LocationHistory': { x: 1600, y: 600 },
            'BiometricIdentifier': { x: 1600, y: 1400 },
            'TrackingPoint': { x: 900, y: 1000 },
            'DataReconciliation': { x: 2300, y: 1000 },

            // 🔵 ORGANIZATIONAL FOUNDATION - Far left (4 entities)
            'Organization': { x: 100, y: 1000 },
            'Certificate': { x: 100, y: 600 },
            'CertificationScheme': { x: 100, y: 200 },
            'CertificationBody': { x: 100, y: 1400 },

            // 🟤 MATERIAL & SUPPLY CHAIN - Left side with more spacing (4 entities)
            'Material': { x: 500, y: 200 },
            'SupplyBase': { x: 500, y: 600 },
            'Supplier': { x: 500, y: 1000 },
            'Customer': { x: 500, y: 1400 },

            // 🟠 TRANSACTION MANAGEMENT - Far right (3 entities)
            'Transaction': { x: 2700, y: 1000 },
            'TransactionBatch': { x: 2700, y: 1400 },
            'SalesDeliveryDocument': { x: 2700, y: 600 },

            // 🟡 SUSTAINABILITY & CLAIMS - Top center (1 entity)
            'Claim': { x: 1600, y: 200 },

            // 🟣 GEOGRAPHIC & LOCATION - Center left (1 entity)
            'GeographicData': { x: 900, y: 600 },

            // 🔴 REPORTING & COMPLIANCE - Lower right with spacing (3 entities)
            'SupplyBaseReport': { x: 2700, y: 1800 },
            'VerificationStatement': { x: 2300, y: 1800 },
            'Audit': { x: 1900, y: 1800 },

            // ⚫ ANALYTICS & DATA MANAGEMENT - Lower center with spacing (3 entities)
            'ProductGroup': { x: 1200, y: 1800 },
            'MassBalanceAccount': { x: 900, y: 1800 },
            'EnergyCarbonData': { x: 1600, y: 1800 },

            // 👥 PERSONNEL MANAGEMENT - Lower left (1 entity)
            'Operator': { x: 500, y: 1800 }
        };

        // Auto-discovery functions - supports both raw directory listings and Jekyll pages
        async function discoverSchemaDirectories() {
            try {
                const response = await fetch('../drafts/current/schema/');
                const text = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(text, 'text/html');
                
                // Try Jekyll format first (GitHub Pages)
                const codeBlocks = doc.querySelectorAll('pre code, .highlight code');
                let directories = [];
                
                for (const codeBlock of codeBlocks) {
                    const content = codeBlock.textContent;
                    // Look for directory structure with trailing slashes
                    const directoryMatches = content.match(/├── (\w+)\//g) || content.match(/(\w+)\/\s*#/g);
                    if (directoryMatches) {
                        directories = directoryMatches
                            .map(match => match.replace(/├── |\/.*$/g, '').trim())
                            .filter(name => name && !name.includes('.') && name !== 'README');
                        console.log(`Found Jekyll-formatted directories: ${directories.join(', ')}`);
                        break;
                    }
                }
                
                // Fallback to raw directory listing format (local server)
                if (directories.length === 0) {
                    directories = Array.from(doc.querySelectorAll('a'))
                        .map(a => a.textContent.trim())
                        .filter(name => name && !name.includes('.') && name !== '../' && name !== 'README.md')
                        .map(name => name.replace('/', ''));
                    console.log(`Found raw directory listing: ${directories.join(', ')}`);
                }
                
                console.log(`Auto-discovered ${directories.length} schema directories`);
                return directories;
            } catch (error) {
                console.error('Could not auto-discover schemas:', error);
                return [];
            }
        }

        function directoryToEntityName(directory) {
            // Convert snake_case to PascalCase
            return directory.split('_')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join('');
        }

        // Schema loading functions
        async function loadSchemaFile(entityName) {
            try {
                const schemaPath = `../drafts/current/schema/${entityName.replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2').replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase()}/validation_schema.json?cb=${Date.now()}`;
                const response = await fetch(schemaPath);
                if (!response.ok) {
                    console.warn(`Could not load schema for ${entityName}: ${response.status}`);
                    return null;
                }
                return await response.json();
            } catch (error) {
                console.warn(`Error loading schema for ${entityName}:`, error);
                return null;
            }
        }

        function extractMetadataFromSchema(entityName, schema) {
            const schemaData = schema.schema || schema;
            const boostMeta = schemaData.boost_metadata;
            
            if (!boostMeta) {
                console.warn(`Entity ${entityName} is missing boost_metadata in schema file`);
                return null;
            }
            
            if (!boostMeta.area) {
                console.warn(`Entity ${entityName} has boost_metadata but missing area field`);
                return null;
            }
            
            return {
                area: boostMeta.area,
                description: `${boostMeta.emoji || '📋'} ${schemaData.description || schemaData.title || entityName}`,
                position: boostMeta.position || null,
                relationships: boostMeta.relationships || []
            };
        }

        function calculateAutoPosition(area, entityIndex, entitiesInArea) {
            const areaLayouts = {
                'core_traceability': { startX: 1400, startY: 800, cols: 2, spacing: 400 },
                'organizational_foundation': { startX: 100, startY: 400, cols: 1, spacing: 400 },
                'material_supply_chain': { startX: 800, startY: 600, cols: 2, spacing: 400 },
                'transaction_management': { startX: 2400, startY: 800, cols: 1, spacing: 400 },
                'sustainability_claims': { startX: 1400, startY: 200, cols: 3, spacing: 400 },
                'geographic_location': { startX: 500, startY: 1200, cols: 2, spacing: 400 },
                'reporting_compliance': { startX: 2800, startY: 400, cols: 1, spacing: 500 },
                'analytics_data': { startX: 1000, startY: 1800, cols: 3, spacing: 300 },
                'personnel': { startX: 400, startY: 1800, cols: 1, spacing: 400 }
            };
            
            const layout = areaLayouts[area] || areaLayouts['analytics_data'];
            const col = entityIndex % layout.cols;
            const row = Math.floor(entityIndex / layout.cols);
            
            return {
                x: layout.startX + (col * layout.spacing),
                y: layout.startY + (row * layout.spacing)
            };
        }

        function convertSchemaToEntity(entityName, schema, area, description, position) {
            if (!schema || !schema.schema || !schema.schema.properties) {
                return null;
            }

            const properties = schema.schema.properties;
            const required = schema.schema.required || [];
            const fields = [];

            // Convert schema properties to ERD fields
            Object.entries(properties).forEach(([fieldName, fieldDef]) => {
                // Skip JSON-LD context fields
                if (fieldName.startsWith('@')) return;

                let fieldType = fieldDef.type || 'string';
                let isPK = false;
                let isFK = false;
                let isRequired = required.includes(fieldName);

                // Detect primary keys (usually ends with 'Id' and matches entity name)
                if (fieldName.toLowerCase().includes('id') && 
                    (fieldName.toLowerCase().includes(entityName.toLowerCase()) || fieldName === 'id')) {
                    isPK = true;
                }

                // Detect foreign keys (ends with 'Id' but not primary key)
                if (fieldName.endsWith('Id') && !isPK && fieldName !== 'id') {
                    isFK = true;
                }

                // Handle enum types
                if (fieldDef.enum) {
                    fieldType = 'enum';
                }

                // Handle array types
                if (fieldType === 'array') {
                    fieldType = 'array';
                }

                // Handle number types
                if (fieldType === 'number') {
                    fieldType = fieldDef.format === 'date-time' ? 'datetime' : 'decimal';
                }

                fields.push({
                    name: fieldName,
                    type: fieldType,
                    isPK: isPK,
                    isFK: isFK,
                    required: isRequired
                });
            });

            return {
                id: entityName,
                name: entityName,
                area: area,
                description: description,
                fields: fields,
                x: position.x,
                y: position.y
            };
        }


        // Load entities from schema files with auto-discovery
        async function loadEntitiesFromSchema() {
            const entities = [];
            const discoveredRelationships = [];
            
            // Try auto-discovery first
            const directories = await discoverSchemaDirectories();
            const discoveredEntities = new Set();
            
            // Group entities by area for auto-positioning
            const entitiesByArea = {};
            
            for (const directory of directories) {
                const entityName = directoryToEntityName(directory);
                const schema = await loadSchemaFile(entityName);
                
                if (schema) {
                    console.log(`Processing entity: ${entityName}`);
                    const metadata = extractMetadataFromSchema(entityName, schema);
                    
                    if (metadata) {
                        console.log(`✅ ${entityName} loaded successfully in area: ${metadata.area}`);
                        // Collect relationships from schema metadata
                        if (metadata.relationships && metadata.relationships.length > 0) {
                            metadata.relationships.forEach(rel => {
                                discoveredRelationships.push({
                                    from: rel.from,
                                    to: rel.to,
                                    label: rel.label,
                                    type: rel.type,
                                    fromCard: rel.from_cardinality,
                                    toCard: rel.to_cardinality
                                });
                            });
                            console.log(`Found ${metadata.relationships.length} relationships for ${entityName}`);
                        }
                        
                        // Initialize area group if needed
                        if (!entitiesByArea[metadata.area]) {
                            entitiesByArea[metadata.area] = [];
                        }
                        
                        // Auto-calculate position if not specified
                        let position = metadata.position;
                        if (!position) {
                            // Auto-calculate position
                            const entityIndex = entitiesByArea[metadata.area].length;
                            position = calculateAutoPosition(metadata.area, entityIndex);
                        }
                        
                        const entity = convertSchemaToEntity(entityName, schema, metadata.area, metadata.description, position);
                        if (entity) {
                            entities.push(entity);
                            entitiesByArea[metadata.area].push(entity);
                            discoveredEntities.add(entityName);
                        }
                    } else {
                        console.warn(`Skipping ${entityName} - missing boost_metadata`);
                    }
                } else {
                    console.warn(`Failed to load schema for ${entityName} from directory ${directory}`);
                }
            }
            
            // No fallback needed - all entities must have boost_metadata in their schema files
            
            // Merge discovered relationships with static relationships
            if (discoveredRelationships.length > 0) {
                console.log(`Merging ${discoveredRelationships.length} relationships from schema metadata with ${relationships.length} static relationships`);
                relationships.push(...discoveredRelationships);
                console.log(`Total relationships after merge: ${relationships.length}`);
            }
            
            console.log(`Loaded ${entities.length} entities (${discoveredEntities.size} auto-discovered, ${entities.length - discoveredEntities.size} from metadata)`);
            return entities;
        }

        // Complete entities based on schema definitions - will be replaced by dynamic loading
        const staticEntities = [
            {
                id: 'TraceableUnit',
                name: 'TraceableUnit',
                area: 'core_traceability',
                description: '🔑 CENTRAL: Unique biomass tracking unit with BOOST traceability system integration',
                fields: [
                    { name: 'traceableUnitId', type: 'string', isPK: true, required: true },
                    { name: 'unitType', type: 'enum', required: true },
                    { name: 'uniqueIdentifier', type: 'string', required: true },
                    { name: 'totalVolumeM3', type: 'decimal', required: true },
                    { name: 'currentMoistureContent', type: 'decimal' },
                    { name: 'moistureContentTimestamp', type: 'datetime' },
                    { name: 'moistureContentSource', type: 'string' },
                    { name: 'currentGeographicDataId', type: 'string', isFK: true },
                    { name: 'harvestGeographicDataId', type: 'string', isFK: true },
                    { name: 'createdTimestamp', type: 'datetime', required: true },
                    { name: 'harvesterId', type: 'string', isFK: true },
                    { name: 'operatorId', type: 'string', isFK: true },
                    { name: 'materialTypeId', type: 'string', isFK: true },
                    { name: 'assortmentType', type: 'string' },
                    { name: 'qualityGrade', type: 'string' },
                    { name: 'isMultiSpecies', type: 'boolean' },
                    { name: 'currentStatus', type: 'string' },
                    { name: 'sustainabilityCertification', type: 'string' },
                    { name: 'parentTraceableUnitId', type: 'string', isFK: true },
                    { name: 'childTraceableUnitIds', type: 'string[]' }
                ]
            },
            {
                id: 'MaterialProcessing',
                name: 'MaterialProcessing',
                area: 'core_traceability',
                description: '🔑 Processing operations that transform TRUs with plant part tracking',
                fields: [
                    { name: 'processingId', type: 'string', isPK: true, required: true },
                    { name: 'inputTraceableUnitId', type: 'string', isFK: true, required: true },
                    { name: 'outputTraceableUnitId', type: 'string', isFK: true },
                    { name: 'processType', type: 'string', required: true },
                    { name: 'processTimestamp', type: 'datetime', required: true },
                    { name: 'processingGeographicDataId', type: 'string', isFK: true },
                    { name: 'operatorId', type: 'string', isFK: true },
                    { name: 'inputComposition', type: 'string' },
                    { name: 'outputComposition', type: 'string' },
                    { name: 'inputVolume', type: 'decimal' },
                    { name: 'outputVolume', type: 'decimal' },
                    { name: 'volumeLoss', type: 'decimal' },
                    { name: 'qualityMetrics', type: 'string' },
                    { name: 'equipmentUsed', type: 'string' }
                ]
            },
            {
                id: 'ProcessingHistory',
                name: 'ProcessingHistory',
                area: 'core_traceability',
                description: '🔑 Complete timeline of processing events with moisture tracking',
                fields: [
                    { name: 'processingHistoryId', type: 'string', isPK: true, required: true },
                    { name: 'traceableUnitId', type: 'string', isFK: true, required: true },
                    { name: 'materialProcessingId', type: 'string', isFK: true },
                    { name: 'timestamp', type: 'datetime', required: true },
                    { name: 'processSequenceNumber', type: 'integer' },
                    { name: 'processingEventType', type: 'string' },
                    { name: 'inputTRUIds', type: 'string[]' },
                    { name: 'outputTRUIds', type: 'string[]' },
                    { name: 'processingDuration', type: 'string' },
                    { name: 'qualityChangeDescription', type: 'string' },
                    { name: 'inputMoistureContent', type: 'decimal' },
                    { name: 'outputMoistureContent', type: 'decimal' },
                    { name: 'moistureChangeRatio', type: 'decimal' },
                    { name: 'operatorId', type: 'string', isFK: true }
                ]
            },
            {
                id: 'SpeciesComponent',
                name: 'SpeciesComponent',
                area: 'core_traceability',
                description: '🌲 Species composition within TRUs',
                fields: [
                    { name: 'componentId', type: 'string', isPK: true, required: true },
                    { name: 'traceableUnitId', type: 'string', isFK: true, required: true },
                    { name: 'species', type: 'string', required: true },
                    { name: 'volumeM3', type: 'decimal' },
                    { name: 'percentageByVolume', type: 'decimal' },
                    { name: 'qualityGrade', type: 'string' },
                    { name: 'sourceGeographicDataId', type: 'string', isFK: true },
                    { name: 'harvestingMethod', type: 'string' },
                    { name: 'harvestTimestamp', type: 'datetime' },
                    { name: 'carbonStorage', type: 'string' },
                    { name: 'primaryPlantPart', type: 'string' }
                ]
            },
            {
                id: 'MeasurementRecord',
                name: 'MeasurementRecord',
                area: 'core_traceability',
                description: '📏 Quality measurements and dimensional data',
                fields: [
                    { name: 'recordId', type: 'string', isPK: true, required: true },
                    { name: 'traceableUnitId', type: 'string', isFK: true, required: true },
                    { name: 'measuredVolume', type: 'decimal' },
                    { name: 'measuredLength', type: 'decimal' },
                    { name: 'measuredDiameter', type: 'decimal' },
                    { name: 'moistureContent', type: 'decimal' },
                    { name: 'moistureMeasurementMethod', type: 'string' },
                    { name: 'moistureEquipmentUsed', type: 'string' },
                    { name: 'measurementMethod', type: 'string' },
                    { name: 'measurementGeographicDataId', type: 'string', isFK: true },
                    { name: 'measurementTimestamp', type: 'datetime', required: true },
                    { name: 'operatorId', type: 'string', isFK: true },
                    { name: 'trackingPointId', type: 'string', isFK: true }
                ]
            },
            {
                id: 'LocationHistory',
                name: 'LocationHistory',
                area: 'core_traceability',
                description: '📍 Historical movement records of TRUs',
                fields: [
                    { name: 'locationHistoryId', type: 'string', isPK: true, required: true },
                    { name: 'traceableUnitId', type: 'string', isFK: true, required: true },
                    { name: 'geographicDataId', type: 'string', isFK: true, required: true },
                    { name: 'timestamp', type: 'datetime', required: true },
                    { name: 'locationEventType', type: 'string' },
                    { name: 'materialProcessingId', type: 'string', isFK: true },
                    { name: 'operatorId', type: 'string', isFK: true },
                    { name: 'equipmentUsed', type: 'string' },
                    { name: 'notes', type: 'string' },
                    { name: 'distanceTraveled', type: 'decimal' },
                    { name: 'transportMethod', type: 'string' },
                    { name: 'isCurrentLocation', type: 'boolean' }
                ]
            },
            {
                id: 'BiometricIdentifier',
                name: 'BiometricIdentifier',
                area: 'core_traceability',
                description: '🔬 Biometric identifiers for media-interruption-free tracking',
                fields: [
                    { name: 'biometricId', type: 'string', isPK: true, required: true },
                    { name: 'traceableUnitId', type: 'string', isFK: true, required: true },
                    { name: 'biometricSignature', type: 'string', required: true },
                    { name: 'captureMethod', type: 'string' },
                    { name: 'captureGeographicDataId', type: 'string', isFK: true },
                    { name: 'captureTimestamp', type: 'datetime', required: true },
                    { name: 'trackingPointId', type: 'string', isFK: true },
                    { name: 'speciesBiometrics', type: 'string[]' }
                ]
            },
            {
                id: 'TrackingPoint',
                name: 'TrackingPoint',
                area: 'core_traceability',
                description: '📡 Physical tracking points in supply chain',
                fields: [
                    { name: 'trackingPointId', type: 'string', isPK: true, required: true },
                    { name: 'pointType', type: 'string', required: true },
                    { name: 'geographicDataId', type: 'string', isFK: true, required: true },
                    { name: 'equipmentUsed', type: 'string' },
                    { name: 'operatorId', type: 'string', isFK: true },
                    { name: 'establishedTimestamp', type: 'datetime', required: true }
                ]
            },
            {
                id: 'DataReconciliation',
                name: 'DataReconciliation',
                area: 'core_traceability',
                description: '🔄 Reconciliation of measurement discrepancies',
                fields: [
                    { name: 'reconciliationId', type: 'string', isPK: true, required: true },
                    { name: 'traceableUnitId', type: 'string', isFK: true, required: true },
                    { name: 'transactionId', type: 'string', isFK: true },
                    { name: 'forestMeasurement', type: 'decimal' },
                    { name: 'millMeasurement', type: 'decimal' },
                    { name: 'discrepancy', type: 'decimal' },
                    { name: 'reconciliationStatus', type: 'string' },
                    { name: 'discrepancyReason', type: 'string' },
                    { name: 'reconciliationDate', type: 'datetime' },
                    { name: 'reconciliationOperator', type: 'string' }
                ]
            },
            {
                id: 'Organization',
                name: 'Organization',
                area: 'organizational_foundation',
                description: '🏢 Business entities in BOOST supply chain',
                fields: [
                    { name: 'organizationId', type: 'string', isPK: true, required: true },
                    { name: 'name', type: 'string', required: true },
                    { name: 'address', type: 'string' },
                    { name: 'role', type: 'string' },
                    { name: 'scopeOfOperations', type: 'string' },
                    { name: 'legalEntityStatus', type: 'string' },
                    { name: 'certificateCode', type: 'string', isFK: true },
                    { name: 'contactInfo', type: 'string' },
                    { name: 'equipmentIds', type: 'string[]' },
                    { name: 'operatorIds', type: 'string[]' },
                    { name: 'harvestSites', type: 'string[]' },
                    { name: 'traceableUnitIds', type: 'string[]' }
                ]
            },
            {
                id: 'Certificate',
                name: 'Certificate',
                area: 'organizational_foundation',
                description: '📜 Sustainability certificates',
                fields: [
                    { name: 'certificateNumber', type: 'string', isPK: true, required: true },
                    { name: 'certificateId', type: 'string' },
                    { name: 'dateOfIssue', type: 'date', required: true },
                    { name: 'dateOfExpiry', type: 'date', required: true },
                    { name: 'scopeOfCertification', type: 'string' },
                    { name: 'status', type: 'string' },
                    { name: 'versionNumber', type: 'string' },
                    { name: 'cbId', type: 'string', isFK: true },
                    { name: 'organizationId', type: 'string', isFK: true },
                    { name: 'certificationSchemeId', type: 'string', isFK: true },
                    { name: 'certificateGeographicDataId', type: 'string', isFK: true },
                    { name: 'lastUpdated', type: 'datetime' }
                ]
            },
            {
                id: 'CertificationScheme',
                name: 'CertificationScheme',
                area: 'organizational_foundation',
                description: '🛡️ Certification schemes (FSC, PEFC, SBP, etc.)',
                fields: [
                    { name: 'schemeId', type: 'string', isPK: true, required: true },
                    { name: 'schemeName', type: 'string', required: true },
                    { name: 'recognitionStatus', type: 'string' },
                    { name: 'versionNumber', type: 'string' },
                    { name: 'description', type: 'string' },
                    { name: 'website', type: 'uri' },
                    { name: 'materialCategories', type: 'string[]' },
                    { name: 'controlSystems', type: 'string[]' },
                    { name: 'labelUseRequirements', type: 'string' },
                    { name: 'volumeTrackingRequirements', type: 'string' },
                    { name: 'dueDiligenceRequirements', type: 'string' },
                    { name: 'sustainabilityCriteria', type: 'string[]' },
                    { name: 'applicableRegions', type: 'string[]' }
                ]
            },
            {
                id: 'CertificationBody',
                name: 'CertificationBody',
                area: 'organizational_foundation',
                description: '🏛️ Accredited certification bodies',
                fields: [
                    { name: 'cbId', type: 'string', isPK: true, required: true },
                    { name: 'cbName', type: 'string', required: true },
                    { name: 'accreditationStatus', type: 'string' },
                    { name: 'accreditationScope', type: 'string' },
                    { name: 'contactInformation', type: 'object' },
                    { name: 'jurisdictions', type: 'string[]' },
                    { name: 'sectorsServed', type: 'string[]' },
                    { name: 'isActive', type: 'boolean', required: true },
                    { name: 'lastUpdated', type: 'datetime' }
                ]
            },
            {
                id: 'Material',
                name: 'Material',
                area: 'material_supply_chain',
                description: '🪵 Material types and specifications',
                fields: [
                    { name: 'materialTypeId', type: 'string', isPK: true, required: true },
                    { name: 'materialName', type: 'string', required: true },
                    { name: 'materialCategory', type: 'string' },
                    { name: 'defaultAssortmentTypes', type: 'string' },
                    { name: 'standardQualityGrades', type: 'string' },
                    { name: 'carbonStorageRate', type: 'string' },
                    { name: 'density', type: 'string' },
                    { name: 'applicableProcessingTypes', type: 'string[]' },
                    { name: 'applicablePlantParts', type: 'string[]' },
                    { name: 'excludedPlantParts', type: 'string[]' }
                ]
            },
            {
                id: 'SupplyBase',
                name: 'SupplyBase',
                area: 'material_supply_chain',
                description: '🌲 Supply base areas and management',
                fields: [
                    { name: 'supplyBaseId', type: 'string', isPK: true, required: true },
                    { name: 'organizationId', type: 'string', isFK: true, required: true },
                    { name: 'supplyBaseName', type: 'string', required: true },
                    { name: 'description', type: 'string' },
                    { name: 'harvestSites', type: 'string[]' },
                    { name: 'skidRoads', type: 'string[]' },
                    { name: 'forestRoads', type: 'string[]' },
                    { name: 'equipmentDeployment', type: 'string[]' },
                    { name: 'traceableUnitIds', type: 'string[]' },
                    { name: 'speciesAvailable', type: 'string[]' },
                    { name: 'supplyBaseGeographicDataId', type: 'string', isFK: true }
                ]
            },
            {
                id: 'Supplier',
                name: 'Supplier',
                area: 'material_supply_chain',
                description: '🤝 External suppliers in supply chain',
                fields: [
                    { name: 'supplierId', type: 'string', isPK: true, required: true },
                    { name: 'supplierName', type: 'string', required: true },
                    { name: 'address', type: 'string' },
                    { name: 'certificateCode', type: 'string' },
                    { name: 'claim', type: 'string' },
                    { name: 'supplierType', type: 'string' },
                    { name: 'supplierGeographicDataId', type: 'string', isFK: true }
                ]
            },
            {
                id: 'Customer',
                name: 'Customer',
                area: 'material_supply_chain',
                description: '🏭 End customers and buyers',
                fields: [
                    { name: 'customerId', type: 'string', isPK: true, required: true },
                    { name: 'customerName', type: 'string', required: true },
                    { name: 'address', type: 'string' },
                    { name: 'customerGeographicDataId', type: 'string', isFK: true }
                ]
            },
            {
                id: 'Transaction',
                name: 'Transaction',
                area: 'transaction_management',
                description: '💰 Business transactions between organizations',
                fields: [
                    { name: 'transactionId', type: 'string', isPK: true, required: true },
                    { name: 'supplyingOrganizationId', type: 'string', isFK: true, required: true },
                    { name: 'customerOrganizationId', type: 'string', isFK: true, required: true },
                    { name: 'transactionDate', type: 'date', required: true },
                    { name: 'salesDocumentId', type: 'string', isFK: true },
                    { name: 'contractValue', type: 'decimal' },
                    { name: 'contractCurrency', type: 'string' },
                    { name: 'contractTerms', type: 'string' },
                    { name: 'paymentTerms', type: 'string' },
                    { name: 'transactionStatus', type: 'string' },
                    { name: 'transactionGeographicDataId', type: 'string', isFK: true },
                    { name: 'brokerOrganizationId', type: 'string', isFK: true }
                ]
            },
            {
                id: 'TransactionBatch',
                name: 'TransactionBatch',
                area: 'transaction_management',
                description: '📦 Physical batches within transactions',
                fields: [
                    { name: 'transactionBatchId', type: 'string', isPK: true, required: true },
                    { name: 'transactionId', type: 'string', isFK: true, required: true },
                    { name: 'productionBatchId', type: 'string', isFK: true },
                    { name: 'quantity', type: 'decimal', required: true },
                    { name: 'quantityUnit', type: 'string' },
                    { name: 'traceableUnitIds', type: 'string[]' },
                    { name: 'claimId', type: 'string', isFK: true },
                    { name: 'additionalClaimIds', type: 'string[]' },
                    { name: 'speciesComposition', type: 'string[]' },
                    { name: 'qualityGrade', type: 'string' },
                    { name: 'processingHistoryIds', type: 'string[]' },
                    { name: 'reconciliationStatus', type: 'string' },
                    { name: 'measurementRecordIds', type: 'string[]' }
                ]
            },
            {
                id: 'SalesDeliveryDocument',
                name: 'SalesDeliveryDocument',
                area: 'transaction_management',
                description: '📄 Sales and delivery documentation',
                fields: [
                    { name: 'documentId', type: 'string', isPK: true, required: true },
                    { name: 'dateIssued', type: 'date', required: true },
                    { name: 'buyerName', type: 'string', required: true },
                    { name: 'buyerAddress', type: 'string' },
                    { name: 'sellerName', type: 'string', required: true },
                    { name: 'sellerAddress', type: 'string' },
                    { name: 'productDescription', type: 'string', required: true },
                    { name: 'quantity', type: 'decimal', required: true },
                    { name: 'transactionId', type: 'string', isFK: true },
                    { name: 'certificateCode', type: 'string' },
                    { name: 'transportReference', type: 'string' }
                ]
            },
            {
                id: 'Claim',
                name: 'Claim',
                area: 'sustainability_claims',
                description: '🏆 Sustainability claims and validation',
                fields: [
                    { name: 'claimId', type: 'string', isPK: true, required: true },
                    { name: 'traceableUnitId', type: 'string', isFK: true, required: true },
                    { name: 'claimType', type: 'string', required: true },
                    { name: 'certificationSchemeId', type: 'string', isFK: true },
                    { name: 'statement', type: 'string', required: true },
                    { name: 'validated', type: 'boolean', required: true },
                    { name: 'validatedBy', type: 'string' },
                    { name: 'validationDate', type: 'datetime' },
                    { name: 'applicableSpecies', type: 'string[]' },
                    { name: 'claimPercentage', type: 'decimal' },
                    { name: 'claimScope', type: 'string' },
                    { name: 'evidenceDocumentId', type: 'string' },
                    { name: 'claimExpiry', type: 'datetime' }
                ]
            },
            {
                id: 'GeographicData',
                name: 'GeographicData',
                area: 'geographic_location',
                description: '🗺️ Spatial data and geographic references',
                fields: [
                    { name: 'geographicDataId', type: 'string', isPK: true, required: true },
                    { name: 'geoJsonData', type: 'json', required: true },
                    { name: 'dataType', type: 'string' },
                    { name: 'description', type: 'string' },
                    { name: 'lastUpdated', type: 'datetime' }
                ]
            },
            {
                id: 'SupplyBaseReport',
                name: 'SupplyBaseReport',
                area: 'reporting_compliance',
                description: '📊 Supply base reports and documentation',
                fields: [
                    { name: 'sbrId', type: 'string', isPK: true, required: true },
                    { name: 'organizationId', type: 'string', isFK: true, required: true },
                    { name: 'preparationDate', type: 'date', required: true },
                    { name: 'supplyBaseSummary', type: 'string' },
                    { name: 'sourcingPractices', type: 'string' },
                    { name: 'sustainabilityMeasures', type: 'string' },
                    { name: 'publicationUrl', type: 'string' },
                    { name: 'reportGeographicDataId', type: 'string', isFK: true }
                ]
            },
            {
                id: 'VerificationStatement',
                name: 'VerificationStatement',
                area: 'reporting_compliance',
                description: '✅ Third-party verification statements',
                fields: [
                    { name: 'statementId', type: 'string', isPK: true, required: true },
                    { name: 'verificationDate', type: 'date', required: true },
                    { name: 'issuingBody', type: 'string', required: true },
                    { name: 'scope', type: 'string' },
                    { name: 'transactionBatchId', type: 'string', isFK: true }
                ]
            },
            {
                id: 'Audit',
                name: 'Audit',
                area: 'reporting_compliance',
                description: '🔍 Certification audits and findings',
                fields: [
                    { name: 'auditId', type: 'string', isPK: true, required: true },
                    { name: 'auditType', type: 'string', required: true },
                    { name: 'auditDate', type: 'date', required: true },
                    { name: 'organizationId', type: 'string', isFK: true, required: true },
                    { name: 'cbId', type: 'string', isFK: true },
                    { name: 'findings', type: 'string' },
                    { name: 'reportUrl', type: 'string' },
                    { name: 'auditGeographicDataId', type: 'string', isFK: true }
                ]
            },
            {
                id: 'ProductGroup',
                name: 'ProductGroup',
                area: 'analytics_data',
                description: '📋 Product categorization and grouping',
                fields: [
                    { name: 'productGroupId', type: 'string', isPK: true, required: true },
                    { name: 'productGroupName', type: 'string', required: true },
                    { name: 'productCategory', type: 'string' },
                    { name: 'classification', type: 'string' },
                    { name: 'description', type: 'string', required: true },
                    { name: 'typicalUses', type: 'string[]' },
                    { name: 'qualityStandards', type: 'string[]' },
                    { name: 'certificationRequirements', type: 'string[]' },
                    { name: 'regulatoryClassification', type: 'string' },
                    { name: 'lastUpdated', type: 'datetime' }
                ]
            },
            {
                id: 'MassBalanceAccount',
                name: 'MassBalanceAccount',
                area: 'analytics_data',
                description: '⚖️ Mass balance accounting system',
                fields: [
                    { name: 'accountId', type: 'string', isPK: true, required: true },
                    { name: 'organizationId', type: 'string', isFK: true, required: true },
                    { name: 'productGroupId', type: 'string', isFK: true, required: true },
                    { name: 'periodInputs', type: 'decimal' },
                    { name: 'periodOutputs', type: 'decimal' },
                    { name: 'currentBalance', type: 'decimal' },
                    { name: 'balancingPeriod', type: 'string' },
                    { name: 'conversionFactors', type: 'decimal' }
                ]
            },
            {
                id: 'EnergyCarbonData',
                name: 'EnergyCarbonData',
                area: 'analytics_data',
                description: '🌡️ Energy and carbon footprint data',
                fields: [
                    { name: 'energyCarbonDataId', type: 'string', isPK: true, required: true },
                    { name: 'dataType', type: 'string', required: true },
                    { name: 'value', type: 'decimal', required: true },
                    { name: 'unit', type: 'string', required: true },
                    { name: 'source', type: 'string', required: true },
                    { name: 'measurementMethod', type: 'string' },
                    { name: 'traceableUnitId', type: 'string', isFK: true },
                    { name: 'measurementRecordId', type: 'string', isFK: true },
                    { name: 'measurementTimestamp', type: 'datetime' },
                    { name: 'measurementGeographicDataId', type: 'string', isFK: true },
                    { name: 'temperatureConditions', type: 'decimal' },
                    { name: 'humidityConditions', type: 'decimal' }
                ]
            },
            {
                id: 'Operator',
                name: 'Operator',
                area: 'personnel',
                description: '👤 Personnel and operators in supply chain',
                fields: [
                    { name: 'operatorId', type: 'string', isPK: true, required: true },
                    { name: 'organizationId', type: 'string', isFK: true, required: true },
                    { name: 'operatorName', type: 'string', required: true },
                    { name: 'employeeId', type: 'string' },
                    { name: 'operatorType', type: 'string' },
                    { name: 'certifications', type: 'string[]' },
                    { name: 'equipmentAuthorizations', type: 'string[]' },
                    { name: 'contactInfo', type: 'string' },
                    { name: 'isActive', type: 'boolean', required: true },
                    { name: 'hireDate', type: 'date' },
                    { name: 'skillsQualifications', type: 'string[]' },
                    { name: 'supervisorOperatorId', type: 'string', isFK: true }
                ]
            }
        ].map(entity => ({
            ...entity,
            x: entityPositions[entity.id]?.x || 1600,
            y: entityPositions[entity.id]?.y || 1000
        }));

        // Relationships based on schema definitions
        const relationships = [
            // 🔵 ORGANIZATIONAL FOUNDATION RELATIONSHIPS
            { from: 'Organization', to: 'Certificate', label: 'has', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'Certificate', to: 'CertificationScheme', label: 'certifies_against', type: 'non-identifying', fromCard: 'many', toCard: 'one' },
            { from: 'Certificate', to: 'CertificationBody', label: 'issued_by', type: 'non-identifying', fromCard: 'many', toCard: 'one' },
            { from: 'CertificationBody', to: 'Audit', label: 'conducts', type: 'identifying', fromCard: 'one', toCard: 'many' },

            // 🟢 CORE TRACEABILITY RELATIONSHIPS - Primary Data Flow
            { from: 'TraceableUnit', to: 'SpeciesComponent', label: 'contains_species', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'TraceableUnit', to: 'MaterialProcessing', label: 'undergoes_processing', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'TraceableUnit', to: 'ProcessingHistory', label: 'has_processing_timeline', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'MaterialProcessing', to: 'MeasurementRecord', label: 'generates_measurements', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'MaterialProcessing', to: 'ProcessingHistory', label: 'documented_by', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'ProcessingHistory', to: 'ProcessingHistory', label: 'forms_processing_chain', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'TraceableUnit', to: 'BiometricIdentifier', label: 'identified_by', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'TraceableUnit', to: 'DataReconciliation', label: 'reconciled_through', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'TraceableUnit', to: 'LocationHistory', label: 'has_location_history', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'TraceableUnit', to: 'Claim', label: 'has_sustainability_claims', type: 'identifying', fromCard: 'one', toCard: 'one' },
            { from: 'TrackingPoint', to: 'MeasurementRecord', label: 'captures_at', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'TrackingPoint', to: 'BiometricIdentifier', label: 'scanned_at', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'TraceableUnit', to: 'TraceableUnit', label: 'parent_child_relationship', type: 'non-identifying', fromCard: 'one', toCard: 'many' },

            // 🟤 MATERIAL & SUPPLY CHAIN RELATIONSHIPS
            { from: 'Material', to: 'TraceableUnit', label: 'material_type_reference', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'Organization', to: 'SupplyBase', label: 'manages_supply_base', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'SupplyBase', to: 'TraceableUnit', label: 'originates_tru', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'Organization', to: 'Supplier', label: 'sources_from', type: 'non-identifying', fromCard: 'many', toCard: 'many' },
            { from: 'Organization', to: 'Customer', label: 'sells_to', type: 'non-identifying', fromCard: 'many', toCard: 'many' },

            // 🟠 TRANSACTION MANAGEMENT RELATIONSHIPS
            { from: 'Transaction', to: 'TraceableUnit', label: 'includes_tru', type: 'non-identifying', fromCard: 'many', toCard: 'many' },
            { from: 'TransactionBatch', to: 'TraceableUnit', label: 'contains_tru', type: 'non-identifying', fromCard: 'many', toCard: 'many' },
            { from: 'Transaction', to: 'TransactionBatch', label: 'contains', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'Transaction', to: 'SalesDeliveryDocument', label: 'documented_by', type: 'identifying', fromCard: 'one', toCard: 'one' },
            { from: 'TransactionBatch', to: 'VerificationStatement', label: 'verified_by', type: 'non-identifying', fromCard: 'many', toCard: 'one' },
            { from: 'Transaction', to: 'DataReconciliation', label: 'validated_by', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'Organization', to: 'Transaction', label: 'creates', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'Customer', to: 'Transaction', label: 'receives', type: 'non-identifying', fromCard: 'one', toCard: 'many' },

            // 🟡 SUSTAINABILITY & CLAIMS RELATIONSHIPS
            { from: 'Claim', to: 'CertificationScheme', label: 'references_scheme', type: 'non-identifying', fromCard: 'many', toCard: 'one' },
            { from: 'Claim', to: 'TraceableUnit', label: 'inherited_from_parent_tru', type: 'non-identifying', fromCard: 'many', toCard: 'many' },

            // 🟣 GEOGRAPHIC & LOCATION RELATIONSHIPS - Spatial Integration
            { from: 'GeographicData', to: 'TraceableUnit', label: 'provides_harvest_location', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'GeographicData', to: 'TraceableUnit', label: 'provides_current_location', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'GeographicData', to: 'Organization', label: 'defines_operational_area', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'GeographicData', to: 'Transaction', label: 'locates_transaction', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'GeographicData', to: 'SupplyBase', label: 'defines_boundaries', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'GeographicData', to: 'Supplier', label: 'locates_supplier', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'GeographicData', to: 'Customer', label: 'locates_customer', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'LocationHistory', to: 'GeographicData', label: 'references_location', type: 'non-identifying', fromCard: 'many', toCard: 'one' },
            { from: 'LocationHistory', to: 'MaterialProcessing', label: 'triggered_by_processing', type: 'non-identifying', fromCard: 'many', toCard: 'one' },
            { from: 'LocationHistory', to: 'TraceableUnit', label: 'tracks_movement_of', type: 'identifying', fromCard: 'many', toCard: 'one' },

            // 🔴 REPORTING & COMPLIANCE RELATIONSHIPS
            { from: 'Organization', to: 'SupplyBaseReport', label: 'prepares', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'Audit', to: 'Organization', label: 'audits', type: 'non-identifying', fromCard: 'many', toCard: 'one' },
            
            // LCFS COMPLIANCE RELATIONSHIPS
            { from: 'Transaction', to: 'LCFSPathway', label: 'uses_pathway', type: 'non-identifying', fromCard: 'many', toCard: 'one' },
            { from: 'LCFSReporting', to: 'Organization', label: 'submitted_by', type: 'identifying', fromCard: 'many', toCard: 'one' },
            { from: 'LCFSReporting', to: 'Transaction', label: 'includes', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'LCFSPathway', to: 'EnergyCarbonData', label: 'has_carbon_data', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'LCFSReporting', to: 'LCFSPathway', label: 'summarizes_pathway', type: 'non-identifying', fromCard: 'one', toCard: 'many' },

            // ⚫ ANALYTICS & DATA MANAGEMENT RELATIONSHIPS
            { from: 'Organization', to: 'MassBalanceAccount', label: 'manages', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'Organization', to: 'ProductGroup', label: 'defines', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'MassBalanceAccount', to: 'ProductGroup', label: 'tracks', type: 'non-identifying', fromCard: 'many', toCard: 'one' },
            { from: 'ProductGroup', to: 'Material', label: 'categorizes', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'Certificate', to: 'ProductGroup', label: 'certifies', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'Material', to: 'EnergyCarbonData', label: 'characterized_by', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'TransactionBatch', to: 'EnergyCarbonData', label: 'associated_with', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'TraceableUnit', to: 'EnergyCarbonData', label: 'characterized_by', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'MeasurementRecord', to: 'EnergyCarbonData', label: 'generates_moisture_data', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'ProcessingHistory', to: 'EnergyCarbonData', label: 'tracks_moisture_changes', type: 'non-identifying', fromCard: 'one', toCard: 'many' },

            // 🟢 ORGANIZATIONAL-TRU MANAGEMENT RELATIONSHIPS
            { from: 'Organization', to: 'TrackingPoint', label: 'operates', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'Organization', to: 'TraceableUnit', label: 'manages', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'Organization', to: 'Operator', label: 'employs', type: 'identifying', fromCard: 'one', toCard: 'many' },
            { from: 'Operator', to: 'MaterialProcessing', label: 'performs_processing', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'Operator', to: 'ProcessingHistory', label: 'documents_processing', type: 'non-identifying', fromCard: 'one', toCard: 'many' },
            { from: 'Operator', to: 'LocationHistory', label: 'manages_movement', type: 'non-identifying', fromCard: 'one', toCard: 'many' }
        ];

        // D3 Setup with zoom and pan
        const svg = d3.select('#erd-svg');
        const tooltip = d3.select('#tooltip');
        const container = d3.select('#svg-container');
        
        // Add SVG definitions for icons
        const defs = svg.append('defs');
        
        // GitHub discussion icon definition (chat bubble with GitHub mark)
        defs.append('g')
            .attr('id', 'github-discussion-icon')
            .html(`
                <rect x="1" y="2" width="10" height="7" rx="1.5" ry="1.5" fill="currentColor" opacity="0.9"/>
                <path d="M3 11 L6 9 L9 11" fill="currentColor" opacity="0.9"/>
                <circle cx="4" cy="5.5" r="0.8" fill="white"/>
                <circle cx="8" cy="5.5" r="0.8" fill="white"/>
                <path d="M5.5 6.8 Q6 7.3 6.5 6.8" stroke="white" stroke-width="0.4" fill="none"/>
            `);
        
        // Create main group for zoom/pan transforms
        const g = svg.append('g').attr('class', 'main-group');
        
        // Zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 3])
            .on('zoom', handleZoom);
        
        // Apply zoom to SVG
        svg.call(zoom);
        
        // Track zoom level for indicator
        let currentZoom = 1;
        
        function handleZoom(event) {
            const { transform } = event;
            g.attr('transform', transform);
            currentZoom = transform.k;
            updateZoomIndicator();
            
            // Update cursor during pan
            if (event.sourceEvent && event.sourceEvent.type === 'mousemove') {
                container.classed('panning', true);
            } else {
                container.classed('panning', false);
            }
        }
        
        function updateZoomIndicator() {
            d3.select('#zoom-indicator').text(`${Math.round(currentZoom * 100)}%`);
        }

        // Zoom control functions
        function zoomIn() {
            svg.transition().duration(300).call(zoom.scaleBy, 1.5);
        }
        
        function zoomOut() {
            svg.transition().duration(300).call(zoom.scaleBy, 1 / 1.5);
        }
        
        function resetZoom() {
            svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity);
        }
        
        function fitToScreen() {
            // Debug: Log some entity positions
            console.log('Sample entity positions:');
            entities.slice(0, 5).forEach(e => {
                console.log(`${e.name}: (${e.x}, ${e.y})`);
            });
            
            // Calculate bounding box of all entities
            const bounds = {
                minX: Math.min(...entities.map(e => e.x)),
                maxX: Math.max(...entities.map(e => e.x + config.entityWidth)),
                minY: Math.min(...entities.map(e => e.y)),
                maxY: Math.max(...entities.map(e => e.y + config.headerHeight + (e.fields.length * config.entityFieldHeight) + (config.entityPadding * 2) + 4))
            };
            
            // Check actual browser viewport size FIRST
            const svgElement = document.getElementById('erd-svg');
            const svgContainer = svgElement.parentElement;
            const actualWidth = svgContainer.clientWidth;
            const actualHeight = svgContainer.clientHeight;
            
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;
            
            // Use actual browser viewport size instead of config size
            const calculatedScale = Math.min(actualWidth / width, actualHeight / height) * 0.85;
            const scale = Math.max(calculatedScale, 0.1); // Ensure minimum 0.1x zoom, no maximum cap
            
            console.log('Fit to screen - Bounds:', bounds);
            console.log('Fit to screen - Calculated scale:', calculatedScale, 'Final scale:', scale);
            
            // Use the actual bounds center to fit ALL entities
            const centerX = (bounds.minX + bounds.maxX) / 2;
            const centerY = (bounds.minY + bounds.maxY) / 2;
            
            console.log('Fit to screen - Content center:', centerX, centerY);
            
            console.log('Fit to screen - Canvas size:', config.width, 'x', config.height);
            console.log('Fit to screen - SVG element size:', actualWidth, 'x', actualHeight);
            console.log('Fit to screen - Browser window size:', window.innerWidth, 'x', window.innerHeight);
            console.log('Fit to screen - SVG container size:', svgElement.parentElement.clientWidth, 'x', svgElement.parentElement.clientHeight);
            console.log('Fit to screen - Content size:', width, 'x', height);
            
            const translateX = actualWidth / 2 - centerX * scale;
            const translateY = actualHeight / 2 - centerY * scale;
            
            console.log('Fit to screen - Translation:', translateX, translateY);
            
            // Calculate where the bounds will appear on screen
            const screenMinX = bounds.minX * scale + translateX;
            const screenMinY = bounds.minY * scale + translateY;
            const screenMaxX = bounds.maxX * scale + translateX;
            const screenMaxY = bounds.maxY * scale + translateY;
            
            console.log('Content will appear on screen from:', screenMinX, screenMinY, 'to', screenMaxX, screenMaxY);
            console.log('Screen viewport is 0,0 to', config.width, config.height);
            
            // Add visual indicators at the calculated bounds
            g.selectAll('.debug-bounds').remove();
            g.append('rect')
                .attr('class', 'debug-bounds')
                .attr('x', bounds.minX)
                .attr('y', bounds.minY)
                .attr('width', bounds.maxX - bounds.minX)
                .attr('height', bounds.maxY - bounds.minY)
                .attr('fill', 'none')
                .attr('stroke', 'red')
                .attr('stroke-width', 3)
                .attr('stroke-dasharray', '10,5');
                
            // Remove debug bounds after 3 seconds
            setTimeout(() => g.selectAll('.debug-bounds').remove(), 3000);
            
            svg.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity.translate(translateX, translateY).scale(scale)
            );
        }

        // Enhanced connection points that connect to specific fields
        function getConnectionPoint(entity, targetEntity, relationship, isFromEntity = true) {
            const entityHeight = config.headerHeight + (entity.fields.length * config.entityFieldHeight) + (config.entityPadding * 2) + 4;
            
            // Find the relevant field for this relationship
            let fieldIndex = -1;
            let targetFieldName = null;
            
            if (isFromEntity) {
                // Look for FK field that references the target entity
                const targetEntityName = targetEntity.id;
                const possibleFKNames = [
                    targetEntityName.toLowerCase() + 'Id',
                    targetEntityName.charAt(0).toLowerCase() + targetEntityName.slice(1) + 'Id',
                    // Common patterns
                    'organizationId', 'traceableUnitId', 'geographicDataId', 'operatorId', 
                    'materialTypeId', 'certificateCode', 'cbId', 'schemeId'
                ];
                
                fieldIndex = entity.fields.findIndex(field => 
                    field.isFK && possibleFKNames.some(name => field.name.includes(name.replace('Id', '')))
                );
            } else {
                // For target entity, use primary key
                fieldIndex = entity.fields.findIndex(field => field.isPK);
            }
            
            // Fallback to appropriate edge if no specific field found
            if (fieldIndex === -1) {
                return getEntityEdgePoint(entity, targetEntity);
            }
            
            // Calculate field position
            const fieldY = entity.y + config.headerHeight + config.entityPadding + (fieldIndex * config.entityFieldHeight) + 6;
            
            // Determine which side of the entity to connect to
            const entityCenter = {
                x: entity.x + (entity.actualWidth || config.entityWidth) / 2,
                y: entity.y + entityHeight / 2
            };
            
            const targetCenter = {
                x: targetEntity.x + (targetEntity.actualWidth || config.entityWidth) / 2,
                y: targetEntity.y + (config.headerHeight + (targetEntity.fields.length * config.entityFieldHeight) + (config.entityPadding * 2) + 4) / 2
            };
            
            let connectionX;
            if (targetCenter.x > entityCenter.x) {
                // Target is to the right, connect from right edge
                connectionX = entity.x + (entity.actualWidth || config.entityWidth);
            } else {
                // Target is to the left, connect from left edge
                connectionX = entity.x;
            }
            
            return {
                x: connectionX,
                y: fieldY,
                fieldIndex: fieldIndex,
                fieldName: entity.fields[fieldIndex]?.name
            };
        }
        
        function getEntityEdgePoint(entity, targetEntity) {
            const entityHeight = config.headerHeight + (entity.fields.length * config.entityFieldHeight) + (config.entityPadding * 2) + 4;
            const targetHeight = config.headerHeight + (targetEntity.fields.length * config.entityFieldHeight) + (config.entityPadding * 2) + 4;
            
            const entityCenter = {
                x: entity.x + (entity.actualWidth || config.entityWidth) / 2,
                y: entity.y + entityHeight / 2
            };
            
            const targetCenter = {
                x: targetEntity.x + (targetEntity.actualWidth || config.entityWidth) / 2,
                y: targetEntity.y + targetHeight / 2
            };
            
            const dx = targetCenter.x - entityCenter.x;
            const dy = targetCenter.y - entityCenter.y;
            
            // Determine which edge to connect to
            if (Math.abs(dx) > Math.abs(dy)) {
                // Horizontal connection
                if (dx > 0) {
                    return { x: entity.x + (entity.actualWidth || config.entityWidth), y: entityCenter.y };
                } else {
                    return { x: entity.x, y: entityCenter.y };
                }
            } else {
                // Vertical connection
                if (dy > 0) {
                    return { x: entityCenter.x, y: entity.y + entityHeight };
                } else {
                    return { x: entityCenter.x, y: entity.y };
                }
            }
        }

        // Check if a point is inside an entity's bounding box
        function isPointInsideEntity(point, entity) {
            const entityHeight = config.headerHeight + (entity.fields.length * config.entityFieldHeight) + (config.entityPadding * 2) + 4;
            return point.x >= entity.x - 10 && 
                   point.x <= entity.x + (entity.actualWidth || config.entityWidth) + 10 && 
                   point.y >= entity.y - 10 && 
                   point.y <= entity.y + entityHeight + 10;
        }

        // Check if a line segment intersects with an entity
        function lineIntersectsEntity(p1, p2, entity, excludeEntities = []) {
            if (excludeEntities.includes(entity.id)) return false;
            
            const entityHeight = config.headerHeight + (entity.fields.length * config.entityFieldHeight) + (config.entityPadding * 2) + 4;
            const buffer = 15; // Add buffer around entities
            
            const entityBounds = {
                left: entity.x - buffer,
                right: entity.x + (entity.actualWidth || config.entityWidth) + buffer,
                top: entity.y - buffer,
                bottom: entity.y + entityHeight + buffer
            };
            
            // Check if line segment intersects the entity rectangle
            return lineSegmentIntersectsRect(p1, p2, entityBounds);
        }

        // Find the best position for a relationship label to avoid entity overlaps
        function findBestLabelPosition(path, label, fromEntity, toEntity) {
            const pathLength = path.node().getTotalLength();
            const excludeEntities = [fromEntity.id, toEntity.id];
            const textWidth = label.length * 4.5;
            const textHeight = 14;
            
            // Try multiple positions along the path
            const positions = [0.5, 0.4, 0.6, 0.3, 0.7, 0.25, 0.75];
            
            for (const pos of positions) {
                const testPoint = path.node().getPointAtLength(pathLength * pos);
                
                // Check if this position would overlap with any entity
                const labelBounds = {
                    left: testPoint.x - textWidth/2 - 3,
                    right: testPoint.x + textWidth/2 + 3,
                    top: testPoint.y - 7,
                    bottom: testPoint.y + 7
                };
                
                let hasOverlap = false;
                for (const entity of entities) {
                    if (excludeEntities.includes(entity.id)) continue;
                    
                    const entityHeight = config.headerHeight + (entity.fields.length * config.entityFieldHeight) + (config.entityPadding * 2) + 4;
                    const entityBounds = {
                        left: entity.x - 10,
                        right: entity.x + (entity.actualWidth || config.entityWidth) + 10,
                        top: entity.y - 10,
                        bottom: entity.y + entityHeight + 10
                    };
                    
                    if (rectanglesOverlap(labelBounds, entityBounds)) {
                        hasOverlap = true;
                        break;
                    }
                }
                
                if (!hasOverlap) {
                    return testPoint;
                }
            }
            
            // If no good position found, return the midpoint
            return path.node().getPointAtLength(pathLength / 2);
        }
        
        // Check if two rectangles overlap
        function rectanglesOverlap(rect1, rect2) {
            return !(rect1.right < rect2.left || 
                     rect2.right < rect1.left || 
                     rect1.bottom < rect2.top || 
                     rect2.bottom < rect1.top);
        }
        
        // Determine if a label should be displayed to reduce clutter
        function shouldDisplayLabel(labelPoint, rel, fromEntity, toEntity) {
            // TraceableUnit has massive clutter - be very aggressive about hiding labels
            const isTraceableUnitRelationship = fromEntity.id === 'TraceableUnit' || toEntity.id === 'TraceableUnit';
            
            if (isTraceableUnitRelationship) {
                // Only show the most critical TraceableUnit relationships
                const criticalTruLabels = ['material_type_reference', 'includes_tru', 'originates_tru'];
                if (!criticalTruLabels.includes(rel.label)) {
                    return false; // Hide all other TraceableUnit relationship labels
                }
            }
            
            // Other central entities - be selective  
            const centralEntities = ['Material', 'Organization', 'Transaction'];
            const isCentralRelationship = centralEntities.includes(fromEntity.id) || centralEntities.includes(toEntity.id);
            
            // Always show labels for important non-TRU relationships
            const importantLabels = ['manages_supply_base', 'sources_from', 'sells_to'];
            if (importantLabels.includes(rel.label)) {
                return true;
            }
            
            // In central areas, be very selective
            if (isCentralRelationship) {
                return rel.label.length <= 12 || labelPoint.y < 150 || labelPoint.y > 900;
            }
            
            return true;
        }
        
        // Generate control points for central area routes with wider avoidance
        function generateCentralAvoidanceRoute(fromPoint, toPoint, fromEntity, toEntity, excludeEntities) {
            const dx = toPoint.x - fromPoint.x;
            const dy = toPoint.y - fromPoint.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // TraceableUnit needs MASSIVE avoidance zones
            const isTraceableUnitRoute = fromEntity.id === 'TraceableUnit' || toEntity.id === 'TraceableUnit';
            
            // Use much larger offsets for TraceableUnit routes
            let offset;
            if (isTraceableUnitRoute) {
                offset = Math.min(distance * 0.7, 250); // Much larger offset for TRU
            } else {
                offset = Math.min(distance * 0.4, 150); // Normal offset for others
            }
            
            // Get TraceableUnit position for exclusion zone
            const truEntity = entities.find(e => e.id === 'TraceableUnit');
            const truCenterX = truEntity ? truEntity.x + 150 : 600;
            const truCenterY = truEntity ? truEntity.y + 100 : 400;
            
            // Create large exclusion zone around TraceableUnit
            const exclusionRadius = isTraceableUnitRoute ? 200 : 100;
            
            let control1, control2;
            
            if (isTraceableUnitRoute) {
                // For TraceableUnit routes, use extreme avoidance
                const angle = Math.atan2(dy, dx);
                const perpAngle = angle + Math.PI / 2;
                
                // Route far around TraceableUnit
                const avoidanceDistance = 300;
                const xAvoid = Math.cos(perpAngle) * avoidanceDistance;
                const yAvoid = Math.sin(perpAngle) * avoidanceDistance;
                
                control1 = {
                    x: fromPoint.x + dx * 0.2 + xAvoid,
                    y: fromPoint.y + dy * 0.2 + yAvoid
                };
                control2 = {
                    x: toPoint.x - dx * 0.2 + xAvoid,
                    y: toPoint.y - dy * 0.2 + yAvoid
                };
            } else {
                // Standard avoidance for non-TRU routes
                if (Math.abs(dx) > Math.abs(dy)) {
                    // Horizontal dominant - route above or below
                    const routeAbove = fromPoint.y < truCenterY || toPoint.y < truCenterY;
                    const yOffset = routeAbove ? -offset : offset;
                    
                    control1 = { 
                        x: fromPoint.x + dx * 0.3, 
                        y: fromPoint.y + yOffset 
                    };
                    control2 = { 
                        x: toPoint.x - dx * 0.3, 
                        y: toPoint.y + yOffset 
                    };
                } else {
                    // Vertical dominant - route left or right
                    const routeLeft = fromPoint.x < truCenterX || toPoint.x < truCenterX;
                    const xOffset = routeLeft ? -offset : offset;
                    
                    control1 = { 
                        x: fromPoint.x + xOffset, 
                        y: fromPoint.y + dy * 0.3 
                    };
                    control2 = { 
                        x: toPoint.x + xOffset, 
                        y: toPoint.y - dy * 0.3 
                    };
                }
            }
            
            return [fromPoint, control1, control2, toPoint];
        }
        
        // Enhanced simple control points with central awareness
        function generateSimpleControlPoints(fromPoint, toPoint, isCentralRoute = false) {
            const dx = toPoint.x - fromPoint.x;
            const dy = toPoint.y - fromPoint.y;
            
            // Use smaller curves for non-central routes, larger for central
            const curveIntensity = isCentralRoute ? 0.4 : 0.3;
            
            return [
                fromPoint,
                { 
                    x: fromPoint.x + dx * curveIntensity, 
                    y: fromPoint.y + dy * curveIntensity 
                },
                { 
                    x: toPoint.x - dx * curveIntensity, 
                    y: toPoint.y - dy * curveIntensity 
                },
                toPoint
            ];
        }

        function lineSegmentIntersectsRect(p1, p2, rect) {
            // Check if either endpoint is inside the rectangle
            if ((p1.x >= rect.left && p1.x <= rect.right && p1.y >= rect.top && p1.y <= rect.bottom) ||
                (p2.x >= rect.left && p2.x <= rect.right && p2.y >= rect.top && p2.y <= rect.bottom)) {
                return true;
            }
            
            // Check intersection with each edge of the rectangle
            const edges = [
                { p1: { x: rect.left, y: rect.top }, p2: { x: rect.right, y: rect.top } },     // top
                { p1: { x: rect.right, y: rect.top }, p2: { x: rect.right, y: rect.bottom } }, // right
                { p1: { x: rect.right, y: rect.bottom }, p2: { x: rect.left, y: rect.bottom } }, // bottom
                { p1: { x: rect.left, y: rect.bottom }, p2: { x: rect.left, y: rect.top } }     // left
            ];
            
            return edges.some(edge => lineSegmentsIntersect(p1, p2, edge.p1, edge.p2));
        }

        function lineSegmentsIntersect(p1, q1, p2, q2) {
            function onSegment(p, q, r) {
                return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) &&
                       q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
            }
            
            function orientation(p, q, r) {
                const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
                if (val === 0) return 0;
                return (val > 0) ? 1 : 2;
            }
            
            const o1 = orientation(p1, q1, p2);
            const o2 = orientation(p1, q1, q2);
            const o3 = orientation(p2, q2, p1);
            const o4 = orientation(p2, q2, q1);
            
            if (o1 !== o2 && o3 !== o4) return true;
            if (o1 === 0 && onSegment(p1, p2, q1)) return true;
            if (o2 === 0 && onSegment(p1, q2, q1)) return true;
            if (o3 === 0 && onSegment(p2, p1, q2)) return true;
            if (o4 === 0 && onSegment(p2, q1, q2)) return true;
            
            return false;
        }

        // Find a route around entities with enhanced avoidance and central area awareness
        function findRouteAroundEntities(fromPoint, toPoint, fromEntity, toEntity, relationship) {
            const excludeEntities = [fromEntity.id, toEntity.id];
            const centralEntities = ['TraceableUnit', 'Material', 'Organization', 'Transaction'];
            const isCentralRoute = centralEntities.includes(fromEntity.id) || centralEntities.includes(toEntity.id);
            
            // Check for direct path first
            const directObstructions = entities.filter(entity => 
                !excludeEntities.includes(entity.id) && 
                lineIntersectsEntity(fromPoint, toPoint, entity, excludeEntities)
            );
            
            if (directObstructions.length === 0) {
                return generateSimpleControlPoints(fromPoint, toPoint, isCentralRoute);
            }
            
            // For central routes, use wider avoidance paths
            if (isCentralRoute) {
                return generateCentralAvoidanceRoute(fromPoint, toPoint, fromEntity, toEntity, excludeEntities);
            }
            
            // Enhanced routing with multiple waypoints for complex scenarios
            const routes = [];
            
            // Strategy 1: High arc over obstructions
            const highRoute = createHighArcRoute(fromPoint, toPoint, directObstructions, excludeEntities);
            if (highRoute) routes.push(highRoute);
            
            // Strategy 2: Low arc under obstructions
            const lowRoute = createLowArcRoute(fromPoint, toPoint, directObstructions, excludeEntities);
            if (lowRoute) routes.push(lowRoute);
            
            // Strategy 3: Left detour
            const leftRoute = createLeftDetourRoute(fromPoint, toPoint, directObstructions, excludeEntities);
            if (leftRoute) routes.push(leftRoute);
            
            // Strategy 4: Right detour
            const rightRoute = createRightDetourRoute(fromPoint, toPoint, directObstructions, excludeEntities);
            if (rightRoute) routes.push(rightRoute);
            
            // Strategy 5: Complex multi-waypoint routing
            const complexRoute = createComplexRoute(fromPoint, toPoint, directObstructions, excludeEntities);
            if (complexRoute) routes.push(complexRoute);
            
            if (routes.length === 0) {
                console.log(`No clear route found for ${fromEntity.id} -> ${toEntity.id}, using direct path`);
                return generateSimpleControlPoints(fromPoint, toPoint);
            }
            
            // Choose the route with minimum total path length
            const bestRoute = routes.reduce((best, current) => {
                const bestLength = calculateRouteLength(best);
                const currentLength = calculateRouteLength(current);
                return currentLength < bestLength ? current : best;
            });
            
            console.log(`Found route for ${fromEntity.id} -> ${toEntity.id} with ${bestRoute.length} waypoints`);
            return bestRoute;
        }
        
        function createHighArcRoute(fromPoint, toPoint, obstructions, excludeEntities) {
            const minY = Math.min(...obstructions.map(e => e.y)) - 50; // Higher clearance
            const midX = (fromPoint.x + toPoint.x) / 2;
            
            // Create smooth arc with multiple control points
            const route = [
                fromPoint,
                { x: fromPoint.x + (midX - fromPoint.x) * 0.3, y: fromPoint.y - 20 },
                { x: midX, y: minY },
                { x: toPoint.x - (toPoint.x - midX) * 0.3, y: toPoint.y - 20 },
                toPoint
            ];
            
            return isRouteValid(route, excludeEntities) ? route : null;
        }
        
        function createLowArcRoute(fromPoint, toPoint, obstructions, excludeEntities) {
            const maxY = Math.max(...obstructions.map(e => {
                const entityHeight = config.headerHeight + (e.fields.length * config.entityFieldHeight) + (config.entityPadding * 2) + 4;
                return e.y + entityHeight;
            })) + 50; // Lower clearance
            const midX = (fromPoint.x + toPoint.x) / 2;
            
            const route = [
                fromPoint,
                { x: fromPoint.x + (midX - fromPoint.x) * 0.3, y: fromPoint.y + 20 },
                { x: midX, y: maxY },
                { x: toPoint.x - (toPoint.x - midX) * 0.3, y: toPoint.y + 20 },
                toPoint
            ];
            
            return isRouteValid(route, excludeEntities) ? route : null;
        }
        
        function createLeftDetourRoute(fromPoint, toPoint, obstructions, excludeEntities) {
            const minX = Math.min(...obstructions.map(e => e.x)) - 50;
            const midY = (fromPoint.y + toPoint.y) / 2;
            
            const route = [
                fromPoint,
                { x: minX, y: fromPoint.y },
                { x: minX, y: midY },
                { x: minX, y: toPoint.y },
                toPoint
            ];
            
            return isRouteValid(route, excludeEntities) ? route : null;
        }
        
        function createRightDetourRoute(fromPoint, toPoint, obstructions, excludeEntities) {
            const maxX = Math.max(...obstructions.map(e => e.x + config.entityWidth)) + 50;
            const midY = (fromPoint.y + toPoint.y) / 2;
            
            const route = [
                fromPoint,
                { x: maxX, y: fromPoint.y },
                { x: maxX, y: midY },
                { x: maxX, y: toPoint.y },
                toPoint
            ];
            
            return isRouteValid(route, excludeEntities) ? route : null;
        }
        
        function createComplexRoute(fromPoint, toPoint, obstructions, excludeEntities) {
            // For very complex scenarios, create a route that goes around the cluster
            const bounds = {
                minX: Math.min(...obstructions.map(e => e.x)) - 60,
                maxX: Math.max(...obstructions.map(e => e.x + config.entityWidth)) + 60,
                minY: Math.min(...obstructions.map(e => e.y)) - 60,
                maxY: Math.max(...obstructions.map(e => {
                    const entityHeight = config.headerHeight + (e.fields.length * config.entityFieldHeight) + (config.entityPadding * 2) + 4;
                    return e.y + entityHeight;
                })) + 60
            };
            
            // Choose best corner route based on from/to positions
            const routes = [];
            
            // Top-left corner route
            routes.push([
                fromPoint,
                { x: bounds.minX, y: fromPoint.y },
                { x: bounds.minX, y: bounds.minY },
                { x: toPoint.x, y: bounds.minY },
                toPoint
            ]);
            
            // Bottom-right corner route
            routes.push([
                fromPoint,
                { x: bounds.maxX, y: fromPoint.y },
                { x: bounds.maxX, y: bounds.maxY },
                { x: toPoint.x, y: bounds.maxY },
                toPoint
            ]);
            
            const validRoutes = routes.filter(route => isRouteValid(route, excludeEntities));
            if (validRoutes.length === 0) return null;
            
            return validRoutes.reduce((best, current) => {
                return calculateRouteLength(current) < calculateRouteLength(best) ? current : best;
            });
        }
        
        function isRouteValid(route, excludeEntities) {
            for (let i = 0; i < route.length - 1; i++) {
                const segmentObstructed = entities.some(entity => 
                    !excludeEntities.includes(entity.id) && 
                    lineIntersectsEntity(route[i], route[i + 1], entity, excludeEntities)
                );
                if (segmentObstructed) return false;
            }
            return true;
        }


        function calculateRouteLength(route) {
            let length = 0;
            for (let i = 0; i < route.length - 1; i++) {
                const dx = route[i + 1].x - route[i].x;
                const dy = route[i + 1].y - route[i].y;
                length += Math.sqrt(dx * dx + dy * dy);
            }
            return length;
        }

        function generateSimpleControlPoints(fromPoint, toPoint) {
            const dx = toPoint.x - fromPoint.x;
            const dy = toPoint.y - fromPoint.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Use smaller control distance for cleaner curves
            const controlDistance = Math.min(distance * 0.2, 80);
            
            let cp1, cp2;
            
            // Create gentle S-curves that are less likely to intersect entities
            if (Math.abs(dx) > Math.abs(dy)) {
                // Horizontal dominant
                cp1 = {
                    x: fromPoint.x + Math.sign(dx) * controlDistance,
                    y: fromPoint.y + Math.sign(dy) * 10
                };
                cp2 = {
                    x: toPoint.x - Math.sign(dx) * controlDistance,
                    y: toPoint.y - Math.sign(dy) * 10
                };
            } else {
                // Vertical dominant
                cp1 = {
                    x: fromPoint.x + Math.sign(dx) * 10,
                    y: fromPoint.y + Math.sign(dy) * controlDistance
                };
                cp2 = {
                    x: toPoint.x - Math.sign(dx) * 10,
                    y: toPoint.y - Math.sign(dy) * controlDistance
                };
            }
            
            return [fromPoint, cp1, cp2, toPoint];
        }

        function generateControlPoints(fromPoint, toPoint, relationship, fromEntity, toEntity) {
            return findRouteAroundEntities(fromPoint, toPoint, fromEntity, toEntity, relationship);
        }

        // Draw entity function
        function drawEntity(entity) {
            const color = config.colors[entity.area] || { fill: '#f3f4f6', stroke: '#9ca3af', header: '#6b7280' };
            const visibleFields = entity.fields; // Show all fields comprehensively
            
            // Calculate dynamic entity width based on text content
            let maxTextWidth = 0;
            
            // Create temporary group to measure text
            const tempGroup = g.append('g').style('opacity', 0);
            
            // Measure entity name width (accounting for icon space)
            const entityNameText = tempGroup.append('text')
                .attr('class', 'entity-header')
                .text(entity.name);
            maxTextWidth = Math.max(maxTextWidth, entityNameText.node().getComputedTextLength() + 30); // Add space for larger icon
            
            // Measure all field text widths
            visibleFields.forEach((field, i) => {
                const prefix = field.isPK ? 'PK ' : field.isFK ? 'FK ' : field.required ? '• ' : '  ';
                let fullText = `${prefix}${field.name}: ${field.type}`;
                
                const tempText = tempGroup.append('text')
                    .attr('class', 'entity-field')
                    .text(fullText);
                
                const textWidth = tempText.node().getComputedTextLength();
                maxTextWidth = Math.max(maxTextWidth, textWidth);
            });
            
            tempGroup.remove(); // Remove temporary group
            
            // Calculate entity width with padding (minimum 180px, or text width + padding)
            const entityWidth = Math.max(config.entityWidth, maxTextWidth + 16); // 8px padding on each side
            const entityHeight = config.headerHeight + (visibleFields.length * config.entityFieldHeight) + (config.entityPadding * 2) + 4;
            
            // Store dynamic width on entity for other functions to use
            entity.actualWidth = entityWidth;
            
            const entityGroup = g.append('g')
                .attr('class', 'entity')
                .attr('data-area', entity.area)
                .attr('data-id', entity.id)
                .attr('transform', `translate(${entity.x}, ${entity.y})`);

            // Entity background
            entityGroup.append('rect')
                .attr('width', entityWidth)
                .attr('height', entityHeight)
                .attr('fill', color.fill)
                .attr('stroke', color.stroke)
                .attr('stroke-width', 1)
                .attr('rx', 6);

            // Header
            entityGroup.append('rect')
                .attr('width', entityWidth)
                .attr('height', config.headerHeight)
                .attr('fill', color.header)
                .attr('rx', 6);
                
            entityGroup.append('rect')
                .attr('y', config.headerHeight - 6)
                .attr('width', entityWidth)
                .attr('height', 6)
                .attr('fill', color.header);

            // Entity name
            entityGroup.append('text')
                .attr('class', 'entity-header')
                .attr('x', (entityWidth - 26) / 2) // Shift left to account for larger icon
                .attr('y', config.headerHeight / 2 + 3)
                .attr('text-anchor', 'middle')
                .attr('fill', 'white')
                .text(entity.name);
            
            // GitHub discussion icon
            const discussionIcon = entityGroup.append('use')
                .attr('class', 'discussion-icon')
                .attr('href', '#github-discussion-icon')
                .attr('x', entityWidth - 22)
                .attr('y', config.headerHeight / 2 - 8)
                .attr('width', 16)
                .attr('height', 16)
                .style('cursor', 'pointer');
            
            // Add tooltip for discussion icon
            discussionIcon.append('title')
                .text(`Discuss ${entity.name} schema on GitHub`);
            
            // Discussion icon click handler
            discussionIcon.on('click', function(event) {
                event.stopPropagation(); // Prevent entity click
                
                // Entity to discussion URL mapping
                const discussionUrls = {
                    'TraceableUnit': 'https://github.com/carbondirect/BOOST/discussions/166',
                    'GeographicData': 'https://github.com/carbondirect/BOOST/discussions/167',
                    'TrackingPoint': 'https://github.com/carbondirect/BOOST/discussions/168',
                    'MeasurementRecord': 'https://github.com/carbondirect/BOOST/discussions/169',
                    'LocationHistory': 'https://github.com/carbondirect/BOOST/discussions/170',
                    'DataReconciliation': 'https://github.com/carbondirect/BOOST/discussions/171',
                    'SpeciesComponent': 'https://github.com/carbondirect/BOOST/discussions/172',
                    'MaterialProcessing': 'https://github.com/carbondirect/BOOST/discussions/173',
                    'ProcessingHistory': 'https://github.com/carbondirect/BOOST/discussions/174',
                    'MoistureContent': 'https://github.com/carbondirect/BOOST/discussions/175',
                    'Transaction': 'https://github.com/carbondirect/BOOST/discussions/176',
                    'Operator': 'https://github.com/carbondirect/BOOST/discussions/177',
                    'SupplyBase': 'https://github.com/carbondirect/BOOST/discussions/178',
                    'BiometricIdentifier': 'https://github.com/carbondirect/BOOST/discussions/179',
                    // Existing discussions for other entities
                    'SupplyBaseReport': 'https://github.com/carbondirect/BOOST/discussions/106',
                    'ProductGroup': 'https://github.com/carbondirect/BOOST/discussions/105',
                    'Material': 'https://github.com/carbondirect/BOOST/discussions/94',
                    'Organization': 'https://github.com/carbondirect/BOOST/discussions/90',
                    'Customer': 'https://github.com/carbondirect/BOOST/discussions/96',
                    'Supplier': 'https://github.com/carbondirect/BOOST/discussions/95',
                    'EnergyCarbonData': 'https://github.com/carbondirect/BOOST/discussions/101',
                    'TransactionBatch': 'https://github.com/carbondirect/BOOST/discussions/98',
                    'SalesDeliveryDocument': 'https://github.com/carbondirect/BOOST/discussions/100',
                    'CertificationScheme': 'https://github.com/carbondirect/BOOST/discussions/91',
                    'Certificate': 'https://github.com/carbondirect/BOOST/discussions/92',
                    'CertificationBody': 'https://github.com/carbondirect/BOOST/discussions/93',
                    'Audit': 'https://github.com/carbondirect/BOOST/discussions/107',
                    'VerificationStatement': 'https://github.com/carbondirect/BOOST/discussions/103',
                    'MassBalanceAccount': 'https://github.com/carbondirect/BOOST/discussions/104',
                    'Claim': 'https://github.com/carbondirect/BOOST/discussions/99',
                    'DTSTransaction': 'https://github.com/carbondirect/BOOST/discussions/97'
                };
                
                const discussionUrl = discussionUrls[entity.name] || 'https://github.com/carbondirect/BOOST/discussions';
                window.open(discussionUrl, '_blank');
            });

            // Fields - simple single line text
            visibleFields.forEach((field, i) => {
                const fieldY = config.headerHeight + config.entityPadding + (i * config.entityFieldHeight) + 8;
                let fieldClass = 'entity-field';
                
                if (field.isPK) fieldClass = 'entity-pk';
                else if (field.isFK) fieldClass = 'entity-fk';
                else if (field.required) fieldClass = 'entity-required';
                
                const prefix = field.isPK ? 'PK ' : field.isFK ? 'FK ' : field.required ? '• ' : '  ';
                
                entityGroup.append('text')
                    .attr('class', fieldClass)
                    .attr('x', 4)
                    .attr('y', fieldY)
                    .text(`${prefix}${field.name}: ${field.type}`);
            });


            // Events
            entityGroup.on('mouseover', function(event) {
                const fieldsList = entity.fields
                    .map(f => `<code>${f.name}</code>: ${f.type}${f.required ? ' *' : ''}${f.isPK ? ' (PK)' : ''}${f.isFK ? ' (FK)' : ''}`)
                    .join('<br/>');
                
                tooltip.style('opacity', 1)
                    .html(`<strong>${entity.name}</strong><br/><em>${entity.area.replace('_', ' ')}</em><br/><br/>${entity.description}<br/><br/>${fieldsList}`)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
            })
            .on('mouseout', () => tooltip.style('opacity', 0))
            .on('click', () => highlightRelationships(entity.id));

            return entityGroup;
        }

        // Draw curved relationships
        function drawRelationships() {
            g.selectAll('.relationship-group').remove();
            
            relationships.forEach((rel, index) => {
                const fromEntity = entities.find(e => e.id === rel.from);
                const toEntity = entities.find(e => e.id === rel.to);
                
                if (fromEntity && toEntity) {
                    drawCurvedRelationship(fromEntity, toEntity, rel);
                }
            });
        }

        function drawCurvedRelationship(fromEntity, toEntity, rel) {
            const fromPoint = getConnectionPoint(fromEntity, toEntity, rel, true);
            const toPoint = getConnectionPoint(toEntity, fromEntity, rel, false);
            const controlPoints = generateControlPoints(fromPoint, toPoint, rel, fromEntity, toEntity);
            
            const relationshipGroup = g.append('g')
                .attr('class', 'relationship-group')
                .attr('data-from', rel.from)
                .attr('data-to', rel.to);

            // Create curved path
            const line = d3.line()
                .x(d => d.x)
                .y(d => d.y)
                .curve(d3[config.curveType]);

            const path = relationshipGroup.append('path')
                .attr('class', `relationship relationship-${rel.type}`)
                .attr('d', line(controlPoints));

            // Enhanced Crow's foot notation with proper angles
            const lastPoint = controlPoints[controlPoints.length - 1];
            const secondLastPoint = controlPoints[controlPoints.length - 2];
            const endAngle = Math.atan2(lastPoint.y - secondLastPoint.y, lastPoint.x - secondLastPoint.x);
            
            // Draw notation at the "to" end (many side)
            if (rel.toCard === 'many') {
                drawCrowsFoot(relationshipGroup, toPoint.x, toPoint.y, endAngle);
            } else {
                drawSingleMark(relationshipGroup, toPoint.x, toPoint.y, endAngle);
            }
            
            // Draw notation at the "from" end (one side)
            const firstPoint = controlPoints[0];
            const secondPoint = controlPoints[1];
            const startAngle = Math.atan2(secondPoint.y - firstPoint.y, secondPoint.x - firstPoint.x);
            
            if (rel.fromCard === 'many') {
                drawCrowsFoot(relationshipGroup, fromPoint.x, fromPoint.y, startAngle + Math.PI);
            } else {
                drawSingleMark(relationshipGroup, fromPoint.x, fromPoint.y, startAngle + Math.PI);
            }

            // Add field connection indicators
            if (fromPoint.fieldName) {
                relationshipGroup.append('circle')
                    .attr('cx', fromPoint.x)
                    .attr('cy', fromPoint.y)
                    .attr('r', 2)
                    .attr('fill', '#2563eb')
                    .attr('stroke', 'white')
                    .attr('stroke-width', 1);
            }
            
            if (toPoint.fieldName) {
                relationshipGroup.append('circle')
                    .attr('cx', toPoint.x)
                    .attr('cy', toPoint.y)
                    .attr('r', 2)
                    .attr('fill', '#dc2626')
                    .attr('stroke', 'white')
                    .attr('stroke-width', 1);
            }

            // Smart label positioning to avoid entity overlaps
            const pathLength = path.node().getTotalLength();
            let labelPoint = path.node().getPointAtLength(pathLength / 2);
            
            // Check if label would overlap with any entity and adjust position
            labelPoint = findBestLabelPosition(path, rel.label, fromEntity, toEntity);
            
            const textWidth = rel.label.length * 4.5;
            
            // Only show label if it doesn't cause clutter in central areas
            const shouldShowLabel = shouldDisplayLabel(labelPoint, rel, fromEntity, toEntity);
            
            if (shouldShowLabel) {
                relationshipGroup.append('rect')
                    .attr('class', 'label-background')
                    .attr('x', labelPoint.x - textWidth/2 - 3)
                    .attr('y', labelPoint.y - 7)
                    .attr('width', textWidth + 6)
                    .attr('height', 14)
                    .attr('rx', 3);
                    
                relationshipGroup.append('text')
                    .attr('class', 'relationship-label')
                    .attr('x', labelPoint.x)
                    .attr('y', labelPoint.y + 3)
                    .text(rel.label);
            }
                
            // Add tooltip functionality to the entire relationship group
            relationshipGroup
                .on('mouseover', function(event) {
                    const relationshipDescription = generateRelationshipDescription(rel, fromEntity, toEntity, fromPoint, toPoint);
                    
                    tooltip.style('opacity', 1)
                        .html(relationshipDescription)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                        
                    // Highlight the relationship
                    d3.select(this).selectAll('.relationship')
                        .style('stroke-width', '3px')
                        .style('filter', 'drop-shadow(0 2px 6px rgba(0,0,0,0.3))');
                })
                .on('mouseout', function() {
                    tooltip.style('opacity', 0);
                    
                    // Reset relationship styling
                    d3.select(this).selectAll('.relationship-identifying')
                        .style('stroke-width', '1.5px')
                        .style('filter', 'none');
                    d3.select(this).selectAll('.relationship-non-identifying')
                        .style('stroke-width', '1.2px')
                        .style('filter', 'none');
                })
                .on('click', function(event) {
                    event.stopPropagation();
                    highlightRelationshipEntities(fromEntity.id, toEntity.id);
                    showRelationshipFocusMessage(rel, fromEntity, toEntity);
                })
                .style('cursor', 'pointer');
        }
        
        function generateRelationshipDescription(rel, fromEntity, toEntity, fromPoint, toPoint) {
            const cardinalityText = getCardinalityText(rel.fromCard, rel.toCard);
            const relationshipTypeText = rel.type === 'identifying' ? 'Identifying' : 'Non-identifying';
            
            let description = `<div style="max-width: 350px;">`;
            description += `<strong>${rel.label}</strong><br/>`;
            description += `<em>${relationshipTypeText} Relationship</em><br/><br/>`;
            
            description += `<strong>From:</strong> ${fromEntity.name}<br/>`;
            if (fromPoint.fieldName) {
                description += `<strong>Field:</strong> <code>${fromPoint.fieldName}</code><br/>`;
            }
            
            description += `<strong>To:</strong> ${toEntity.name}<br/>`;
            if (toPoint.fieldName) {
                description += `<strong>Field:</strong> <code>${toPoint.fieldName}</code><br/>`;
            }
            
            description += `<br/><strong>Cardinality:</strong> ${cardinalityText}<br/>`;
            
            // Add business context based on relationship
            const businessContext = getBusinessContext(rel, fromEntity, toEntity);
            if (businessContext) {
                description += `<br/><strong>Business Rule:</strong><br/>${businessContext}`;
            }
            
            description += `</div>`;
            return description;
        }
        
        function getCardinalityText(fromCard, toCard) {
            const fromText = fromCard === 'many' ? 'Many' : 'One';
            const toText = toCard === 'many' ? 'Many' : 'One';
            return `${fromText} to ${toText}`;
        }
        
        function getBusinessContext(rel, fromEntity, toEntity) {
            const contexts = {
                // Core traceability relationships
                'has_processing_timeline': `Each ${fromEntity.name} maintains a complete chronological record of all processing events through ${toEntity.name} entries.`,
                'undergoes_processing': `${fromEntity.name} records are transformed through ${toEntity.name} operations, creating an audit trail of material transformations.`,
                'contains_species': `Each ${fromEntity.name} can contain multiple ${toEntity.name} entries, allowing for mixed-species biomass tracking.`,
                'generates_measurements': `${fromEntity.name} operations produce quantitative ${toEntity.name} data for quality control and verification.`,
                'identified_by': `${fromEntity.name} entities use ${toEntity.name} for media-interruption-free tracking via biometric signatures.`,
                'has_location_history': `${fromEntity.name} movements are tracked through ${toEntity.name} records for complete supply chain visibility.`,
                
                // Organizational relationships
                'has': `${fromEntity.name} entities possess ${toEntity.name} documents that validate their operational credentials and compliance status.`,
                'certifies_against': `${toEntity.name} documents reference specific ${toEntity.name} standards for sustainability validation.`,
                'issued_by': `${toEntity.name} documents are officially issued and validated by accredited ${toEntity.name} organizations.`,
                'employs': `${fromEntity.name} entities maintain ${toEntity.name} records for personnel management and operational oversight.`,
                
                // Material and supply chain
                'manages_supply_base': `${fromEntity.name} entities oversee ${toEntity.name} areas for sustainable biomass sourcing and harvesting operations.`,
                'originates_tru': `${fromEntity.name} areas serve as the source locations where ${toEntity.name} entities are initially created and harvested.`,
                'material_type_reference': `${fromEntity.name} specifications define the material characteristics and properties for ${toEntity.name} entities.`,
                
                // Transaction management
                'contains': `${fromEntity.name} records group multiple ${toEntity.name} entries for efficient transaction processing and logistics.`,
                'includes_tru': `${fromEntity.name} records can include multiple ${toEntity.name} entities for bulk material transfers.`,
                'documented_by': `${fromEntity.name} operations are formally recorded through ${toEntity.name} for legal and compliance purposes.`,
                
                // Geographic and location
                'provides_harvest_location': `${fromEntity.name} entries specify the exact geographic coordinates where ${toEntity.name} entities were originally harvested.`,
                'provides_current_location': `${fromEntity.name} entries track the present geographic position of ${toEntity.name} entities in the supply chain.`,
                'defines_operational_area': `${fromEntity.name} entries establish the geographic boundaries for ${toEntity.name} operational activities.`,
                
                // Analytics and data
                'tracks': `${fromEntity.name} systems monitor and record ${toEntity.name} volumes for mass balance compliance and reporting.`,
                'categorizes': `${fromEntity.name} classifications organize ${toEntity.name} types for standardized processing and certification.`,
                'characterized_by': `${fromEntity.name} entities have associated ${toEntity.name} metrics for environmental impact assessment.`
            };
            
            return contexts[rel.label] || `${fromEntity.name} and ${toEntity.name} are connected through the "${rel.label}" relationship in the BOOST biomass traceability system.`;
        }
        
        function highlightRelationshipEntities(fromEntityId, toEntityId) {
            // Dim all entities except the connected ones
            g.selectAll('.entity').style('opacity', function() {
                const id = d3.select(this).attr('data-id');
                return (id === fromEntityId || id === toEntityId) ? 1 : 0.3;
            });
            
            // Highlight only the relevant relationship
            g.selectAll('.relationship-group').style('opacity', function() {
                const from = d3.select(this).attr('data-from');
                const to = d3.select(this).attr('data-to');
                return (from === fromEntityId && to === toEntityId) || 
                       (from === toEntityId && to === fromEntityId) ? 1 : 0.2;
            });
            
            // Reset after a delay
            setTimeout(() => {
                g.selectAll('.entity').style('opacity', 1);
                g.selectAll('.relationship-group').style('opacity', 0.8);
            }, 2000);
        }
        
        function showRelationshipFocusMessage(relationship, fromEntity, toEntity) {
            // Create a temporary message overlay
            const messageContainer = d3.select('body').append('div')
                .style('position', 'fixed')
                .style('top', '20px')
                .style('left', '50%')
                .style('transform', 'translateX(-50%)')
                .style('background', 'rgba(17, 24, 39, 0.95)')
                .style('color', 'white')
                .style('padding', '12px 20px')
                .style('border-radius', '8px')
                .style('font-size', '14px')
                .style('font-weight', '500')
                .style('z-index', '9999')
                .style('backdrop-filter', 'blur(8px)')
                .style('box-shadow', '0 4px 12px rgba(0,0,0,0.3)')
                .style('opacity', '0');
                
            messageContainer.html(`
                <div style="text-align: center;">
                    <div style="font-weight: 600; margin-bottom: 4px;">Relationship Focus</div>
                    <div style="font-size: 12px; color: #d1d5db;">
                        ${fromEntity.name} <span style="color: #60a5fa;">→</span> ${toEntity.name}
                    </div>
                    <div style="font-size: 11px; color: #9ca3af; margin-top: 4px;">
                        "${relationship.label}"
                    </div>
                </div>
            `);
                
            // Animate in
            messageContainer.transition()
                .duration(300)
                .style('opacity', '1');
                
            // Animate out and remove after delay
            setTimeout(() => {
                messageContainer.transition()
                    .duration(500)
                    .style('opacity', '0')
                    .remove();
            }, 2500);
        }

        function drawCrowsFoot(g, x, y, angle) {
            const size = 7;  // Increased size for better visibility
            const length = 12; // Increased length
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            
            // Draw the three lines of the crow's foot
            const offsets = [-size, 0, size];
            offsets.forEach(offset => {
                const perpCos = Math.cos(angle + Math.PI / 2);
                const perpSin = Math.sin(angle + Math.PI / 2);
                
                g.append('line')
                    .attr('class', 'crowsfoot-line')
                    .attr('x1', x)
                    .attr('y1', y)
                    .attr('x2', x - cos * length + perpCos * offset)
                    .attr('y2', y - sin * length + perpSin * offset);
            });
            
            // Add a small circle at the connection point for "many" relationships
            g.append('circle')
                .attr('cx', x)
                .attr('cy', y)
                .attr('r', 2)
                .attr('fill', 'white')
                .attr('stroke', '#374151')
                .attr('stroke-width', 1.5);
        }

        function drawSingleMark(g, x, y, angle) {
            const perpCos = Math.cos(angle + Math.PI / 2);
            const perpSin = Math.sin(angle + Math.PI / 2);
            const length = 6; // Length of the single mark
            
            // Draw perpendicular line for "one" relationship
            g.append('line')
                .attr('class', 'crowsfoot-line')
                .attr('x1', x + perpCos * length)
                .attr('y1', y + perpSin * length)
                .attr('x2', x - perpCos * length)
                .attr('y2', y - perpSin * length);
                
            // Add a small circle at the connection point for "one" relationships
            g.append('circle')
                .attr('cx', x)
                .attr('cy', y)
                .attr('r', 1.5)
                .attr('fill', '#374151')
                .attr('stroke', 'white')
                .attr('stroke-width', 0.5);
        }

        // Control functions
        function setCurveType(curveType) {
            config.curveType = curveType;
            drawRelationships();
            
            d3.selectAll('.area-controls .control-btn').classed('active', false);
            d3.select(event.target).classed('active', true);
        }
        
        function toggleLabels() {
            const container = d3.select('#svg-container');
            const button = d3.select('#label-toggle');
            const isHidden = container.classed('labels-hidden');
            
            container.classed('labels-hidden', !isHidden);
            button.text(isHidden ? '🏷️' : '🏷️⚹');
            button.attr('title', isHidden ? 'Toggle relationship labels' : 'Show relationship labels');
        }
        
        function toggleTruFocus() {
            const container = d3.select('#svg-container');
            const button = d3.select('#tru-focus');
            const isFocused = container.classed('tru-focus');
            
            container.classed('tru-focus', !isFocused);
            button.text(isFocused ? '🎯' : '🔍');
            button.attr('title', isFocused ? 'Focus on essential TraceableUnit relationships' : 'Show all relationships');
            
            if (!isFocused) {
                // Mark essential relationships and entities
                markEssentialElements();
            }
        }
        
        function markEssentialElements() {
            // Essential TraceableUnit relationships (only the most critical)
            const essentialRelationships = [
                'material_type_reference',
                'includes_tru',
                'originates_tru',
                'manages'
            ];
            
            // Essential entities connected to TraceableUnit
            const essentialEntities = [
                'Material',
                'Transaction', 
                'SupplyBase',
                'Organization'
            ];
            
            // Mark essential relationship groups
            g.selectAll('.relationship-group').each(function() {
                const group = d3.select(this);
                const fromEntity = group.attr('data-from');
                const toEntity = group.attr('data-to');
                
                // Check if this is an essential TraceableUnit relationship
                const isEssential = (fromEntity === 'TraceableUnit' || toEntity === 'TraceableUnit') &&
                                   relationships.some(rel => 
                                       (rel.from === fromEntity && rel.to === toEntity || 
                                        rel.from === toEntity && rel.to === fromEntity) &&
                                       essentialRelationships.includes(rel.label)
                                   );
                
                group.attr('data-essential', isEssential);
            });
            
            // Mark essential entities
            g.selectAll('.entity').each(function() {
                const entity = d3.select(this);
                const entityId = entity.attr('data-id');
                const isEssential = entityId === 'TraceableUnit' || essentialEntities.includes(entityId);
                entity.attr('data-essential', isEssential);
            });
        }

        function showAll() {
            g.selectAll('.entity').style('opacity', 1);
            g.selectAll('.relationship-group').style('opacity', 0.8);
            updateActiveButton(0);
        }

        function filterByArea(area) {
            g.selectAll('.entity').style('opacity', function() {
                return d3.select(this).attr('data-area') === area ? 1 : 0.2;
            });
            g.selectAll('.relationship-group').style('opacity', 0.3);
        }

        function highlightRelationships(entityId) {
            g.selectAll('.relationship-group').style('opacity', function() {
                const from = d3.select(this).attr('data-from');
                const to = d3.select(this).attr('data-to');
                return (from === entityId || to === entityId) ? 1 : 0.2;
            });
            
            g.selectAll('.entity').style('opacity', function() {
                const id = d3.select(this).attr('data-id');
                const isConnected = relationships.some(rel => 
                    (rel.from === entityId && rel.to === id) || 
                    (rel.to === entityId && rel.from === id)
                );
                return (id === entityId || isConnected) ? 1 : 0.3;
            });
        }

        function updateActiveButton(index) {
            d3.selectAll('.controls .btn').classed('active', false);
            d3.selectAll('.controls .btn').nodes()[index].classList.add('active');
        }

        function exportDiagram() {
            const svgElement = document.getElementById('erd-svg');
            const serializer = new XMLSerializer();
            const svgString = serializer.serializeToString(svgElement);
            
            const blob = new Blob([svgString], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'boost-erd-interactive-v2-2-smart-routing.svg';
            a.click();
            
            URL.revokeObjectURL(url);
        }

        // Global entities variable
        let entities = [];

        // Initialize
        async function initializeVisualization() {
            try {
                // Load entities from schema files
                entities = await loadEntitiesFromSchema();
                console.log(`Loaded ${entities.length} entities from schema files`);
                
                console.log(`Total relationships available: ${relationships.length}`);
                
                // Fallback to static entities if schema loading fails
                if (entities.length === 0) {
                    console.warn('No entities loaded from schemas, falling back to static entities');
                    entities = staticEntities;
                }
                
                // Draw entities
                entities.forEach(entity => {
                    drawEntity(entity);
                });
                
                drawRelationships();
                updateZoomIndicator();
                
                // Initial fit to screen
                setTimeout(fitToScreen, 100);
            } catch (error) {
                console.error('Error initializing visualization:', error);
                // Fallback to static entities
                entities = staticEntities;
                entities.forEach(entity => {
                    drawEntity(entity);
                });
                drawRelationships();
                updateZoomIndicator();
                setTimeout(fitToScreen, 100);
            }
        }

        // Start
        initializeVisualization();
    </script>
</body>
</html>
